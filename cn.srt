1
00:00:00,000 --> 00:00:06,600
欢迎来到这个完整的Elixir课程。这门课程由Octolium创建，涵盖了Elixir的基础知识

2
00:00:06,600 --> 00:00:12,440
以及函数式编程，包括递归、模式匹配和Actor模型。

3
00:00:12,920 --> 00:00:18,880
该课程还涵盖了数据类型、流程控制以及混合项目等高级主题。

4
00:00:18,880 --> 00:00:24,000
列表操作。完成本课程后，您将能够构建自己的Elixir应用程序。

5
00:00:24,000 --> 00:00:28,640
并自信地在您的项目中应用函数式编程概念。

6
00:00:28,640 --> 00:00:33,000
嗨，欢迎来到这门课程，关于Elixir的函数式编程。

7
00:00:33,640 --> 00:00:38,280
现在这门课程着重于学习函数式编程的基础知识

8
00:00:38,800 --> 00:00:44,140
我们将通过使用Elixir编程语言来学习这些基础知识。

9
00:00:44,400 --> 00:00:49,280
现在这门课程适合那些具有一定编程基础的人，

10
00:00:49,380 --> 00:00:54,420
但你不需要是专家。也许你懂一点JavaScript，

11
00:00:54,420 --> 00:01:01,660
Python、Java或C++都可以。不重要的是，你需要有一些编程经验。

12
00:01:01,740 --> 00:01:06,940
现在让我们来介绍一下这个教程系列中涉及的所有主题。

13
00:01:07,540 --> 00:01:12,440
那么首先，正如你所看到的，我们将学习所有基本的基础知识

14
00:01:12,440 --> 00:01:17,760
函数式编程。之后，我们还将学习Elixir的所有基础知识。

15
00:01:18,100 --> 00:01:22,260
你可以看到我们也将涵盖Elixir的所有类型系统。

16
00:01:22,260 --> 00:01:28,640
然后我们将学习如何使用mix创建项目。所以这是基础教程项目，

17
00:01:28,640 --> 00:01:35,100
我们将要创建。而作为最后的巅峰项目，我们将创建一个真实的

18
00:01:35,100 --> 00:01:39,800
统计库。好了，这就是本视频的内容。我希望你对学习更多感到兴奋

19
00:01:39,800 --> 00:01:44,600
关于函数式编程和Elixir的一般知识，我会在下一个视频中和你见面。

20
00:01:45,720 --> 00:01:51,220
那么Elixir到底是什么？现在，Elixir是一种函数式编程语言。

21
00:01:51,860 --> 00:01:58,320
现在，为什么我要谈论Elixir呢？嗯，让我通过问你一个问题来回答。

22
00:01:59,040 --> 00:02:06,080
你上一次使用WhatsApp或Discord是什么时候？嗯，这两个应用程序，

23
00:02:06,440 --> 00:02:12,920
它们在同一个虚拟机上运行。现在准确地说，Discord是由Elixir驱动的，

24
00:02:13,280 --> 00:02:19,400
WhatsApp则由Erlang驱动。你一定在想Erlang和Elixir有什么关系，

25
00:02:19,400 --> 00:02:26,720
嗯，Erlang也是一种函数式编程语言，而Elixir是在Erlang的基础上构建的。

26
00:02:27,580 --> 00:02:32,560
这两种语言都是编译的，它们在Erlang虚拟机上运行，

27
00:02:32,680 --> 00:02:39,540
也被称为Beam。你可以将其想象成类似于Java虚拟机。

28
00:02:40,240 --> 00:02:46,980
你有很多语言，比如Java、Kotlin、Clojure和Scala。所有这些语言，

29
00:02:46,980 --> 00:02:53,940
它们都编译并在Java虚拟机上运行。Elixir也是如此。

30
00:02:54,180 --> 00:03:00,260
Elixir被编译后在Beam虚拟机上运行。现在你一定在想，

31
00:03:00,340 --> 00:03:07,540
这些东西为什么重要？Elixir有什么了不起的地方？嗯，首先，它是一种函数式语言。

32
00:03:07,740 --> 00:03:15,580
其次，它默认支持不可变性。为什么不可变性如此重要呢？嗯，那是因为，

33
00:03:15,580 --> 00:03:22,740
因此，我们可以具有巨大的可扩展性。你一定想知道为什么。因为既然所有的

34
00:03:22,740 --> 00:03:28,160
数据类型是不可变的，这意味着线程或其他对象没有机会

35
00:03:28,160 --> 00:03:33,860
或者其他函数意外更改值。因此状态被保留，

36
00:03:33,940 --> 00:03:40,060
这就是系统变得更具可伸缩性的原因。Elixir最强大的地方

37
00:03:40,060 --> 00:03:46,580
是它支持容错。假设一个节点崩溃或任何一个我们的角色或

38
00:03:46,580 --> 00:03:52,000
处理器崩溃，那么它们可以自动恢复，可以恢复到其自己的

39
00:03:52,000 --> 00:03:59,660
状态。这就是为什么你可以通过使用

40
00:03:59,660 --> 00:04:05,500
Elixir来创建非常分布式和容错系统。所以如果你有兴趣学习Elixir，那么请继续关注，我会在下一个

41
00:04:05,500 --> 00:04:12,420
视频中见。再见。现在我们对Elixir有了更多的了解，但让我们试着理解我们

42
00:04:12,420 --> 00:04:19,860
通过函数式编程我们的意思。简单来说，它只是意味着我们的整个程序是由

43
00:04:19,860 --> 00:04:28,020
不同的功能。所以想象一下，这个 f of x 就是一种函数。让我来强调一下

44
00:04:28,020 --> 00:04:33,920
背景。所以这个绿色的东西。所以这是一个非常简单的函数。现在这个函数，

45
00:04:33,920 --> 00:04:41,360
它接收一个输入。假设输入是 x。现在这个函数将会转换这个数据

46
00:04:41,360 --> 00:04:48,660
从 x，这个数据将会转换成为一个叫做 y 的东西。所以这就是你的

47
00:04:48,660 --> 00:04:55,060
函数要做的事情。你的函数总是接受某种参数。它会

48
00:04:55,060 --> 00:05:01,160
转换这个数据，然后它总是会返回某种数据。现在这看起来可能非常

49
00:05:01,160 --> 00:05:08,260
简单，但它并不简单。创建纯函数背后有很多事情。

50
00:05:08,720 --> 00:05:14,700
所以让我们试着理解什么使函数式编程如此独特。首先显然是

51
00:05:14,700 --> 00:05:21,660
在函数式编程中，我们没有任何类或对象。接下来的一个是所有

52
00:05:21,660 --> 00:05:27,500
数据类型是不可变的。所以就像在整个程序中使用常量一样。

53
00:05:27,500 --> 00:05:32,800
现在你一定在想为什么我们需要不可变的数据类型或常量呢？

54
00:05:33,900 --> 00:05:40,840
答案是因为数据是不可变的，这意味着状态保持不变。

55
00:05:41,320 --> 00:05:48,560
而且如果状态保持不变，那意味着数据可以被复制和分发得更加容易。

56
00:05:48,560 --> 00:05:55,820
而且由于这些数据可以被分发，这意味着我们可以创建非常可扩展的系统。

57
00:05:55,820 --> 00:06:02,380
通过使用函数式编程，我们可以创建这样的系统。现在这就带我到下一个观点，我觉得这个观点可能会让我们有点震惊，

58
00:06:02,380 --> 00:06:09,820
那就是我们没有任何for循环。现在由于

59
00:06:09,820 --> 00:06:16,560
数据是不可变的，所以我们没有for循环。试着想象一下你通常的for循环。

60
00:06:17,260 --> 00:06:25,400
假设你有一个变量i等于零，i小于长度并且i加加。现在

61
00:06:25,400 --> 00:06:32,460
每次迭代都会增加变量i。这意味着数据

62
00:06:32,460 --> 00:06:40,240
在不断变异，但我们不能这样做，因为我们有不可变的数据类型。你必须

63
00:06:40,240 --> 00:06:46,340
那么有什么意义呢？我们如何在Elixir中进行迭代？但函数式编程

64
00:06:46,340 --> 00:06:54,280
Elixir有一种更好的循环方式，那就是使用递归。而我将要

65
00:06:54,280 --> 00:07:01,600
在下一个视频中详细讲解递归。那么递归是什么意思，为什么

66
00:07:01,600 --> 00:07:09,840
递归如此重要？让我们逐个解答这些问题。首先我们来看看什么

67
00:07:09,840 --> 00:07:17,680
递归是什么意思。简单来说，当您一次又一次地执行相同的任务时，可以说

68
00:07:17,680 --> 00:07:24,080
您正在执行递归。这意味着您可以看到我们有一个任务和这个任务

69
00:07:24,080 --> 00:07:32,460
一次又一次地调用自身。因此，您可以说我们处于递归状态。现在，如果

70
00:07:32,460 --> 00:07:40,240
递归如此简单，那么递归有什么了不起的？让我试着解释一下

71
00:07:40,240 --> 00:07:47,120
带您穿越时光之旅。您一定听说过世界七大奇迹。

72
00:07:47,120 --> 00:07:53,980
您有泰姬陵，您有中国长城，您有马丘比丘等等。

73
00:07:54,400 --> 00:08:00,900
但是如果你问我们每个人，你认为世界的奇迹是什么？答案会有所不同。

74
00:08:00,900 --> 00:08:07,880
会有所不同。让我们看看接下来会发生什么。所以他们是一些最聪明的家伙之一。

75
00:08:07,880 --> 00:08:15,100
星球上。所以他们是沃伦·巴菲特和伟大的查理·芒格。如果你问这些人，你会得到什么回答？

76
00:08:15,100 --> 00:08:20,100
他们认为世界奇迹之一？那么最有可能的答案会是

77
00:08:20,100 --> 00:08:26,660
复利。现在让我们看看接下来会发生什么。还有一个非常聪明的家伙

78
00:08:27,260 --> 00:08:33,660
正如你所想象的，这就是伟大的艾萨克·牛顿。如果你问牛顿

79
00:08:33,660 --> 00:08:40,540
世界上最伟大的奇迹，最有可能他会说是重力。所以要点就是

80
00:08:40,540 --> 00:08:48,000
我试图表达的是我们的感知因人而异。现在如果你问

81
00:08:48,000 --> 00:08:55,680
这个家伙，也就是我，我对世界上最伟大的奇迹有什么看法？而且就像你所想的

82
00:08:55,680 --> 00:09:03,720
你可以猜到我的答案会是递归。嗯，那并不完全正确。如果你想要一个非常诚实的答案

83
00:09:04,480 --> 00:09:12,720
那么我认为递归加突变，也就是递归突变是世界上最伟大的之一

84
00:09:12,720 --> 00:09:19,660
这个世界上最伟大的奇迹。听起来很混乱，是吗？别担心，现在是解释的时候了。

85
00:09:20,580 --> 00:09:27,580
只要考虑我们人类。我们所有人都有习惯，对吧？而且我们倾向于有相同的

86
00:09:27,580 --> 00:09:34,780
在很长一段时间里。那么你能说我们的思维处于递归状态吗？

87
00:09:34,780 --> 00:09:41,640
因为我们每天都在重复同样的习惯。你可能会说我们的习惯可以

88
00:09:41,640 --> 00:09:49,480
也会改变。嗯是的，它们可以改变，这就是我所指的突变。但试着考虑一下

89
00:09:49,480 --> 00:09:56,880
你的习惯不会在一夜之间发生剧变。你的习惯可能会在很长一段时间里改变

90
00:09:56,880 --> 00:10:03,640
所以你也可以说你的习惯变化是由于发生的小突变

91
00:10:03,640 --> 00:10:10,780
每天都发生。所以也许你可以说我们所有人都处于递归突变的状态。

92
00:10:11,920 --> 00:10:18,700
让我们试着变得更大一些。让我们试着思考地球本身。现在地球

93
00:10:18,700 --> 00:10:25,640
需要大约24小时才能回到完全相同的位置。那么你能说地球也是

94
00:10:25,640 --> 00:10:32,700
在递归的状态中. 让我们尝试延展一下这种想法. 地区一直围着

95
00:10:32,700 --> 00:10:38,800
太阳公转. 12 个月一圈

96
00:10:38,800 --> 00:10:45,240
不过每四年我们会得到一个闰年, 也就表示一年多了一天. 你可以说

97
00:10:45,240 --> 00:10:52,200
地球处于递归变化中. 现在我们试着将概念拓展出太阳系.

98
00:10:52,200 --> 00:11:00,280
你一定听说过整个宇宙在不停地膨胀

99
00:11:01,540 --> 00:11:09,060
在 136 亿年前, 宇宙中什么都没有. 宇宙大爆炸发生后地球

100
00:11:09,320 --> 00:11:18,900
星星, 太阳和整个星系才出现, 这是怎么发送的? (这段有些莫名奇妙)

101
00:11:18,900 --> 00:11:26,980
我可以用一个递归方法来解释这一切.

102
00:11:27,520 --> 00:11:32,400
现在我们不需要了解所有知识, 你可以将问题留

103
00:11:32,400 --> 00:11:38,140
在未来，当你对elixir有了更多了解的时候。现在让我们试试看怎么样

104
00:11:38,140 --> 00:11:46,520
宇宙可以从无中膨胀。所以如果我说宇宙，现在是大爆炸的时候了

105
00:11:47,160 --> 00:11:54,080
大爆炸是一个不带参数的函数。现在让我们看看会发生什么。

106
00:11:54,460 --> 00:12:00,980
好的，大爆炸发生了。在那之后，你可以看到宇宙的大小是零，一，

107
00:12:01,180 --> 00:12:07,740
二，三，四，而且大小不断扩大。现在让我停下来，否则

108
00:12:07,740 --> 00:12:13,700
这将无限进行下去。那么到底发生了什么？你可以看到我有一个函数

109
00:12:13,700 --> 00:12:21,240
称为expand，在最后该函数再次调用自身，但这次我们

110
00:12:21,240 --> 00:12:27,160
只是改变状态。我写了状态加一，但想象一下这不是加一。

111
00:12:27,620 --> 00:12:32,580
我们正在引发某种变异，这就是这个符号的意义所在。

112
00:12:33,980 --> 00:12:40,620
现在这就将我带到了最后一个观点。所以你可以想象宇宙的本质是什么。

113
00:12:40,620 --> 00:12:47,460
递归。这意味着我们为编程而学习的所有数学也是递归的。

114
00:12:47,460 --> 00:12:54,960
在本质上，这种递归的概念对于函数式编程来说是自然而然的。所以现在我们

115
00:12:54,960 --> 00:13:02,480
明白了，我们必须经历一段非常漫长的旅程才能理解什么是递归，以及其中的关键点。

116
00:13:02,480 --> 00:13:09,480
它有什么重要性。现在让我们看看如何安装Elixir。所以你可以去

117
00:13:09,480 --> 00:13:16,380
前往elixirlang.org这个网站，然后点击安装，如果你使用的是

118
00:13:16,380 --> 00:13:22,480
Windows系统，你可以点击Windows。然后你可以从这里下载安装程序，按照指示

119
00:13:22,480 --> 00:13:28,780
上面已经说过，你只需要点击下一步，然后一直点击完成，如果你使用的是Mac系统

120
00:13:28,780 --> 00:13:35,780
你可以简单地使用brew来安装Elixir。所以如果你使用的是Mac系统，你可以打开终端

121
00:13:35,780 --> 00:13:43,000
输入brew install elixir，一旦你安装好Elixir，我希望你只需

122
00:13:43,000 --> 00:13:49,020
打开一个终端，或者如果你使用的是Windows系统，只需打开PowerShell，然后你就可以简单地

123
00:13:49,020 --> 00:13:56,660
键入 elixir 和连字符 v。所以正如你所看到的，我目前正在运行 elixir
1.14.1，如果你正在观看这个视频，你可能有其他版本，但不用担心，所有的版本也一样。

124
00:13:56,660 --> 00:14:05,020
如果你将来看这个视频，你可能有其他版本，但不用担心，所有的版本都一样。

125
00:14:05,020 --> 00:14:11,280
版本也都一样。对于这个视频的下一个步骤是让我们打开我们的 Visual Studio
Code，并且让我们。

126
00:14:11,700 --> 00:14:18,800
为这个设置 elixir 插件。所以只需打开你的扩展，我希望你只需。

127
00:14:18,800 --> 00:14:27,680
搜索 elixir。所以这个扩展是为了 elixir ls，所以你可以在这里看到，目前它有。

128
00:14:27,680 --> 00:14:34,400
有着 33.9 万次下载，所以只需安装这个插件，这是你真正需要开始工作的。

129
00:14:34,400 --> 00:14:41,460
在 VS Code 中使用 elixir。当你第一次在 VS Code 中打开任何 elixir
文件时，你将会。

130
00:14:41,460 --> 00:14:47,820
在右下角的某个位置会弹出一个小窗口，该窗口会显示。

131
00:14:47,820 --> 00:14:55,140
elixir 正在构建 plt，所以就让它发生吧，这需要一些时间，但让它。

132
00:14:55,140 --> 00:15:02,420
运行，当 elixir plt 构建完成后，你就可以在 VS Code 中开始使用你的 elixir
文件了。

133
00:15:03,340 --> 00:15:08,440
既然我们已经安装了elixir，现在是时候开始学习更多关于elixir的知识了

134
00:15:08,440 --> 00:15:15,460
但是在学习之前，我们需要先开始“反学习”，因为很多概念在面向对象的世界中是不存在的

135
00:15:15,460 --> 00:15:21,920
面向对象的世界在函数式编程的世界中是不存在的，这就引出了我想谈的一个非常重要的观点

136
00:15:21,920 --> 00:15:30,440
首先，如果我说a等于1，然后问你对此有什么看法，你可能会回答

137
00:15:30,440 --> 00:15:37,380
你可能会说a是一个变量，而1是被赋值给变量a的值

138
00:15:37,380 --> 00:15:44,180
你是对的，但这并不是在函数式编程的世界中发生的事情。如果我带你回到

139
00:15:44,180 --> 00:15:49,640
回到你上高中的日子，想象一下你正在上最基础的代数课

140
00:15:50,360 --> 00:15:57,520
在那节课上，我们学到的是a等于1，这意味着a是你的左手边，1是你的右手边

141
00:15:57,520 --> 00:16:05,260
它是你的右手边。所以数学试图表达的是你的左手边等于

142
00:16:05,260 --> 00:16:13,220
你的右手边。你的基础代数并没有说1被赋值给了a这个概念

143
00:16:13,220 --> 00:16:21,220
不存在。现在如果我们说左边等于右边，那就意味着

144
00:16:21,220 --> 00:16:28,140
右边也应该等于左边。所以如果我说a等于一

145
00:16:28,520 --> 00:16:35,400
这意味着甚至这个语句也应该成立，这就是elixir世界中发生的事情

146
00:16:35,400 --> 00:16:43,080
同样如此。我们很快也会演示这个。现在只要记住等于不是

147
00:16:43,080 --> 00:16:50,140
赋值运算符，这是匹配运算符，这个运算符的作用是简单地

148
00:16:50,140 --> 00:16:56,860
将你的右边匹配到你的左边，你会经常看到这种模式

149
00:16:56,860 --> 00:17:03,860
在elixir中。这也被称为模式匹配，这是一个非常强大的东西

150
00:17:03,860 --> 00:17:10,200
elixir。每当你看到这样的语句时，请记住我们只是在试图匹配

151
00:17:10,200 --> 00:17:16,720
右边和左边。现在让我们打开终端进行演示。

152
00:17:17,600 --> 00:17:24,220
Elixir实际上附带了一个交互式shell或一个repel，让我们看看如何打开它

153
00:17:24,220 --> 00:17:33,160
并开始使用elixir。我们可以通过键入IEX进入交互式shell。您可以清除

154
00:17:33,160 --> 00:17:42,200
通过键入clear清除终端。所以在这里我们可以说我的a等于一。现在如果我们说是

155
00:17:42,200 --> 00:17:50,900
一个等于我的a，我们得到的输出是true。您也可以输入one等于a

156
00:17:50,900 --> 00:17:57,320
这只是简单地返回值，因为one和a都保存着相同的值one。

157
00:17:58,440 --> 00:18:05,400
让我来澄清一下。让我们再试一次实验。假设我说我的名字是

158
00:18:07,120 --> 00:18:16,900
Octalium。所以在这种情况下，如果我说Octalium等于我的名字，那么我们应该得到

159
00:18:16,900 --> 00:18:23,460
答案是true，是的，就是这样。所以请记住，这个等于不是

160
00:18:23,460 --> 00:18:35,380
分配。我们只是试图将右侧的模式与左侧的模式匹配。让我们

161
00:18:35,380 --> 00:18:42,660
例子。现在方括号表示这是一个列表，我将更多地介绍列表

162
00:18:42,660 --> 00:18:49,480
以后再说吧，现在让我们顺其自然。现在我不想让你

163
00:18:49,480 --> 00:18:56,780
专注于语法。我希望你只专注于右边和

164
00:18:56,780 --> 00:19:03,860
左边。你能看到右边的模式和左边的模式是一样的吗？

165
00:19:03,860 --> 00:19:10,160
左边有两个变量。右边有两个值。这里

166
00:19:10,160 --> 00:19:18,840
你可以说一个的值现在绑定到了变量a上。现在下一个变量也是

167
00:19:18,840 --> 00:19:26,260
a，而且a中的值也是1，就是这样。所以这将在内部成立

168
00:19:26,960 --> 00:19:34,680
elixir。为了进行快速演示，让我打开终端，我已经在IEX中了。以防万一

169
00:19:34,680 --> 00:19:40,860
你忘记了如何进入IEX，让我再给你演示一次。退出IEX只需要按一下

170
00:19:40,860 --> 00:19:49,920
两次ctrl c，你就可以退出IEX，如果你想进入，请再输入IEX。再一次

171
00:19:49,920 --> 00:20:00,300
让我澄清一下。所以这里我可以说我的列表有两个变量a和a，值分别是

172
00:20:00,300 --> 00:20:08,280
1和1。所以就是这样。完全匹配。右边等于左边

173
00:20:08,280 --> 00:20:16,080
所以我们把值拿回来。如果我只是说我想看到a的值，这里它是我们得到的值

174
00:20:16,080 --> 00:20:24,980
a的值是一个。现在让我们回过头来。现在你能猜到这次会发生什么吗？

175
00:20:25,780 --> 00:20:32,160
现在这次你可以看到我们有a和a的值，右边是一个的值

176
00:20:32,160 --> 00:20:39,340
一个和两个。好吧，让我们去我们的IEX看看这次会发生什么。所以我们有

177
00:20:39,340 --> 00:20:46,220
这是a和a，右边是一个和两个。让我们看看会发生什么。

178
00:20:46,800 --> 00:20:53,140
哦，我们得到了一个错误，如果你仔细观察，我们会得到一个错误，说没有匹配

179
00:20:53,140 --> 00:21:02,220
右边是不匹配的。原因是一个的值绑定到了

180
00:21:02,220 --> 00:21:10,980
一个的值，再次，第二个值是a，但这次a里面的值是一个，右边是

181
00:21:10,980 --> 00:21:17,520
的值是两个。所以两个不等于一个，这就是为什么右边和左边

182
00:21:17,520 --> 00:21:26,480
不匹配，这就是为什么我们会得到一个错误。让我们回去。现在如果我们发生了什么？

183
00:21:26,480 --> 00:21:32,360
像这样吗？如果我们将第二个值从a换成一个新变量b，

184
00:21:33,240 --> 00:21:38,740
你能猜到会发生什么吗？好，我们回到之前，让我们看看会发生什么

185
00:21:38,740 --> 00:21:47,860
这一次。所以让我将值从a改为b，让我们看看。嗯，是的，完美匹配。

186
00:21:48,640 --> 00:21:55,940
那么这次发生了什么？1的值绑定到了变量a，2的值

187
00:21:55,940 --> 00:22:03,660
绑定到了变量b。我们可以检查一下。所以如果我说a，我们得到1的值

188
00:22:03,660 --> 00:22:12,840
而如果我说b，我们得到2的值，就是这样。要始终尝试并思考

189
00:22:12,840 --> 00:22:19,920
从模式匹配的角度来看，这意味着我们始终希望右侧等于左侧

190
00:22:19,920 --> 00:22:28,260
这也被称为模式匹配，正如我之前所说，这是一个非常强大的

191
00:22:28,260 --> 00:22:34,220
在Elixir中的模式，并且我们将在整个教程中使用这种模式匹配

192
00:22:34,220 --> 00:22:41,740
系列。到目前为止，我们已经了解了一点关于Elixir中的模式匹配，并且我们一直在使用它。

193
00:22:41,740 --> 00:22:48,960
使用我们的终端，但我们可以做得更好，让我向您介绍Livebook。

194
00:22:48,960 --> 00:22:56,200
因此，Livebook实际上就像Elixir的Jupyter笔记本，但在我向您展示Livebook之前，

195
00:22:56,200 --> 00:23:01,140
您可能已经注意到，我有一个不同的提示符，我的终端里还有更多的颜色

196
00:23:01,140 --> 00:23:08,180
这是因为我使用了更加复杂的设置，但就这样而已。

197
00:23:08,460 --> 00:23:16,260
现在让我来看看Livebook。就是这里，您可以直接访问这个网站livebook.dev

198
00:23:16,260 --> 00:23:23,180
然后我们可以简单地在我们的机器上安装Livebook，只需点击安装

199
00:23:23,180 --> 00:23:29,220
在这里您可以选择您的Mac或Windows系统并下载安装程序，在下载完成之后

200
00:23:29,220 --> 00:23:35,640
只需像在您的机器上安装其他程序一样安装它。现在我已经安装了Livebook，所以让我打开它

201
00:23:35,640 --> 00:23:43,940
已经安装了Livebook，让我打开它。就是这样，我们可以开始

202
00:23:43,940 --> 00:23:49,640
新建一个笔记本，只需点击这里的新笔记本，就这样，我们可以开始了。

203
00:23:50,220 --> 00:23:57,960
让我们试试在终端中写入的相同代码，所以这里我可以说的是我的a逗号a

204
00:23:57,960 --> 00:24:07,220
等于我的1逗号1，你可以点击这里进行评估，现在我们有输出了，对吧

205
00:24:08,020 --> 00:24:17,620
让我们尝试一些其他的例子，所以这里我可以说如果我的a等于1，那么我的

206
00:24:17,620 --> 00:24:24,620
等于1，让我们尝试在这个单元格中进行评估，是的，我们得到了输出。

207
00:24:26,620 --> 00:24:32,540
现在，为了参考，我还包括了一些笔记本，你可以

208
00:24:32,540 --> 00:24:38,780
在这里找到所有这些，所以这是整个教程系列的github存储库

209
00:24:38,780 --> 00:24:47,940
这是octalium斜杠oop，就在这里，你可以去octalium和斜杠functional

210
00:24:47,940 --> 00:24:53,580
使用elixir编程，在笔记本中你可以看到我有几个笔记本

211
00:24:53,580 --> 00:24:59,500
现在，在将来我可能会再添加几个笔记本，但在录制时

212
00:24:59,500 --> 00:25:05,000
我们有三个，所以让我们看看如何在我们的livebook中打开这些笔记本

213
00:25:05,000 --> 00:25:11,200
所以让我回到我的livebook，让我只需点击左边的这个图标

214
00:25:11,820 --> 00:25:16,300
这里我只需要选择我的路径，所以我要进入我的 github

215
00:25:17,700 --> 00:25:23,940
使用 elixir notebooks 进行 octalium 函数式编程，让我选择第一个

216
00:25:23,940 --> 00:25:29,900
然后让我简单地点击打开，所以这是你可以在里面找到的第一个 livebook

217
00:25:29,900 --> 00:25:34,280
这个仓库，正如你所看到的，我已经包含了一些

218
00:25:34,280 --> 00:25:39,800
文本，还有一些代码块供你参考，这就是我们试图做的事情

219
00:25:39,800 --> 00:25:47,140
上次，如果你看到这里，我创建了一些更多的例子，所以如果我的名字是

220
00:25:47,140 --> 00:25:54,200
等于 octalium，那么我的 octalium 也应该等于 name，以此类推，所以你可以做的是

221
00:25:54,200 --> 00:26:00,180
也许你可以尝试创建更多的笔记本，然后尝试打开这些笔记本

222
00:26:00,180 --> 00:26:05,840
这些笔记本包含在仓库中，我会在下一个视频中告诉你，到目前为止我们一直在

223
00:26:05,840 --> 00:26:10,440
试图更多地了解模式匹配，让我们在这个视频中继续做同样的事情

224
00:26:10,440 --> 00:26:17,760
现在让我们回到终端，让我进入 IEX，我可以通过简单的方式来做到这一点

225
00:26:17,760 --> 00:26:24,940
现在再次输入IEX，请让我提醒您，我的提示符看起来不同，这是因为我自定义了设置

226
00:26:24,940 --> 00:26:30,500
因为我自定义了设置，我只想让提示符与我的标志相同

227
00:26:30,500 --> 00:26:37,320
这就是我简单地更改了它，但就是这样，现在让我清理终端，然后让

228
00:26:37,320 --> 00:26:43,240
让我们尝试更多地了解模式匹配，所以让我们再创建相同的列表

229
00:26:43,240 --> 00:26:50,120
对于右侧，让我们说我们想与一个和二进行匹配，正如您所知，我们将得到一个匹配错误

230
00:26:50,120 --> 00:26:56,120
您知道我们将得到一个匹配错误，这就是我们得到的，所以让我再试一次

231
00:26:56,120 --> 00:27:03,060
并刷新我们的记忆，发生了什么，所以正在发生的是变量a的值是

232
00:27:03,060 --> 00:27:09,940
绑定到值为一的值，并且在下一次发生的事情是这里我们有一个a

233
00:27:09,940 --> 00:27:16,860
但我们正在尝试将值为二的值与a进行匹配，正如您所知，a绑定到一，这就是为什么

234
00:27:16,860 --> 00:27:21,900
我们得到了匹配错误，现在让我们花几分钟来试着理解

235
00:27:21,900 --> 00:27:28,760
为什么会发生这种情况？因为Elixir中的所有数据类型都是不可变的。

236
00:27:29,320 --> 00:27:35,660
这意味着我们不能在Elixir中随机分配新值给现有变量。

237
00:27:35,660 --> 00:27:41,000
现在你一定在想为什么Elixir中的所有类型都必须是不可变的。

238
00:27:41,520 --> 00:27:47,500
简而言之，这是为了可扩展性，我们将在下一个视频中详细讨论这一点。

239
00:27:47,500 --> 00:27:53,160
现在让我们试着了解一下背后发生了什么，现在让我来解释一下。

240
00:27:53,160 --> 00:27:59,580
再来一次屏幕，这次让我们假设我们要的是a，并且我们希望它在右边。

241
00:27:59,580 --> 00:28:05,980
所以这次发生的是我们在这里有一个匹配运算符，其值为。

242
00:28:05,980 --> 00:28:13,880
将1绑定到变量a上，但是这里有一个小问题，如果我说a等于2

243
00:28:13,880 --> 00:28:20,860
所以这次我们没有错误，但是我刚才说过在Elixir中我们的数据类型是不可变的。

244
00:28:20,860 --> 00:28:27,500
所以发生了什么，当我们在匹配运算符的左边有一个变量时，

245
00:28:27,500 --> 00:28:34,240
那时候，Elixir认为我们想将新值绑定到左边的变量上，这就是为什么

246
00:28:34,240 --> 00:28:40,100
为什么我们有了新值而不是a，它是两个，但是如果你不想要这种行为，那么我们可以

247
00:28:40,100 --> 00:28:46,860
可以使用一个pin操作符，我们可以说pin操作符，a等于三，这次

248
00:28:46,860 --> 00:28:53,020
正如你所看到的，我们得到了一个匹配错误，匹配错误表示右侧没有匹配

249
00:28:53,020 --> 00:28:59,320
值为三，这是因为我们有两的值，而左边

250
00:28:59,320 --> 00:29:05,060
我们试图匹配一个值为三的值，这就是为什么我们得到了匹配错误，现在如果我们试图做

251
00:29:05,060 --> 00:29:11,300
这件事情的另一种方式，如果我们说三等于a，那么这次我们又得到了一个

252
00:29:11,300 --> 00:29:18,640
没有匹配，右侧的值是两，所以是的，正如你在这里看到的一样，这个值

253
00:29:18,640 --> 00:29:24,960
与a绑定的值是两，这就是为什么三不等于两，我们得到了一个匹配错误

254
00:29:24,960 --> 00:29:32,240
在第四行，我们可以把新的值两重新绑定到我们的变量a上，只是因为

255
00:29:32,240 --> 00:29:37,180
这个变量暂时在匹配运算符的左边，你现在不必担心

256
00:29:37,180 --> 00:29:41,920
随着我们的进展和解决更多的例子，你就不必太担心这些事情了

257
00:29:41,920 --> 00:29:47,800
所有这些事情现在都会很容易明白，现在来到下一个问题，为什么我们需要

258
00:29:47,800 --> 00:29:54,720
在Elixir中的可逆性，我的简短答案是可扩展性，让我试着解释一下为什么

259
00:29:54,720 --> 00:30:02,580
可逆性有助于可扩展性，因为我们的数据不可逆，这意味着数据可以轻松地

260
00:30:02,580 --> 00:30:08,720
在各个进程之间传递，并且如果另一个资源、另一个线程或者

261
00:30:08,720 --> 00:30:14,260
另一个进程正在改变或尝试改变我们的数据，当我们理解代码在Elixir中的执行方式以及演员模型时，这个问题就会变得清楚起来

262
00:30:14,260 --> 00:30:20,960
理解代码在Elixir中的执行方式以及演员模型，这就是我们接下来要做的

263
00:30:20,960 --> 00:30:26,640
我们将在下一个视频中尝试理解Elixir内部的所有代码

264
00:30:26,640 --> 00:30:34,480
现在所有的代码都在一个被称为演员的东西中执行，因此你可以

265
00:30:34,480 --> 00:30:42,360
想象你的角色就像这个盒子，现在这是一个孤立的盒子，发生的事情是

266
00:30:42,360 --> 00:30:49,560
这个盒子或者这个角色接收到某种消息，这些消息可能是数据，它们

267
00:30:49,560 --> 00:30:56,000
可能是如何处理这些数据的指令等等。在接收到这些消息之后，你的角色

268
00:30:56,000 --> 00:31:03,060
会处理你的消息，并简单地返回某种响应，所以

269
00:31:03,060 --> 00:31:10,200
简单来说，你可以想象角色就像一个孤立的竞争单位，它得到一些东西，它

270
00:31:10,200 --> 00:31:16,000
处理一些东西，然后返回一些东西。现在发生的是这些角色在内部运行

271
00:31:16,000 --> 00:31:22,340
一些被称为进程的东西，而且我们在某个给定的时间可以有数百万个

272
00:31:22,340 --> 00:31:29,980
进程，这就是数据不可变性出现的地方，我们可以有数百万个副本

273
00:31:29,980 --> 00:31:36,640
我们的数据，它们可以分布在各个部门，不仅仅是在我们的本地机器上，我们可以

274
00:31:36,640 --> 00:31:43,220
拥有一个全球范围的不同服务器集群，我们可以将负载水平分布在各个部分

275
00:31:43,220 --> 00:31:49,640
全球，所以这些进程不是你的操作系统进程，你可以把它们想象成

276
00:31:49,640 --> 00:31:55,500
虚拟线程，所以让我们一步一步地理解这些进程

277
00:31:55,500 --> 00:32:02,540
看到了演员模型和这些演员，它们在你的进程内运行，对于每个进程，我们都有

278
00:32:02,540 --> 00:32:07,460
一个单独的ID，称为PID，我将在此视频中很快向您展示PID

279
00:32:08,060 --> 00:32:15,400
下一部分是我们可以通过消息传递在这些进程之间进行通信，就像我们刚刚说的那样

280
00:32:15,400 --> 00:32:21,640
由于我们的数据是不可变的，我们可以创建多个副本，并且这些副本可以发送

281
00:32:21,640 --> 00:32:28,400
发送到不同的进程中，由于每个演员都有自己的数据副本，我们不必担心

282
00:32:28,400 --> 00:32:35,380
另一个演员正在改变状态，一切都在隔离中运行，下一部分是每个进程

283
00:32:35,380 --> 00:32:41,600
有自己的堆栈和堆分配，所以如果我们来自编译型编程语言，比如

284
00:32:41,600 --> 00:32:48,980
C++，我们有不同的内存分配模型，您可以在堆栈内分配内存或者

285
00:32:48,980 --> 00:32:56,960
在堆上，对于Elixir来说，每个进程都有自己的栈和堆分配，因此这样垃圾收集非常快

286
00:32:56,960 --> 00:33:02,480
垃圾收集非常快，我们只需要为单个进程进行垃圾收集

287
00:33:02,480 --> 00:33:09,200
同时我们的应用程序仍然保持响应，接下来让我们再多了解一些

288
00:33:09,200 --> 00:33:16,700
关于我们的actor的一些细节，每个actor都有自己的邮箱，所以您传递给一个actor的每个消息都会

289
00:33:16,700 --> 00:33:22,800
独立的进程，这些消息被收集在这个邮箱里，然后它们被执行

290
00:33:22,800 --> 00:33:31,200
按照顺序执行，并且执行顺序是先进先出，接下来这些进程

291
00:33:31,200 --> 00:33:37,780
非常便宜地创建，它们只需要不到3KB的内存，所以您可以看到它非常便宜

292
00:33:37,780 --> 00:33:44,540
我们可以同时创建数百万个进程，最后要记住的是我们总是

293
00:33:44,540 --> 00:33:51,100
通过消息传递进行通信，现在让我们回到我们的终端，让我们检查一下我们的

294
00:33:51,100 --> 00:33:57,980
那边的PID，PID代表您的进程ID，所以首先让我们进入我们的IEX

295
00:33:57,980 --> 00:34:05,540
让我现在解释清楚，这个IEX也是在一个独立的进程中运行的，我们可以检查

296
00:34:05,540 --> 00:34:12,400
使用内置函数self可以获取进程ID，现在关于elixir的下一件事是

297
00:34:12,400 --> 00:34:18,760
括号不是必需的，self是一个函数，你可以写括号，也可以不写

298
00:34:18,760 --> 00:34:24,860
但是现在的一般约定是，当你在代码中编写代码时

299
00:34:24,860 --> 00:34:31,220
编辑器中我们更喜欢括号，但在终端上你可以自行决定，我会不写括号

300
00:34:31,220 --> 00:34:37,680
不写括号，这样我们就可以得到输出，所以我们的IEX正在运行的当前进程ID

301
00:34:37,680 --> 00:34:46,640
就在这里，这是地址0.107.0，所以就这些，下次见

302
00:34:46,640 --> 00:34:53,740
在下一个视频中，我想现在我们已经了解了足够的elixir，现在是时候编写非常重要的

303
00:34:53,740 --> 00:35:01,200
hello world程序，让我们开始吧，让我打开我的终端，然后让我创建

304
00:35:01,200 --> 00:35:07,780
一个名为functional programming with
elixir的文件夹，现在让我进入这个文件夹

305
00:35:08,480 --> 00:35:15,740
然后让我再创建一个脚本目录，让我进入我的脚本目录

306
00:35:15,740 --> 00:35:25,040
然后让我再创建一个名为hello.exs的文件，现在Elixir有两个文件扩展名

307
00:35:25,040 --> 00:35:31,480
这个. s你可以在这里看到，这意味着我们要创建一个脚本文件

308
00:35:31,480 --> 00:35:38,680
每当我们想要创建一个编译文件的时候，我们只需要写成. ex，我们会看到

309
00:35:38,680 --> 00:35:46,160
当我们使用mix工具创建我们的第一个项目时，我们会更多地了解. ex扩展名，但现在

310
00:35:46,160 --> 00:35:53,560
请记住，每当我们想要创建一个脚本时，我们只需要添加一个s，现在有了

311
00:35:53,560 --> 00:36:00,400
有很多时候你需要额外的文件，例如你需要一个文件来填充你的数据库

312
00:36:01,080 --> 00:36:07,140
或者如果你只想要一个用于测试的文件，这些文件不是用于生产的

313
00:36:07,140 --> 00:36:12,980
只是为了你的开发，现在让我继续创建这个文件，让我们打开它

314
00:36:12,980 --> 00:36:19,920
在我们的代码编辑器中打开此文件，现在我的代码编辑器抱怨没有找到mix文件，所以

315
00:36:19,920 --> 00:36:24,760
现在先忽略这个，当我们使用mix创建一个项目时，它会消失

316
00:36:24,760 --> 00:36:30,220
让我收起边栏，那么你要记住的第一件事是

317
00:36:30,220 --> 00:36:37,560
在Elixir中，代码保留在模块内部，所以让我们创建一个模块

318
00:36:37,560 --> 00:36:44,820
我们只需要声明我们要定义一个模块，然后给它命名为hello

319
00:36:44,820 --> 00:36:52,540
接下来，在Elixir中我们没有花括号，而是有do和end代码块

320
00:36:52,540 --> 00:36:59,360
到目前为止，我们只是简单地定义了一个模块，所有的代码都将放在这个模块内部

321
00:36:59,360 --> 00:37:06,880
按照一般惯例，模块名和文件名应该相同，但这不是必须的

322
00:37:06,880 --> 00:37:12,800
但是根据社区惯例，它们应该是相等的，比如让我打开我的边栏

323
00:37:12,800 --> 00:37:18,520
在这里你可以看到我们把文件命名为hello，同时也把模块命名为hello

324
00:37:18,520 --> 00:37:25,800
让我收起我的边栏，在这个模块内部我们来创建我们的第一个函数

325
00:37:25,800 --> 00:37:32,260
你可以使用关键字def来创建函数，让我们将函数称为

326
00:37:32,260 --> 00:37:42,780
world，这个函数不接受任何参数，所以你可以保留空括号或者

327
00:37:42,780 --> 00:37:50,080
不接受任何参数，然后我们需要创建do和end块，在这里我们可以

328
00:37:50,080 --> 00:37:57,640
说一下，从我们的输入输出，我们只是想把一些东西放到输出上，这里我们只是

329
00:37:57,640 --> 00:38:04,220
想要显示“Hello Elixir”的消息，现在总是使用双引号来定义你的

330
00:38:04,220 --> 00:38:09,780
字符串，单引号是用来表示字符的，但是现在我们想要一个字符串，所以

331
00:38:09,780 --> 00:38:16,700
我们使用了双引号，现在让我们保存这个程序并且看看我们如何运行这个程序

332
00:38:16,700 --> 00:38:24,100
让我调整一下屏幕，我们可以用几种不同的方式来运行这个文件，让我们先看一下

333
00:38:24,100 --> 00:38:29,680
方法，在这里我们可以简单地说“嘿，Elixir，我只想让你运行一个叫做

334
00:38:29,680 --> 00:38:39,660
的文件”，你会看到Elixir实际上运行了我们的文件，但是我们没有任何输出，我们

335
00:38:39,660 --> 00:38:45,740
没有输出是因为我们还没有调用world函数，所以让我们现在调用一下吧。

336
00:38:45,740 --> 00:38:52,440
让我把终端稍微放下一点，我们可以在这里说

337
00:38:52,440 --> 00:38:59,540
我们的hello模块想要调用world函数，我们先保存文件，然后去

338
00:38:59,540 --> 00:39:06,540
我们的终端，再试一次相同的命令，这次我们会得到输出

339
00:39:06,540 --> 00:39:14,240
hello elixir，所以你可以在想要运行脚本文件的时候使用这个方法，但是elixir实际上是

340
00:39:14,240 --> 00:39:20,580
一种编译语言，所以让我们看看如何实际编译这个文件，再次请保持

341
00:39:20,580 --> 00:39:26,420
记住，每当我们想要有一个编译文件的时候，文件扩展名应该是

342
00:39:26,420 --> 00:39:33,940
是.ex，但是现在让我来展示一下我们如何编译和运行这个脚本，让我清理一下

343
00:39:33,940 --> 00:39:40,500
我的终端，这里我们可以不写elixir，可以写elixir编译器，加上一个c

344
00:39:40,500 --> 00:39:46,180
就在这里，这代表的是elixir编译器，所以现在elixir将会编译这个文件

345
00:39:46,180 --> 00:39:52,600
文件，然后它会为我们运行，让我打开侧边栏，你可以看到我们有一个

346
00:39:52,600 --> 00:39:59,040
单个文件 hello.exe，这个文件是由我们的虚拟工作室代码创建的，现在让我们编译

347
00:39:59,040 --> 00:40:05,340
文件，让我们看看会发生什么，正如你在侧边栏中看到的，elixir 实际上已经编译了

348
00:40:05,340 --> 00:40:12,680
我们有一个新文件叫做 elixir.hello.beam，现在记住 elixir 运行在 beam
虚拟机上

349
00:40:12,680 --> 00:40:18,700
这是我们的 elixir 代码的编译文件，但通常我们不编译和

350
00:40:18,700 --> 00:40:24,680
像这样运行 elixir 文件，我们将使用 mix 工具，我们将在教程中更多地了解 mix 工具

351
00:40:24,680 --> 00:40:30,420
随着我们在教程中的进展，但现在让我们按部就班，现在让我折叠我的

352
00:40:30,420 --> 00:40:36,280
侧边栏，我们还可以在 interact2 shell 中运行此文件，让我向你展示如何

353
00:40:36,280 --> 00:40:44,420
做到这一点，让我们进入我们的 interact2 shell，让我清理一切，现在我们可以说

354
00:40:44,420 --> 00:40:53,560
我们想要编译 hello.exe 文件，就这样，现在我们收到一个警告，说

355
00:40:54,200 --> 00:40:59,800
模块 hello，那是因为刚刚几秒钟前我们实际上编译了这个文件。

356
00:40:59,800 --> 00:41:06,000
而且该文件目前在我们的内存中，但是现在我们可以简单地忽略所有这些东西。

357
00:41:06,000 --> 00:41:12,980
接下来，你的 iex 实际上运行了该文件，这里我们可以看到我们现在有了 hello elixir
的输出。

358
00:41:12,980 --> 00:41:18,700
让我再清理一次屏幕，让我们看看如何手动调用函数。

359
00:41:18,700 --> 00:41:25,340
所以在这里我们可以说我希望你进入 hello 模块，然后从那里我希望你去。

360
00:41:25,340 --> 00:41:31,800
到 world 函数，现在请记住，在 elixir 中括号是可选的，而且。

361
00:41:31,800 --> 00:41:38,340
由于我们的 world 函数不接受任何参数，我可以使用空括号或者。

362
00:41:38,340 --> 00:41:45,340
可以简单地省略它们，这里你可以看到我们有一个 hello elixir 的输出，之后。

363
00:41:45,340 --> 00:41:51,920
之后我们还有一个消息，说好现在好表示一种被称为的数据类型。

364
00:41:51,920 --> 00:41:58,720
原子，我们将在下一个视频中学到更多关于数据类型的内容，但现在让我们继续。

365
00:41:58,720 --> 00:42:06,140
现在重新流动，让我关闭终端，这次我们让这个函数接受某种参数

366
00:42:06,140 --> 00:42:12,240
一个参数，所以我们可以说我们希望world函数接受一个参数，然后我们

367
00:42:12,240 --> 00:42:18,880
将参数命名为name，然后我们可以使用字符串插值，所以让我拿出来

368
00:42:18,880 --> 00:42:25,320
elixir，这里我们需要放置井号，然后放置花括号，在括号内部

369
00:42:25,320 --> 00:42:31,560
花括号中，我可以简单地使用我们的参数name，还有，让我删除这一行，这行不需要

370
00:42:31,560 --> 00:42:38,840
不需要了，所以让我们打开终端，现在iex正在运行，因为我们做了改动

371
00:42:38,840 --> 00:42:46,040
让我们重新编译模块，我们可以通过输入r来进行，r是重新编译的意思，我们

372
00:42:46,040 --> 00:42:52,020
只需要重新编译我们的hello模块，就这样，我们重新定义了这个模块

373
00:42:52,020 --> 00:42:59,820
让我清理一下，这里我们可以说hello.world，现在让我们传递一个叫做

374
00:42:59,820 --> 00:43:06,380
octalium的参数，我们得到了hello octalium的输出，现在记住括号的使用

375
00:43:06,380 --> 00:43:12,340
是可选项，所以我们也可以像这样写，让我去掉括号，让我

376
00:43:12,340 --> 00:43:19,040
在这里之间加上一个空格，这样我们可以看到这段代码也是有效的，我们得到了完全相同的

377
00:43:19,040 --> 00:43:24,520
相同的输出，就是这样，这个视频就到这里了，接下来我们将看到Elixir中的不同数据类型

378
00:43:24,520 --> 00:43:30,560
从下一个开始，让我们尝试更多地了解Elixir中的不同数据类型

379
00:43:31,200 --> 00:43:37,400
我想提醒你的第一件事是，Elixir中的所有数据类型都是不可变的

380
00:43:37,400 --> 00:43:44,280
通俗地说，我想说的是Elixir中的所有数据类型都是常量

381
00:43:44,880 --> 00:43:51,240
现在，考虑到这个概念，让我们继续前进，让我们试着学习第一个数据类型和

382
00:43:51,240 --> 00:43:58,880
数据类型被称为原子，Elixir中的原子看起来像这样，我们有一个冒号符号

383
00:43:58,880 --> 00:44:05,740
在冒号后面，我们有原子的名称，如果名称中有一些空格

384
00:44:05,740 --> 00:44:12,220
原子，那么我们可以像这样写一个原子，所以语法是这样的，你的原子将

385
00:44:12,220 --> 00:44:17,760
始终以冒号开头，然后是原子的名称，在这种情况下，由于我们有

386
00:44:17,760 --> 00:44:24,780
原子名称中有一个空格，我们使用双引号，在双引号内部我们有

387
00:44:24,780 --> 00:44:32,560
原子的名称，现在这只是原子的语法，但是现在让我们继续并尝试一下

388
00:44:32,560 --> 00:44:39,800
理解原子的全部内容，所以让我们考虑这种情况，所以我们有一个符号或者一个

389
00:44:39,800 --> 00:44:46,440
像这样的标志，你能告诉我这个标志象征着什么吗，这个标志是一个非常受欢迎的

390
00:44:46,440 --> 00:44:53,760
品牌，这个品牌是耐克，所以在这种情况下发生了什么，这个符号与

391
00:44:53,760 --> 00:45:00,880
耐克的名字，如果我向你展示这个符号或者我向你展示这个名字，这两个值都指向

392
00:45:00,880 --> 00:45:07,600
完全相同的东西，所以这只是一个伪代码，这不是一个有效的elixir语法，但让我们

393
00:45:07,600 --> 00:45:13,500
了解原子的概念，所以这里发生的是我们有一个变量

394
00:45:13,500 --> 00:45:21,220
变量的名称是nike，分配给这个变量的值也是nike，所以简而言之

395
00:45:21,220 --> 00:45:29,080
值和名称是相同的，这就是原子所代表的。在一个原子中，名称

396
00:45:29,080 --> 00:45:36,340
而且值总是相同的，我们可以用原子来表示，就像这样，所以我们有一个

397
00:45:36,340 --> 00:45:43,400
为了nike，让我们打开我们的ix，我们可以从那里开始玩，所以这是我的

398
00:45:43,400 --> 00:45:51,160
终端让我进入我的ix，让我清除屏幕，所以让我们为此创建相同的原子

399
00:45:51,160 --> 00:45:58,860
nike，所以我们可以说nike，这就是原子的全部内容。假设我们有一个非常长的名称，其中包含

400
00:45:58,860 --> 00:46:07,580
中间有空格，所以我们可以说像这样the和nike，所以这也是一个有效的原子

401
00:46:08,120 --> 00:46:14,040
而且你会注意到我们的原子总是以冒号开头，现在我们可以做的是让我们去

402
00:46:14,040 --> 00:46:22,140
我们的活动手册，我们可以在那里创建更多的原子示例，所以这是我们的活动手册

403
00:46:22,140 --> 00:46:31,600
让我们创建一个新的笔记本，让我给它一个标题叫做数据类型，这一节是关于

404
00:46:31,600 --> 00:46:39,460
在Elixir中，我们的原子无处不在，原子在模式匹配中被广泛使用

405
00:46:39,460 --> 00:46:44,640
现在假设你正在开发某种应用程序，而且你想返回一个错误消息

406
00:46:44,640 --> 00:46:50,820
那么我们可以简单地创建一个名为error的atom

407
00:46:50,820 --> 00:46:57,400
像这样说error，然后让我们点击评估，这样我们就创建了一个

408
00:46:57,400 --> 00:47:03,080
叫作error的atom，接下来让我给你展示这种atom的一个非常实用的用法

409
00:47:03,080 --> 00:47:09,260
所以让我们拿同样的例子来说，假设我们正在开发一个应用程序，然后出现了一个错误

410
00:47:09,260 --> 00:47:15,720
在那种情况下，我们找不到一个文件，所以很常见的做法是返回一个元组

411
00:47:15,720 --> 00:47:21,280
而且这个元组由这些花括号表示，稍后我会详细介绍元组

412
00:47:21,280 --> 00:47:26,680
但现在让我们顺其自然，元组里面我们可以说

413
00:47:26,680 --> 00:47:33,000
第一个元素是一个错误，所以在那个操作中出现了一些错误，然后我们可以描述这个错误

414
00:47:33,560 --> 00:47:41,220
所以我们可以说，例如，文件未找到，这种模式在elixir中非常常见

415
00:47:41,220 --> 00:47:47,140
通常我们会有一个包含两个元素的元组或者三个元素的元组，你经常会看到

416
00:47:47,140 --> 00:47:53,440
我们只是在这个元组上进行模式匹配，所以我们可以在左边再次进行模式匹配

417
00:47:53,440 --> 00:47:58,880
与这个元组进行模式匹配，让我在这里创建一个新的元组，第一个元素是

418
00:47:58,880 --> 00:48:05,180
是一个错误，第二个元素我们可以称为原因，现在再次发生的是

419
00:48:05,180 --> 00:48:11,180
我们只是在使用模式匹配，我希望你回到你的左手概念

420
00:48:11,180 --> 00:48:18,060
左边等于右边，所以在右边我们有一个元组，在左边

421
00:48:18,060 --> 00:48:24,160
手边我们有一个元组，接下来发生的是，在右边我们有一个叫做文件的字符串

422
00:48:24,160 --> 00:48:30,860
不存在，而在左边，我们有一个变量哦，让我拼写正确，这必须是

423
00:48:30,860 --> 00:48:37,100
原因，所以发生的是，因为我们在左边有一个变量，这个值

424
00:48:37,100 --> 00:48:43,620
文件未找到将绑定到我们的原因变量，让我们点击重新评估和

425
00:48:43,620 --> 00:48:49,740
让我们看看发生了什么，我们得到了我们的元组回来的错误文件找不到，让我们把这个分成

426
00:48:49,740 --> 00:48:55,140
不同的代码块，所以让我在这里创建一个代码块，让我带走这段代码

427
00:48:55,140 --> 00:49:01,760
从这里拿出来，然后让我再粘贴到这里，让我点击重新评估，在这里我们也是这样

428
00:49:01,760 --> 00:49:07,780
现在可以评估了，我们可以做的是，由于我们使用了模式匹配，我们可以提取出值

429
00:49:07,780 --> 00:49:15,220
找不到文件，我刚才说过，找不到这个值绑定到我们的变量

430
00:49:15,780 --> 00:49:22,680
我们可以通过简单地输入我们的原因来检查值，让我们点击重新评估，在这里

431
00:49:22,680 --> 00:49:29,840
我们得到了找不到文件的值，现在这个模式在elixir中非常常见，所以让我们

432
00:49:29,840 --> 00:49:36,320
再看一个例子，假设这次我们有一个成功的操作，例如

433
00:49:36,320 --> 00:49:42,100
如果我们正在开发某种网络应用程序，并且我们收到一个状态为200的消息

434
00:49:42,100 --> 00:49:49,240
那么此时我们可以对"okay"进行模式匹配，然后可以获得一条消息和

435
00:49:49,240 --> 00:49:57,740
这里我们可以传递我们的“好的”，我们可以说状态200好的，然后我们可以看到我们的内容

436
00:49:57,740 --> 00:50:04,020
现在让我们点击“评估”，正如你所看到的，我们得到了消息的值，所以再一次

437
00:50:04,020 --> 00:50:08,800
同样的事情发生在这里，我们只需要在右边进行模式匹配

438
00:50:08,800 --> 00:50:15,340
左边的“好的”与右边的“好的”匹配，这个字符串正在被

439
00:50:15,340 --> 00:50:20,660
绑定到我们的消息变量上，这就是我们在下一行调用的内容

440
00:50:20,660 --> 00:50:26,240
嗯，这就是关于原子的一切，下一个视频我们将从elixir内部的字符串开始

441
00:50:26,880 --> 00:50:33,860
我们系列中的下一个数据类型将是字符串，而elixir中的字符串则是这样表示的

442
00:50:33,860 --> 00:50:40,500
由双引号表示，所以这将是elixir的一个有效字符串，我们有双引号

443
00:50:40,500 --> 00:50:46,560
在双引号内我们有字符串，现在如果你使用单引号而不是双引号

444
00:50:46,560 --> 00:50:53,260
那么这意味着一个字符列表，而字符列表与字符串不同

445
00:50:53,260 --> 00:51:00,940
现在我们来玩一下elixir，让我们进入我们的ix。

446
00:51:00,940 --> 00:51:07,840
让我清理一下屏幕，就像我刚才说的，我们可以使用双引号创建一个字符串。

447
00:51:07,840 --> 00:51:14,940
所以让我写一个octalium，这将是一个有效的字符串在elixir中，现在会发生什么呢？

448
00:51:14,940 --> 00:51:21,780
ix还为我们提供了很多方便的函数来检查不同的数据类型。

449
00:51:21,780 --> 00:51:27,480
其中一种用于显示信息的函数被称为i，让我们调用它。

450
00:51:27,480 --> 00:51:32,900
让我们传递octalium的变量，并看看我们得到了什么样的输出。

451
00:51:33,660 --> 00:51:41,760
所以我们可以看到这个项是octalium，数据类型是二进制字符串，那么会发生什么呢？

452
00:51:41,760 --> 00:51:48,360
在elixir中，你的字符串实际上是保存为一系列字节，这就是为什么它会说

453
00:51:48,360 --> 00:51:57,460
数据类型是二进制字符串，接下来我们的字符串大小是九个字节，接下来

454
00:51:57,460 --> 00:52:05,240
字符串实际上是一个UTF-8编码的二进制，现在我刚才说过你的字符串被保存为一份

455
00:52:05,240 --> 00:52:10,960
字节的集合，这是它在内存中的实际样子，正如你所见

456
00:52:10,960 --> 00:52:17,700
注意到它以双角括号开头，也以双角括号结尾

457
00:52:17,700 --> 00:52:24,160
在这个集合中，你可以看到每个字符的整数表示

458
00:52:24,160 --> 00:52:33,400
字符串中的字符，比如整数79表示o，99表示c

459
00:52:33,400 --> 00:52:40,120
接下来，我们还可以看到为字符串类型实现的一些协议

460
00:52:40,120 --> 00:52:45,660
协议是一个稍微高级的主题，本教程不涉及协议内容

461
00:52:45,660 --> 00:52:51,340
但是现在让我们继续，看看我们还能用字符串做些什么，现在让我们来看一下

462
00:52:51,340 --> 00:52:57,180
通过模式匹配来看看字符串的神奇之处，现在字符串只是

463
00:52:57,180 --> 00:53:04,220
我们的字节的一个集合，我们可以使用模式匹配来提取其中的个体

464
00:53:04,220 --> 00:53:10,980
从字符串中提取代码点，让我清除屏幕，我们可以简单地做以下操作

465
00:53:10,980 --> 00:53:18,600
找到一个o来匹配八进制字符octalium，所以我们可以说我们的第一个字符应该是o，然后我们

466
00:53:18,600 --> 00:53:26,800
收集到一个不同的变量中，叫做rest，它等于octalium，让我们看看接下来会发生什么

467
00:53:26,800 --> 00:53:33,440
现在让我们看一下rest变量的内容，我们可以看到rest变量

468
00:53:33,440 --> 00:53:40,080
包含了o之后的所有字母，那么这一行发生了什么呢，再来看一下

469
00:53:40,080 --> 00:53:45,880
同样的道理，你的左边应该等于你的右边，在右边

470
00:53:45,880 --> 00:53:51,840
我们有一个大写字母o，这是一个模式匹配，接下来是一个字符串

471
00:53:51,840 --> 00:53:57,960
连接运算符，我们说我们要收集所有不同的代码点

472
00:53:57,960 --> 00:54:04,500
在一个叫做rest的变量中的o之后，那么从其他字符开始会发生什么

473
00:54:04,500 --> 00:54:15,240
从c一直到m，这些字符被绑定到我们的rest变量上，这就是我们的目的

474
00:54:15,240 --> 00:54:21,700
例如，假设我们再次想要看一下一个叫做abc的新字符串的信息

475
00:54:21,700 --> 00:54:28,000
现在再次，括号是可选的，所以即使我去掉这个括号，代码也应该

476
00:54:28,000 --> 00:54:35,080
工作了，这里我们得到了输出，我们可以看到a、b和c的原始表示是

477
00:54:35,080 --> 00:54:42,000
就在这里，现在发生的是，97只是表示我们字符a的代码点

478
00:54:42,000 --> 00:54:47,880
我们可以通过使用不同的语法来检查它，所以我们可以放一个问号后面

479
00:54:47,880 --> 00:54:56,060
由a，这样我们就得到了a的代码点表示，在这里我们可以看到它是97，这就是

480
00:54:56,060 --> 00:55:01,860
我们现在拥有的，假设我们想要查看b的代码点，那么b将会是

481
00:55:01,860 --> 00:55:09,500
98，对于c将是99，等等，现在我们把所有这些点记在心里，让我们继续

482
00:55:09,500 --> 00:55:16,780
我们的实时书，让我们再多玩一下字符串，所以在这里让我们创建

483
00:55:16,780 --> 00:55:23,380
一个新的部分，所以我想去博客上创建一个新的部分，这个部分是关于你的

484
00:55:23,380 --> 00:55:31,560
字符串，所以让我们在这里创建相同的字符串，这样我们就可以说我们想创建一个变量

485
00:55:31,560 --> 00:55:38,400
称之为name，并将其值分配给octalim，然后让我们打印出来

486
00:55:38,400 --> 00:55:44,700
name的值，让我们看看我们得到了什么输出，正如预期，我们得到了我们的字符串

487
00:55:44,700 --> 00:55:52,280
接下来我们还可以检查给定的数据是否为字符串类型，为此我们可以

488
00:55:52,280 --> 00:55:59,760
使用一个名为is_binary的内置函数，所以记住你的字符串被表示为一个

489
00:55:59,760 --> 00:56:06,940
原始代码点的集合或字节的集合，所以我们可以使用这个is的函数

490
00:56:06,940 --> 00:56:13,740
二进制，并让我们传递name变量，让我们尝试计算，我们得到的答案是

491
00:56:13,740 --> 00:56:20,780
true，所以是的，这是一个二进制表示，这意味着这是一个字符串，接下来让我们看看如何将两个字符串相加

492
00:56:20,780 --> 00:56:27,440
所以让我创建一个新的代码块，让我们创建一个名为message的新变量

493
00:56:27,440 --> 00:56:34,560
在这里我们可以创建一条消息，说hello，并且对于添加或连接，我们有

494
00:56:34,560 --> 00:56:41,740
这个双角括号，然后让我们传递name变量，所以再次只是为了帮助你

495
00:56:41,740 --> 00:56:47,980
记住这里有尖括号，如果你回到我们的终端，我们可以看到

496
00:56:47,980 --> 00:56:53,760
这里的原始表示法也有尖括号，唯一的区别是

497
00:56:53,760 --> 00:56:59,600
我们使用双尖括号进行表示，而用于字符串连接的是单个尖括号

498
00:56:59,600 --> 00:57:05,180
尖括号，让我们看看这个的输出，让我们试着评估一下，这里是

499
00:57:05,180 --> 00:57:11,360
hello octalium的消息，接下来我们可以使用模式匹配，让我们试着提取值

500
00:57:11,360 --> 00:57:17,140
从字符串中，所以让我们创建一个新的代码块，这里我们可以再次进行模式匹配，所以我们可以说

501
00:57:17,140 --> 00:57:23,960
前几个字符应该是hello，然后是hello后面的剩余部分我想要收集起来

502
00:57:23,960 --> 00:57:30,500
放在一个名为name的新变量中，在右边我们只需要传递消息

503
00:57:30,500 --> 00:57:36,900
记住消息是hello octalium，所以hello和这个空格，就是

504
00:57:36,900 --> 00:57:43,080
模式匹配就在这里，octalium的名字将绑定到我们的name变量上

505
00:57:43,080 --> 00:57:49,080
接下来我们还可以查看变量name的内容，所以让我们把它写在这里。

506
00:57:49,080 --> 00:57:55,320
让我们尝试进行评估，这里我们得到的名字是octalium，现在还有一种方式。

507
00:57:55,320 --> 00:58:01,980
通过与字符串进行模式匹配，这种方法是通过对原始表示进行模式匹配。

508
00:58:01,980 --> 00:58:08,000
所以让我们看看我们如何做到这一点，让我们创建一个新的代码块，现在请记住原始字符串。

509
00:58:08,000 --> 00:58:14,620
表示是由我们的双尖括号完成的，让我们试着进行模式匹配，所以在这里我们

510
00:58:14,620 --> 00:58:22,520
想要对第一个字符或第一个代码点进行模式匹配，并且让我们称之为

511
00:58:22,520 --> 00:58:29,120
将该变量称为head，接下来我们要做的就是要收集所有剩余的代码

512
00:58:29,120 --> 00:58:36,240
点，并且我们可以将该变量称为rest，现在由于我们使用原始的表示

513
00:58:36,240 --> 00:58:42,700
字符串表示，我们还需要告诉Elixir我们想要以哪种格式收集所有的

514
00:58:42,700 --> 00:58:49,640
剩余的代码点，所以在这里我们可以说rest的类型将是二进制，并且在右侧

515
00:58:49,640 --> 00:58:56,840
我们只需要与名称进行模式匹配，然后看看变量中的内容

516
00:58:56,840 --> 00:59:03,320
头部，然后让我们尝试评估这个单元格，现在发生的是

517
00:59:03,320 --> 00:59:09,340
我们实际上得到了代码点，如果我们回到终端，我们可以看到

518
00:59:10,100 --> 00:59:17,460
所以这个97实际上表示的是我们的代码点a，这就是发生的事情

519
00:59:17,460 --> 00:59:25,540
所以在这种情况下，79实际上表示的是我们o的代码点，我们可以在一个新的代码块中检查一下

520
00:59:25,540 --> 00:59:32,660
代码块，所以让我们在这里创建一个新的代码块，在这里我们可以说我的头等于

521
00:59:32,660 --> 00:59:38,780
o的代码点，让我们尝试评估并看看我们得到什么答案，是的

522
00:59:38,780 --> 00:59:43,980
答案是真的，所以如果你感到有点困惑，让我们回到我们的终端

523
00:59:44,700 --> 00:59:50,720
让我清除所有这些东西，让我们检查一下我们的o字符的代码点

524
00:59:50,720 --> 00:59:57,460
我们得到了79的整数表示，这就是我们在这里检查的内容

525
00:59:57,460 --> 01:00:03,640
头部的值是79，这是我们在这行中要检查的，而且由于字符

526
01:00:03,640 --> 01:00:10,540
o也是79，这就是为什么这个表达式评估为真，所以你可以看到

527
01:00:10,540 --> 01:00:16,520
模式匹配在Elixir中非常强大，我们几乎在任何地方都使用模式匹配

528
01:00:16,520 --> 01:00:23,980
在Elixir内，让我们使用相同的示例，所以让我从这里复制，让我们创建一个新的

529
01:00:23,980 --> 01:00:29,720
代码块，让我将其粘贴在这里，而不是使用这个head变量

530
01:00:29,720 --> 01:00:36,960
让我们对o进行模式匹配，看看我们是否能够找到剩余的部分，让我们尝试评估一下

531
01:00:36,960 --> 01:00:43,320
这个表达式，我们得到了正确的答案，所以现在我们得到了从c到m的所有字符

532
01:00:43,320 --> 01:00:49,280
并不一定非得只在单个字符上进行模式匹配，我们可以在多个字符上进行模式匹配

533
01:00:49,280 --> 01:00:56,100
所以让我复制这个，让我们创建一个新的代码块，让我将其粘贴在这里

534
01:00:56,100 --> 01:01:02,300
这次我们可以使用两个字符，所以让我们在o和c上进行模式匹配，然后让我们检查

535
01:01:02,300 --> 01:01:08,920
获取剩余部分的内容，然后让我们尝试评估这个单元格，正如你所看到的，我们得到了正确的结果

536
01:01:08,920 --> 01:01:15,240
输出，所以你可以看到模式匹配在Elixir中真的非常强大，接下来你可以

537
01:01:15,240 --> 01:01:21,060
在与字符串进行模式匹配时，你也可以非常具体地指定数量

538
01:01:21,060 --> 01:01:26,540
你想收集的字符串，所以让我给你展示一个例子，让我们在这里创建一个

539
01:01:26,540 --> 01:01:34,200
新的代码块，让我在这里复制这个东西，现在不要说o和c了，我们

540
01:01:34,200 --> 01:01:39,860
可以做的是我们可以说我们想要创建一个变量，叫做head，而在这个变量里面

541
01:01:39,860 --> 01:01:46,560
我们想要收集前两个二进制，所以在这里我们可以说我们想要收集二进制

542
01:01:47,100 --> 01:01:53,340
而且二进制的大小应该是两个字符，接下来让我们检查一下我们的输出

543
01:01:53,840 --> 01:02:00,900
head，然后让我们尝试评估一下这个，正如你所看到的，我们得到了字符o和c

544
01:02:00,900 --> 01:02:06,520
回来了，好了，这就是Elixir中关于字符串的全部内容，如果你不理解这个模式，不要担心

545
01:02:06,520 --> 01:02:11,300
与二进制匹配和所有这些东西，我只是想向你展示所有不同的

546
01:02:11,300 --> 01:02:19,040
通过在elixir内部使用模式匹配，下一个数据类型是我们的字符列表或

547
01:02:19,040 --> 01:02:25,220
我们的字符列表，如我已经解释过的，通过使用单个字符创建

548
01:02:25,220 --> 01:02:30,420
引号，所以让我们创建一个名为characters的变量，并赋值为

549
01:02:30,420 --> 01:02:36,940
octalium，现在你可以看到我在这里使用单引号，我们得到了值

550
01:02:36,940 --> 01:02:42,820
octalium的，现在让我们做一件事，让我复制这个并让我们去我们的终端

551
01:02:43,340 --> 01:02:50,280
在我的ix内部，我可以检查信息，所以我可以使用i的内置函数

552
01:02:50,280 --> 01:02:55,520
让我把字符字符串粘贴在这里，让我们看看我们得到了什么样的输出

553
01:02:55,520 --> 01:03:03,360
得到的结果，所以这次如果你看到数据类型实际上是一个列表，上一次我们在学习的时候

554
01:03:03,360 --> 01:03:11,420
关于字符串，数据类型是一个二进制字符串，但这是一个包含字符的集合内部的

555
01:03:11,420 --> 01:03:18,900
列表，如果您想查看原始表示形式，这里就是，请注意，由于这是一个

556
01:03:18,900 --> 01:03:25,480
列表的开头和结尾都有方括号，正如您所见，每个

557
01:03:25,480 --> 01:03:32,600
字符也由其整数值表示，所以再次重申，79表示

558
01:03:32,600 --> 01:03:42,760
'o'，其值为99，然后是'c'，其值为116，依此类推，让我们回到我们的实时书中

559
01:03:43,940 --> 01:03:49,660
接下来，让我们看看如何将两个字符列表相加，所以让我添加一个新的块

560
01:03:49,660 --> 01:03:57,700
在这里，让我创建一个新的字符字符串，让我说一声“你好”，用于添加或连接

561
01:03:57,700 --> 01:04:03,780
两个列表在一起，我们必须使用双加号符号，让我传递字符值

562
01:04:03,780 --> 01:04:09,740
就在这里，让我们尝试评估此单元格，然后我们将得到新的值“hello”

563
01:04:09,740 --> 01:04:16,440
总结一下，对于字符串，我们使用尖括号，但由于这是一个列表

564
01:04:16,440 --> 01:04:22,620
这就是为什么我们使用双加号符号，接下来我们还可以使用内置函数来检查

565
01:04:22,620 --> 01:04:28,460
如果给定的字符确实是一个字符列表，让我再次添加一个代码块

566
01:04:28,460 --> 01:04:34,720
在这里，我们可以使用内置的is_list函数，让我们把我们的字符传递进去

567
01:04:34,720 --> 01:04:41,340
让我们尝试评估一下，是的，我们得到的答案是true，最后一点是我们可以

568
01:04:41,340 --> 01:04:46,960
始终要检查代码点，所以我们可以使用问号，然后我们可以使用一个字符

569
01:04:46,960 --> 01:04:56,580
所以a的代码点值是97，如果我们检查o，它将是79，依此类推，所以这样

570
01:04:56,580 --> 01:05:02,980
这就是关于字符的全部内容，接下来要看的是被称为进程的下一个类型，所以让

571
01:05:02,980 --> 01:05:11,040
我来整理一下，这里让我们添加一个块，我们想要添加一个进程部分，让

572
01:05:11,040 --> 01:05:16,440
让我们在这里添加一个代码块，如果你参考一下我之前的视频，这是那个视频

573
01:05:16,440 --> 01:05:22,880
关于进程的，我解释了所有的代码都在进程内执行，所以这些

574
01:05:22,880 --> 01:05:29,500
进程也是Elixir内的一个有效类型，我们可以检查当前的进程，我们的

575
01:05:29,500 --> 01:05:36,480
现在 LiveBook 正在运行，所以我们创建一个名为 mypid 的变量，其中 pit 代表进程。

576
01:05:36,480 --> 01:05:44,040
我们可以使用内置的 self 函数，并且让我们在这之后检查 mypid 的输出。

577
01:05:44,040 --> 01:05:47,980
让我们看看我们得到了什么样的输出，所以我们得到的输出是

578
01:05:48,580 --> 01:05:55,540
bid 现在是 144，现在如果你回到我们的终端并且在这里让我们检查我们的 ix 进程

579
01:05:55,540 --> 01:06:00,800
正在运行，所以让我调用 self 函数，这一次我们可以看到我们有一个不同的

580
01:06:00,800 --> 01:06:07,960
bid 号码，我们的 ix 进程的进程 ID 是 107，但是如果我们回到我们的
LiveBook，我们可以看到

581
01:06:08,410 --> 01:06:15,240
正在运行在进程号 144 中，现在在 Elixir 中的进程和并发是一个非常

582
01:06:15,240 --> 01:06:21,180
庞大的话题，它需要专门的教程，但是对于这门课程，让我们继续前进

583
01:06:21,180 --> 01:06:26,540
让我们看看下一个类型，让我们在这里添加一个新的部分，所以我想添加一个新的

584
01:06:26,540 --> 01:06:33,380
部分，这一部分是关于我们的列表的，让我把这个东西稍微提高一点，所以这个数字

585
01:06:33,380 --> 01:06:39,560
关于列表，你需要明白的一件事是，Elixir中的列表实际上是链接的

586
01:06:39,560 --> 01:06:45,480
它们并不是常规的列表，所以如果你尝试进行像索引这样的操作，它是不会生效的

587
01:06:45,480 --> 01:06:51,780
工作的。准确来说，Elixir中的列表实际上是单向链表，所以让我们

588
01:06:51,780 --> 01:06:57,100
看看我们如何在Elixir中使用列表，让我们在这里创建一个新的代码块

589
01:06:57,100 --> 01:07:02,760
然后让我们创建一个列表，这是我们的列表，对于一个列表我们可以看到我们有

590
01:07:02,760 --> 01:07:09,420
在开头和结尾都有方括号，让我们尝试评估这个单元格，我们得到了列表

591
01:07:09,420 --> 01:07:16,220
现在再让我试试并重复一下，这个列表不是你常规的数组

592
01:07:16,220 --> 01:07:23,080
这是一个单向链表，让我们做一个小实验，尝试对它进行索引

593
01:07:23,080 --> 01:07:28,600
让我们创建一个新的代码块，假设我试图查看在

594
01:07:28,600 --> 01:07:35,600
索引处的元素，现在让我们看看会发生什么，正如你所看到的，我们得到了一个错误，这个错误是因为

595
01:07:35,600 --> 01:07:41,780
这个列表实际上是一个链表，而不是你的常规列表，现在我们使用链表的原因是链表是递归的，你的常规数组或列表不是递归的，它们必须在内存中连续保存，但是如何在Elixir中使用列表呢？

596
01:07:41,780 --> 01:07:48,720
Elixir中的列表是由于链表是递归的性质，你的常规数组或列表不是递归的

597
01:07:48,720 --> 01:07:54,380
常规列表不是递归的，它们必须在内存中连续保存，但是如何

598
01:07:54,380 --> 01:08:00,440
在Elixir中使用列表有很多机制，首先显而易见的是使用

599
01:08:00,440 --> 01:08:06,860
递归函数，或者我们还可以使用很多内置模块，让我给你展示一个模块

600
01:08:06,860 --> 01:08:12,880
让我在这里添加一个代码块，让我们把一切都放在上面，现在我们可以使用这个模块

601
01:08:12,880 --> 01:08:20,120
enum模块，我们可以说enum模块可以使用内置函数add，让我们传递我们的列表

602
01:08:20,120 --> 01:08:25,200
让我们将索引称为零，看看我们得到了什么样的输出

603
01:08:25,200 --> 01:08:31,340
在这里我们可以看到我们得到的输出是a，所以我们在做什么是enum实际上是一个

604
01:08:31,340 --> 01:08:38,860
Elixir内置的模块，add是一个在enum模块内定义的函数，在这里

605
01:08:38,860 --> 01:08:45,560
我们只是在为函数传递参数，让我们回到我们的ix并让我

606
01:08:45,560 --> 01:08:51,840
清理一切，让我从顶部腾出一些空间，如果我写枚举点，如果我

607
01:08:51,840 --> 01:08:58,220
按下tab键，我们可以看到我们有很多内置函数用于枚举模块和

608
01:08:58,220 --> 01:09:04,820
我们使用的函数就在这里，现在这个斜杠两个实际上表示了arity，现在arity

609
01:09:04,820 --> 01:09:10,760
什么都没有，它只是你的函数可以接受的参数的数量，在elixir中我们实际上可以

610
01:09:10,760 --> 01:09:16,960
通过使用不同的参数来定义我们的函数，所以例如你可以看到在这里我们有

611
01:09:16,960 --> 01:09:22,580
一个称为any的函数，对于这个函数我们有两种类型，第一种类型就在这里

612
01:09:22,580 --> 01:09:29,100
所以这个函数只接受一个参数，这就是为什么arity是一，而在这里我们有相同的

613
01:09:29,100 --> 01:09:36,200
函数any，但这次它接受两个参数，所以arity显示为两个，现在让我

614
01:09:36,200 --> 01:09:41,660
清理所有这些东西，现在让我给你展示elixir中的另一个辅助函数

615
01:09:41,660 --> 01:09:47,280
而函数的名称是h，因此h代表你的助手，如果你愿意，你可以使用

616
01:09:47,280 --> 01:09:53,760
括号可以省略，我们需要指定哪个模块或哪个函数

617
01:09:53,760 --> 01:09:59,580
我们想要帮助的是什么，帮助函数的作用就是简单地打印出文档

618
01:09:59,580 --> 01:10:05,380
对于那个模块或函数，所以我们需要指定我们要查看的是

619
01:10:05,380 --> 01:10:10,880
枚举模块的文档，我们想要看到来自枚举的文档

620
01:10:10,880 --> 01:10:16,300
add函数的文档，这里我们得到了文档，你可以看到的第一行

621
01:10:16,300 --> 01:10:21,760
这里是关于你的函数定义的一切，你可以看到第一个参数是

622
01:10:21,760 --> 01:10:28,620
实际上是一个可枚举的，第二个参数是索引，这个函数还接受一个可选的

623
01:10:28,620 --> 01:10:35,220
参数，名称为default，默认值为nil，这两个表示这个default参数是可选的

624
01:10:35,220 --> 01:10:42,060
表示这个default参数是一个可选参数，在这种情况下，如果这个参数

625
01:10:42,060 --> 01:10:48,960
如果未指定，则默认值为nil。接下来，我们可以看到我们有几个示例。

626
01:10:48,960 --> 01:10:54,960
这里有几个示例，你可以看到这个帮助函数非常有用，我提供

627
01:10:54,960 --> 01:11:04,920
使用这个函数来阅读我的终端内的文档，现在让我们回到我们的

628
01:11:05,320 --> 01:11:12,500
和我们的列表一起，让我创建一个新的代码块，现在如果你参考我们的列表，我们的列表有

629
01:11:12,500 --> 01:11:17,620
三个不同的元素，我们可以使用模式匹配来提取所有这些元素

630
01:11:17,620 --> 01:11:23,740
让我向你展示我们如何做到这一点，所以让我创建一些不同的变量

631
01:11:23,740 --> 01:11:29,960
第一个应该被称为第一第二第三，你可以把这些参数称为任何你想要的东西

632
01:11:29,960 --> 01:11:35,720
在右边，我只想在列表上进行模式匹配，所以将会发生的是

633
01:11:35,720 --> 01:11:41,760
同样的事情，左边应该等于右边，所以首先的事情是

634
01:11:41,760 --> 01:11:48,420
这是一个列表，在左边我们确实有一个列表，我们只是试图在上面进行模式匹配

635
01:11:48,420 --> 01:11:55,440
不同的元素，所以a会绑定到我们的第一个变量，你的b会绑定到第二个变量

636
01:11:55,440 --> 01:12:02,640
c会绑定到第三个变量，让我们检查一下第二个变量里面的数据，让我调用一下

637
01:12:02,640 --> 01:12:09,320
这里是第二个变量，让我把它提取出来，同时让我们尝试评估这个单元格，我们得到的结果是

638
01:12:09,320 --> 01:12:15,840
将值返回为b，现在如果你不想要所有的变量，只想要

639
01:12:15,840 --> 01:12:22,540
忽略其中一些，那么我们可以简单地使用下划线来忽略这些值，假设

640
01:12:22,540 --> 01:12:28,960
我不想要第一个和第二个变量的值，那么我们可以这样做，这样我们就可以创建一个列表，因为

641
01:12:28,960 --> 01:12:34,780
我想忽略第一个值，我可以使用下划线，我也想忽略第二个值

642
01:12:34,780 --> 01:12:40,760
所以让我再加一个下划线，接下来我想收集第三个值，所以让我创建一个

643
01:12:40,760 --> 01:12:49,520
变量称为third，让我们将一个列表赋值过来，所以我们的列表是a、b和c，现在让我们

644
01:12:49,520 --> 01:12:56,440
检查一下third里面的值，让我们尝试一下评估，我们得到的值是c，那么现在是什么情况呢？

645
01:12:56,440 --> 01:13:02,760
发生的是，因为我们有一个下划线，所以变量a的值被简单地忽略了，同样的事情

646
01:13:02,760 --> 01:13:10,360
b也是一样，最后c的值绑定到了我们的变量third上，让我来

647
01:13:10,360 --> 01:13:16,140
给你展示一些方便处理列表的函数，首先是

648
01:13:16,140 --> 01:13:22,220
被称为head，让我来给你展示一下我的意思，head函数只是取出第一个值

649
01:13:22,220 --> 01:13:29,120
并将其返回，所以如果我们调用head的内置函数，并将我们的列表传递给它

650
01:13:29,120 --> 01:13:35,380
让我们来尝试一下，正如你所见，我们得到了a的值，类似于head函数

651
01:13:35,380 --> 01:13:41,480
还有另一个被称为tail的函数，让我创建一个新的代码块和这个函数

652
01:13:41,480 --> 01:13:47,300
被称为t和l，现在tail函数要做的就是简单地忽略掉

653
01:13:47,300 --> 01:13:52,980
head值，然后将剩下的所有值返回，让我传递变量

654
01:13:53,420 --> 01:14:00,080
给这个函数，然后让我们来尝试一下，我们得到了b和c的值

655
01:14:00,080 --> 01:14:05,160
还有一种快捷方法可以做到这一点，让我向你展示一下我们如何做到这一点

656
01:14:05,720 --> 01:14:12,720
这次我们可以简单地在列表上进行模式匹配，所以让我们创建一个列表，我想要模式

657
01:14:12,720 --> 01:14:20,240
在一个名为head的新变量内匹配第一个值，然后让我使用cons

658
01:14:20,240 --> 01:14:25,940
然后我可以说我想把所有剩下的值收集到一个新的变量中

659
01:14:25,940 --> 01:14:32,600
称为tail，并让我将list的值分配给它，接下来让我们检查一下里面的值

660
01:14:32,600 --> 01:14:39,740
head，让我们尝试评估这个单元格，正如预期的那样，我们得到了一个返回值，现在这个管道运算符是

661
01:14:39,740 --> 01:14:45,960
也被称为cons运算符，用于操作我们的链表，接下来让我们还检查一下里面的值

662
01:14:45,960 --> 01:14:52,000
t，所以让我创建一个新的代码块，让我调用key变量，正如你所看到的，我们只是简单地

663
01:14:52,000 --> 01:14:59,440
获得我们列表中剩下的值，下一个数据类型是元组，我们已经

664
01:14:59,440 --> 01:15:05,680
看到了一些元组的例子，但是让我再次向你展示一下，元组是通过创建来的

665
01:15:05,680 --> 01:15:12,880
使用花括号，我们可以创建一个包含两个元素的元组，可以这样说

666
01:15:12,880 --> 01:15:20,440
值应该是一和二，所以这些花括号用于创建一个元组，现在元组

667
01:15:20,440 --> 01:15:27,660
与数组非常相似，元组中的所有数据都连续保存在内部

668
01:15:27,660 --> 01:15:34,160
内存中经常出现两个或三个元素的元组，但是如果你想要

669
01:15:34,160 --> 01:15:39,940
保存大量元素，建议使用列表，现在这里也是

670
01:15:39,940 --> 01:15:47,080
我们可以进行简单的模式匹配，所以在左边让我们创建一个新的元组，我们可以说a和b

671
01:15:47,080 --> 01:15:54,380
让我们检查a的值并尝试进行评估，我们得到的值是一

672
01:15:54,380 --> 01:15:59,660
这次让我们创建一个三个元素的元组，所以将来无论你何时学习

673
01:15:59,660 --> 01:16:05,000
使用phoenix进行web开发时，你会发现拥有三个元素非常常见

674
01:16:05,000 --> 01:16:11,100
或者最多四个元素的元组，一个非常常见的模式可能是这样的，首先

675
01:16:11,100 --> 01:16:17,720
元素将被称为消息的元组，第二个元素将是实际的消息

676
01:16:17,720 --> 01:16:24,260
您想要发送回去的，第三个元素通常是服务器的状态，让我们

677
01:16:24,260 --> 01:16:31,620
右边的元组，因此第一个元素应该是回复消息，可能是一个字符串，找到了octalium

678
01:16:31,620 --> 01:16:38,060
而且对于状态，我们可以传递一个octalium所有朋友的简单列表，所以我们可以说

679
01:16:38,060 --> 01:16:45,180
octalium、louis和chico，接下来让我们尝试打印出消息，让我们尝试评估

680
01:16:45,820 --> 01:16:53,040
我们还要检查服务器的状态，所以我们可以说状态，并让我们尝试重新评估

681
01:16:53,040 --> 01:16:59,560
我们得到了正确的列表，所以正如你所看到的，元组是一种非常方便的数据结构

682
01:16:59,560 --> 01:17:06,020
在Elixir中，但通常不要在元组中使用超过三个或四个元素，下一个

683
01:17:06,020 --> 01:17:13,020
我们将要看到的数据类型也被称为关键字列表，所以让我向您展示一下

684
01:17:13,020 --> 01:17:20,360
关键字列表在Elixir中的样子，所以我们可以创建一个名为data的变量，现在关键字列表是

685
01:17:20,360 --> 01:17:29,360
一个列表，但在列表中我们有键和值对，所以我们可以说a是一个，所以

686
01:17:29,360 --> 01:17:37,180
a是你的键，1是值，你可以说b和2，让我们尝试评估一下，我们得到

687
01:17:37,180 --> 01:17:44,800
回到我们的关键词列表，现在关键词列表中发生的是你的键通常是一个

688
01:17:44,800 --> 01:17:51,900
但是如果你记得我们首先将项目写成冒号，然后是项目的名称，而且

689
01:17:51,900 --> 01:17:58,160
事实上，这个键值对实际上被保存为一个元组，所以让我向你展示它是如何保存的

690
01:17:58,160 --> 01:18:06,380
所以在这里让我创建一个列表，在第一个元素内，也就是键，总是保存为

691
01:18:06,380 --> 01:18:13,960
一个原子，所以我可以说a，第二个元素是值，所以它将是1，让我们尝试一下

692
01:18:13,960 --> 01:18:21,520
在一个非常简单的关键词列表上进行模式匹配，所以我们可以说a和1，正如你在这里看到的

693
01:18:21,520 --> 01:18:27,420
a和冒号，这只是一个方便的功能，但在关键词列表内保存时它是

694
01:18:27,420 --> 01:18:34,500
实际上被保存为原子，这个键值对被转换为一个元组，我们可以看到

695
01:18:34,500 --> 01:18:40,800
现在在这里让我们尝试评估，如果我们得到相同的答案，那就意味着我们有一个匹配。

696
01:18:40,800 --> 01:18:46,420
在右手边和左手边之间，用于访问内部不同的值。

697
01:18:46,420 --> 01:18:54,020
我们可以使用内置模块来访问关键字列表，所以让我们回到终端，让我写一下。

698
01:18:54,020 --> 01:19:01,020
关键字点，然后让我按下制表符，正如你所见，我们有很多方便的功能。

699
01:19:01,020 --> 01:19:06,600
让我们回到实时书籍，让我向你展示如何提取值。

700
01:19:06,600 --> 01:19:13,320
根据给定的键，例如，我可以说我想要访问我的关键字数据列表。

701
01:19:13,320 --> 01:19:21,140
然后我想访问键为a的键，并且让我们尝试评估，我们将得到数据作为一个。

702
01:19:21,140 --> 01:19:27,800
好了，就这些，我们将在下一个中学到更多关于地图和结构的内容。

703
01:19:27,800 --> 01:19:34,500
我们将要学习的下一个数据结构被称为地图，所以让我创建一个名为的变量

704
01:19:34,500 --> 01:19:41,520
作为我的地图，现在在上一个视频中，我们看到了如何创建一个元组，对于创建一个元组，我们通常

705
01:19:41,520 --> 01:19:49,260
使用花括号创建地图时，只需添加一个人符号，因此地图更像是

706
01:19:49,260 --> 01:19:55,780
在Python中，您的字典也是一种键值对的数据结构，这些地图也是您的键和值

707
01:19:55,780 --> 01:20:03,360
但与元组或地图内部的关键字列表相比，地图提供了许多功能

708
01:20:03,360 --> 01:20:10,180
我们可以为键使用不同的数据类型，但现在让我们看看如何使用原子作为键

709
01:20:10,180 --> 01:20:19,940
我们的键，因此我们只需说一个冒号和一个，然后再添加一个元素b，再添加一个

710
01:20:19,940 --> 01:20:27,900
更多的c和三，这就是您如何创建一个地图，当您使用元组时会发生什么

711
01:20:27,900 --> 01:20:34,140
在那时，我们可以使用点符号来表示，我很快会向您展示点符号是什么意思

712
01:20:34,140 --> 01:20:41,420
符号，但现在让我们看看地图的样子，然后我们会得到地图，接下来我们可以

713
01:20:41,420 --> 01:20:47,920
使用模式匹配来提取值，所以让我在这里创建一个地图，在地图的内部我们可以

714
01:20:47,920 --> 01:20:55,160
在键为a的地方进行模式匹配，然后将值收集到一个名为first的变量中

715
01:20:55,160 --> 01:21:01,060
接下来，我们可以和b进行模式匹配，让我们收集第二个变量的值，

716
01:21:01,060 --> 01:21:08,020
最后一个，我们可以使用第三个变量，并让我们与my map变量进行模式匹配

717
01:21:08,920 --> 01:21:15,320
让我们看一下变量first的值，让我们尝试进行评估，我们得到的结果

718
01:21:15,320 --> 01:21:21,080
正确答案很明显，map是一种非常方便的数据结构，假设您想要

719
01:21:21,080 --> 01:21:27,400
只提取第二个值，您不必使用整个map，而是我们可以做一些事情

720
01:21:27,400 --> 01:21:34,200
就像这样，让我展示给你看，让我们创建一个map，假设我们只想要模式匹配

721
01:21:34,200 --> 01:21:42,820
在b的键上进行匹配，让我们收集第二个变量的值，让我们与我们的变量进行模式匹配

722
01:21:42,820 --> 01:21:49,800
我们的map中的map，让我们看一下第二个变量的值，正如您所看到的，我们得到了正确的答案

723
01:21:50,360 --> 01:21:56,740
因此，创建整个map进行模式匹配并不是必须的，相反，我们可以创建一个更短的map

724
01:21:56,740 --> 01:22:03,480
只需所需的元素，所以在这里，我们只是在b的键上进行模式匹配，

725
01:22:03,480 --> 01:22:08,800
正在收集第二个变量内的值，下一步是因为我们正在使用

726
01:22:08,800 --> 01:22:15,540
我们可以使用点标记法来访问值，因此让我们创建一个代码块

727
01:22:15,540 --> 01:22:22,260
我们可以说我的 map 点 a，让我们尝试评估一下，我们得到了答案，但是

728
01:22:22,260 --> 01:22:28,680
如果我们有不同的数据类型，例如，如果我们的键值是字符串，那么你就不能

729
01:22:28,680 --> 01:22:36,820
使用点标记法，让我们再创建一个 map ，让我称其为 map two ，让我们创建

730
01:22:36,820 --> 01:22:43,260
我们的 map 就在这里，如果您计划使用字符串作为键，则我们需要编写它们

731
01:22:43,260 --> 01:22:49,580
代码，因为它们是字符串，而且因为我们使用的是不是原子的数据类型

732
01:22:49,580 --> 01:22:56,100
键，我们需要使用箭头符号，在这里我们可以将值分配为 1 ，接下来让我们创建

733
01:22:56,100 --> 01:23:03,080
再创建一个键为 b ，再次记住，由于键不是原子，我们使用箭头括号

734
01:23:03,080 --> 01:23:09,420
在这里，我们可以将值分配为 2 ，然后创建最后一个 c ，让我们分配值

735
01:23:09,420 --> 01:23:17,260
三个的，让我们评估单元格，然后我们得到我们的地图。接下来，我们可以使用相同的模式。

736
01:23:17,260 --> 01:23:23,820
匹配技巧，例如，如果我们想提取c的值，那么让我们创建一个地图。

737
01:23:23,820 --> 01:23:30,300
由于这次的键是字符串，我们就在这里进行模式匹配，假设

738
01:23:30,300 --> 01:23:36,020
我们想收集变量c内的值，让我们与我们的模式匹配

739
01:23:36,020 --> 01:23:42,740
第二个，让我们看看变量c内的值，我们得到正确的值返回

740
01:23:42,740 --> 01:23:48,820
Elixir提供了很多内置功能来处理我们的地图，所以如果我们回到我们的

741
01:23:48,820 --> 01:23:55,840
终端，如果我输入map并键入tab，我们可以看到我们有很多不同的功能

742
01:23:55,840 --> 01:24:06,000
例如，如果您想获取某些内容，或者如果您想创建一个新地图，或者如果您想要

743
01:24:06,000 --> 01:24:11,740
与地图一起做很多事情，但现在让我向您展示一种非常简单的方法

744
01:24:11,740 --> 01:24:18,260
更新我们的地图，让我们创建一个新的代码块，假设我们想要更新该值

745
01:24:18,260 --> 01:24:25,120
将 c 的值从三更新为四，然后我们可以说我们想要更新我们的映射的值

746
01:24:25,120 --> 01:24:32,000
变量名是 map2，然后我们可以使用管道运算符，然后我们可以说

747
01:24:32,000 --> 01:24:40,080
我们想要将 c 的值从三更新为四，让我们将这个值绑定回来

748
01:24:40,080 --> 01:24:46,320
到我们的变量 map2 上，然后让我们尝试评估并看看我们得到了什么样的输出

749
01:24:46,320 --> 01:24:52,700
得到的结果，如你所见，我们已经更新了 c 的值，现在我们正在使用这个箭头符号

750
01:24:52,700 --> 01:25:00,060
因为我们的键值是字符串，但是如果我们有原子的话，我们可以简单地使用

751
01:25:00,060 --> 01:25:07,420
冒号，所以让我给你展示一下，我们有另一个名为 my map 的映射，然后我们可以说

752
01:25:07,420 --> 01:25:14,380
我们想要更新 my map，这次我们想要更新 c 的值，由于 c 只是一个

753
01:25:14,380 --> 01:25:20,660
原子，我们可以使用常规的符号，然后我们可以说我们想要将值更新为四

754
01:25:20,660 --> 01:25:27,040
让我们尝试评估一下，我们得到了更新后的值，好了，这就是这个视频的内容

755
01:25:27,040 --> 01:25:32,700
这只是一个关于地图的简短介绍，随着教程的进展，我们将学习更多关于如何使用地图的内容。

756
01:25:32,700 --> 01:25:39,280
在教程中的进展中，下一个视频将全面介绍Elixir中的结构体，这是下一个数据类型。

757
01:25:39,280 --> 01:25:45,380
结构体是其中一种数据类型，如果你有C或Go等编译型编程语言的经验，你一定很熟悉。

758
01:25:45,380 --> 01:25:57,020
你可能已经使用过结构体，现在让我们来看看如何在Elixir中创建一个结构体。

759
01:25:57,020 --> 01:26:03,980
以模块的名称为例，假设我们想为用户定义一个结构体，我们可以创建一个

760
01:26:03,980 --> 01:26:11,800
模块，我们可以说创建一个名为"用户"的模块，然后在模块内部我们可以使用另一个宏

761
01:26:11,800 --> 01:26:18,780
这个宏的名称叫做"def struct"，现在我们可以看到这里面的所有内容

762
01:26:18,780 --> 01:26:26,280
def模块，def结构这些都是宏，它们意味着它们从给定的代码中创建代码

763
01:26:26,280 --> 01:26:31,980
但是现在我们不需要更多地了解宏，让我们看看如何定义一个结构体

764
01:26:31,980 --> 01:26:38,460
我们所定义的是我们创建了一个名为"用户"的模块，然后我们使用了另一个宏

765
01:26:38,460 --> 01:26:45,460
现在被称为def struct，现在我们需要为我们的结构体指定不同的字段，这些字段

766
01:26:45,460 --> 01:26:51,660
字段必须以键值对的格式指定，现在我们可以再次使用

767
01:26:51,660 --> 01:26:57,680
如果你想的话，你可以使用符号，如果不想使用，可以省略，并让我们看看如何指定

768
01:26:57,680 --> 01:27:05,120
字段，因此我们可以说第一个字段应该是用户名，第二个字段应该是

769
01:27:05,120 --> 01:27:12,160
电子邮件，这是一种指定字段的方式，但如果您想要在初始化时使用一些值

770
01:27:12,160 --> 01:27:18,060
那么我们还可以传递键值对，例如，如果您想要说的是，在

771
01:27:18,060 --> 01:27:25,960
初始化时，我们希望年龄为空，对于电子邮件，我们可以说我们想要一个空的

772
01:27:25,960 --> 01:27:32,500
字符串，对于用户名，我们也可以说在初始化时我们只想要一个空的

773
01:27:32,500 --> 01:27:38,940
字符串，所以我们所做的就是将一个项目列表转换为一个键值列表

774
01:27:38,940 --> 01:27:46,540
和所有这些参数都将成为用户结构体的字段，接下来让我们

775
01:27:46,540 --> 01:27:53,020
让我们看看如何创建和初始化一个结构体，所以让我添加一个代码块，现在我们来处理结构体

776
01:27:53,020 --> 01:27:58,760
这与使用地图非常相似，为了创建地图，我们过去常常使用百分号符号

777
01:27:58,760 --> 01:28:05,180
对于结构体，使用括号非常相似，只是我们必须使用结构体的名称

778
01:28:05,180 --> 01:28:11,200
所以这就是我们如何在内部定义一个结构体，让我们指定不同的字段，我们可以这样说

779
01:28:11,200 --> 01:28:19,480
用户名的值将是octalium，假设我的年龄是14岁，我的电子邮件可以是

780
01:28:20,020 --> 01:28:26,200
octobot at the rate sample.com，让我们试着评估一下，我们所做的就是

781
01:28:26,200 --> 01:28:32,420
基本上创建了一个结构体，这就是我们如何初始化一个结构体，结构体的行为非常相似

782
01:28:32,420 --> 01:28:38,820
对于我们的地图，我们可以在我们的结构体上使用相同的模式匹配技术，所以

783
01:28:38,820 --> 01:28:47,500
例如，让我们将这个分配给一个名为user one的变量，并进行下一步评估

784
01:28:47,500 --> 01:28:53,900
我们再创建一个代码块，假设我们想要提取用户名，那么我们只需要创建

785
01:28:53,900 --> 01:29:01,000
你的普通地图，在这里我们可以说字段名称是用户名，让我们创建

786
01:29:01,000 --> 01:29:08,180
一个变量名，让我们对变量user one进行模式匹配，接下来让我们看看这个值

787
01:29:08,180 --> 01:29:14,460
在用户名内部，让我们尝试评估这个块，正如你所看到的，我们得到了正确的结果

788
01:29:14,460 --> 01:29:21,180
回答是这样的，我们所做的是user one这是一个结构体，但结构体的行为非常类似于地图

789
01:29:21,180 --> 01:29:27,240
这就是为什么我们可以使用地图符号进行模式匹配，我们可以使用相同的技术

790
01:29:27,240 --> 01:29:33,780
也可以用来更新结构体内部的值，例如，如果您想更新年龄，则可以

791
01:29:34,220 --> 01:29:43,480
使用我的user one的地图，并插入这个，我想将年龄更新为21岁，让我们重新绑定

792
01:29:43,480 --> 01:29:51,440
将此值返回给user one，让我们尝试并评估，正如我们所看到的，我们得到了更新后的值

793
01:29:51,440 --> 01:29:57,780
年龄回来了，好了，到此为止，我们所做的事情到目前为止只是一个非常简短的介绍

794
01:29:57,780 --> 01:30:03,720
对Elixir中不同数据类型的简介，但如果你不自信，不要担心

795
01:30:03,720 --> 01:30:09,360
随着我们的进步和更多的实践，你会开始感到更有信心。

796
01:30:09,360 --> 01:30:15,760
到目前为止，我们已经在Elixir中看到了几种不同的数据类型，如果你还没有感觉到自信

797
01:30:15,760 --> 01:30:21,780
不要担心，在我们继续教程的过程中，我们将有更多的练习，但现在

798
01:30:21,780 --> 01:30:27,760
让我们顺其自然，我只是想在我们深入学习之前给你介绍一些主题

799
01:30:28,620 --> 01:30:36,800
下一个主题是关于Elixir内部的控制流程，用于创建循环

800
01:30:36,800 --> 01:30:42,400
我们通常会使用递归，但除了递归之外，我们还有几种不同的机制

801
01:30:42,400 --> 01:30:48,980
用于我们的控制流程，让我们先看一下第一个控制流程机制，称为case

802
01:30:48,980 --> 01:30:57,260
让我们创建一个简单的列表，我们可以说列表是一个、二、三

803
01:30:57,260 --> 01:31:04,100
现在我们可以创建一个case语句，这个case语句更像是你的switch语句，让我创建一个语句，然后我可以向你展示它是如何工作的

804
01:31:04,100 --> 01:31:09,520
现在让我创建一个语句，然后我可以向你展示它是如何工作的

805
01:31:10,140 --> 01:31:18,900
所以在这里我们可以说我们想创建一个情况，让我放置结束块，现在在这里我们可以说

806
01:31:18,900 --> 01:31:25,900
我们只是想从列表中获取第二个元素，所以记住第二个元素

807
01:31:25,900 --> 01:31:34,500
从我们的列表中将是三，所以它在索引号零一和二，所以我们可以说我们想要

808
01:31:34,500 --> 01:31:42,460
从列表中获取第二个元素，然后根据这个语句的结果

809
01:31:42,460 --> 01:31:49,200
我们可以根据几种不同的情况进行模式匹配，所以让我们在内部创建第一个情况

810
01:31:49,730 --> 01:31:57,540
所以在这里我们可以说，如果这个语句求值为一，那么我们只想要

811
01:31:57,540 --> 01:32:04,920
返回一个字符串，字符串将是这个打印下一个，我们还可以创建多个情况

812
01:32:04,920 --> 01:32:11,820
所以在我们得到答案是三的情况下，那个时候我们只想返回三是一个匹配

813
01:32:11,820 --> 01:32:18,320
接下来是一个通用情况，对于这个情况我们可以说我们想使用一个下划线

814
01:32:18,320 --> 01:32:24,420
这意味着我们对值不感兴趣，但是如果我们没有匹配此返回的情况

815
01:32:24,420 --> 01:32:31,680
在那个时候的声明中，我们只想返回一个名为catch all的字符串，现在让我们试试吧。

816
01:32:31,680 --> 01:32:38,340
评估这个，并且正如你所看到的，我们得到的答案是三是一个匹配，所以让我们试试吧。

817
01:32:38,340 --> 01:32:44,240
重申一下发生的事情，所以我们创建了一个case语句，我们只想在模式匹配上进行匹配。

818
01:32:44,780 --> 01:32:51,740
这个表达式的结果就在这里，所以这个语句的结果是三，因为

819
01:32:51,740 --> 01:32:58,560
我们得到了一个匹配，所以我们得到了返回值为三是一个匹配，我们可以使用这个case语句

820
01:32:58,560 --> 01:33:06,300
可以在几乎任何东西上进行模式匹配，例如假设我们有一个结构体，让我们创建一个

821
01:33:06,300 --> 01:33:13,760
模块，这样我们就可以说我们想为post创建一个模块，在其中我们创建一个结构体

822
01:33:13,760 --> 01:33:20,140
让我们创建不同的字段，假设我们想要一个id字段，我们想要

823
01:33:20,140 --> 01:33:26,460
将其初始化为nil，然后我们想要另一个字段用于标题，让我们将其初始化为空白

824
01:33:26,460 --> 01:33:32,740
字符串，下一个可能是用于描述的，我们可以再次将其赋值为空白字符串

825
01:33:32,740 --> 01:33:41,360
最后一个可能是给作者的，让我们将其分配为空字符串，这样我们就创建了一个结构体。

826
01:33:41,360 --> 01:33:50,980
接下来让我们创建一个帖子，这样我们就可以说我们想创建一个帖子一，并且我们想要有一个。

827
01:33:50,980 --> 01:34:00,300
假设帖子的id是一，标题可以是标题一，接下来我们想要作者。

828
01:34:00,300 --> 01:34:08,720
假设作者是朱利叶斯·凯撒，让我们尝试评估这个单元格，你一定有

829
01:34:08,720 --> 01:34:15,120
我们没有在结构体内部给出描述，但在定义时我们已经定义了

830
01:34:15,120 --> 01:34:21,520
万一我们没有描述的值，那么我们只想将其初始化为

831
01:34:21,520 --> 01:34:27,640
一个空字符串，这就是为什么我们立即得到一个空字符串，接下来我们可以使用

832
01:34:27,640 --> 01:34:34,160
我们的帖子的情况陈述，假设我们想要对作者进行模式匹配，所以我们可以说

833
01:34:34,160 --> 01:34:40,740
我们想要一个情况陈述，并且我们想要为我们的帖子编号一进行模式匹配，以及

834
01:34:40,740 --> 01:34:47,040
在这里让我们定义一些不同的场景，现在请记住，由于这是一个结构体，我们可以

835
01:34:47,040 --> 01:34:54,260
还可以使用地图符号进行模式匹配，所以我们可以假设我们有一个作者

836
01:34:54,260 --> 01:35:01,640
如果作者名字是Octalium，我们只想返回一个字符串"got a post"

837
01:35:01,640 --> 01:35:10,100
从Octalium复制并粘贴，假设作者名字是Anil Kulkarni，那么我们可以说得到

838
01:35:10,100 --> 01:35:17,740
从Anil Kulkarni发布，接下来我们还可以创建一个捕获所有情况的块，这样我们就可以使用下划线

839
01:35:17,740 --> 01:35:25,620
这次我们可以创建一个字符串，并且可以说得到一条来自于，并且我们可以使用这个字符串

840
01:35:25,620 --> 01:35:33,260
插值，所以我们可以说post one dot author，让我们尝试并评估，这次我们得到

841
01:35:33,260 --> 01:35:39,940
答案是从Julius Caesar得到一条帖子，现在只是一个小提醒，我们可以很容易地更新

842
01:35:39,940 --> 01:35:46,940
结构体就像更新一个map一样，所以如果我们想要从Julius更新作者字段

843
01:35:46,940 --> 01:35:53,680
变成我的名字，所以我们可以说我们想要更新作者变为Anil Kulkarni

844
01:35:53,680 --> 01:35:59,660
让我们尝试一下评估，这次我们有了新的作者Anil Kulkarni，现在让我

845
01:35:59,660 --> 01:36:06,280
创建一个新的代码块，让我将case语句复制粘贴到这里

846
01:36:06,280 --> 01:36:12,820
让我们尝试评估，这次我们仍然得到了答案是Julius Caesar

847
01:36:12,820 --> 01:36:19,660
那是因为我们在这里没有重新绑定，所以我们可以说我们想重新绑定变量

848
01:36:19,660 --> 01:36:27,760
将number one重新绑定到更新的值上，让我重新评估，这也让我们尝试重新评估

849
01:36:27,760 --> 01:36:33,180
这次我们得到了正确的答案，与case语句类似，我们还有另一个

850
01:36:33,180 --> 01:36:38,640
流控制机制的名称为condition，所以让我在这里创建一个新的代码块

851
01:36:38,640 --> 01:36:44,780
这是给条件的，我们可以在这里定义几个不同的条件

852
01:36:44,780 --> 01:36:50,280
现在条件语句不在这里接受表达式进行模式匹配

853
01:36:50,280 --> 01:36:55,360
相反，我们可以在这里对不同的条件进行模式匹配，所以假设第一个

854
01:36:55,360 --> 01:37:02,020
我们想要匹配的条件是帖子作者，假设您想说的是

855
01:37:02,020 --> 01:37:08,940
如果作者是Octalium，那么我们只需要返回一个字符串，上面写着

856
01:37:08,940 --> 01:37:16,800
Octalium发布的帖子，让我复制粘贴这个，这次我们来检查一下这个条件

857
01:37:16,800 --> 01:37:24,420
Anil Kulkarni，然后变成Anil
Kulkarni，接下来我们还要定义一个用于捕捉所有情况的代码块

858
01:37:24,420 --> 01:37:30,440
现在来定义捕捉所有情况的代码块的条件，我们只需对true条件进行模式匹配

859
01:37:30,440 --> 01:37:36,460
如果我们有一个true条件，那么我们只需返回一个

860
01:37:36,460 --> 01:37:43,100
字符串，上面写着这是一个捕捉所有情况的，现在让我们尝试评估这个单元格，我们会得到

861
01:37:43,100 --> 01:37:50,020
编辑来自Anil Kulkarni的帖子的答案，让我们再看一个条件块，所以

862
01:37:50,020 --> 01:37:56,760
让我在这里创建一个新的块，我们还可以使用这个条件语句进行更高级的

863
01:37:56,760 --> 01:38:05,360
模式匹配，例如，我们在这里有一个列表，假设我们想进行模式匹配

864
01:38:05,360 --> 01:38:11,460
在第一个元素上，那么这时我们可以简单地使用head函数

865
01:38:11,460 --> 01:38:19,720
所以我们可以说我们想要从我们的列表中提取头部，如果头部是一个的话

866
01:38:19,720 --> 01:38:26,560
那个时候我们想要返回一个消息，说得到了一个，让我们定义一个捕获所有的块

867
01:38:26,560 --> 01:38:34,460
所以这次我们可以使用字符串插值，我们可以说头部是，然后我们可以放入

868
01:38:34,460 --> 01:38:40,300
就在这里，让我们在列表上调用头部函数，让我们尝试评估一下

869
01:38:40,300 --> 01:38:46,740
这个块，我们得到的答案是得到了一个，所以你可以看到我们可以使用所有不同的

870
01:38:46,740 --> 01:38:53,720
条件和情况的模式匹配技术，最后的流程控制机制是 if

871
01:38:53,720 --> 01:39:00,180
和 else 块，但通常你不必使用 if 和 else 块，我们会使用

872
01:39:00,180 --> 01:39:06,280
递归或模式匹配，而不是使用 if 和 else，但让我向你展示我们如何使用

873
01:39:06,280 --> 01:39:13,560
如果需要的话，让我创建一个新的部分，这个部分是关于 if 和 else 的

874
01:39:13,560 --> 01:39:20,040
让我们创建一个新的代码块，所以 if 和 else 条件是相同的，所以我们可以

875
01:39:20,040 --> 01:39:28,300
如果条件为真，我们将打印出"this will work"，否则我们将打印出"else this
will work"。

876
01:39:28,300 --> 01:39:34,000
让我们尝试评估这个单元格，我们得到的答案是"this will work well"。就这些。

877
01:39:34,000 --> 01:39:39,520
讲解了Elixir中的各种不同的流程控制机制。到目前为止，我们已经学习了非常简短的介绍。

878
01:39:39,520 --> 01:39:45,760
对Elixir中不同的数据类型和流程控制机制进行了非常简短的介绍。

879
01:39:45,760 --> 01:39:51,520
从下一个视频开始，我们将开始使用混合项目，届时我们将更详细地学习所有这些概念。

880
01:39:51,520 --> 01:39:57,980
我认为到现在为止，我们已经学习了足够的内容，可以开始学习函数式编程的基本概念了。

881
01:39:57,980 --> 01:40:05,000
让我们继续，开始一个新项目，使用Elixir的基本概念。

882
01:40:05,000 --> 01:40:12,080
Elixir附带了一个名为Mix的工具，它是一个项目管理工具。

883
01:40:12,080 --> 01:40:18,560
让我们看看如何使用Mix创建我们的第一个项目，让我回到我的终端。

884
01:40:18,560 --> 01:40:25,640
我想进入我的文件夹"functional programming with
elixir"，现在就开始。

885
01:40:25,640 --> 01:40:32,820
我只创建了一个文件夹，用于我们的脚本，现在让我创建一个新的文件夹，让我

886
01:40:32,820 --> 01:40:42,420
</summary>

887
01:40:42,420 --> 01:40:50,760
<scene></scene>

888
01:40:51,460 --> 01:40:59,400
将其命名为代码，让我进入代码，我们可以通过mix new命令创建一个新项目，让我

889
01:40:59,400 --> 01:41:05,980
</summary>

890
01:41:05,980 --> 01:41:12,180
<scene></scene>

891
01:41:12,180 --> 01:41:18,020
将项目命名为教程，这就是我们有一个新的elixir项目，让我进入文件夹

892
01:41:18,020 --> 01:41:24,200
</summary>

893
01:41:24,820 --> 01:41:30,680
<scene></scene>

894
01:41:30,680 --> 01:41:37,340
让我在我的代码编辑器中打开它，正如你所见，默认情况下，elixir会创建一堆

895
01:41:37,340 --> 01:41:42,760
有很多图表和小动画帮助你理解递归的工作原理，但现在先

896
01:41:42,760 --> 01:41:48,100
让我们开始吧，这是我们在上个视频中创建的混合项目

897
01:41:48,100 --> 01:41:55,140
现在我不需要这些代码了，让我把它们拿出来，然后保存一下，现在让我们

898
01:41:55,140 --> 01:42:00,820
编写一个非常简单的递归程序来打印数字的位数，假设你有一个函数

899
01:42:00,820 --> 01:42:07,160
称为"up to"，如果你把3传递给它，那么我们应该打印出0到3，所以这是一个非常简单的程序

900
01:42:07,160 --> 01:42:12,460
但是我们将使用递归来实现这个程序，所以在lib目录下，我希望你创建一个

901
01:42:12,460 --> 01:42:19,540
一个名为"recursion"的新文件夹，在这个文件夹里，让我们创建一个文件，并称之为

902
01:42:19,540 --> 01:42:27,640
它的名字是print digits.dot ex，这次请记住扩展名是.dot ex，因为

903
01:42:27,640 --> 01:42:34,420
我们要编译这个文件，如果你在这里测试，我们可以看到我们有.dot ex的文件

904
01:42:34,420 --> 01:42:39,760
所以这些是脚本文件，不适用于你的生产代码，现在让我回到

905
01:42:39,760 --> 01:42:45,800
打印数字，然后让我折叠我的侧边栏，现在记住，elixir中的所有代码

906
01:42:45,800 --> 01:42:52,360
留在它的模块中，所以第一件事是我们需要为这个文件定义一个模块，所以让我们

907
01:42:52,360 --> 01:42:59,980
通过输入 deft module 创建一个模块，这个名字是 recursion dot print
digits，但是

908
01:42:59,980 --> 01:43:06,140
命名约定是这样的，首先我们通常包含我们的项目名称，所以我们把它命名为

909
01:43:06,140 --> 01:43:13,020
项目名称为 tutorials，然后让我打开我的侧边栏，所以在我们的项目 tutorials
中，我们创建了

910
01:43:13,020 --> 01:43:18,820
一个名为 recursion 的文件夹，在该递归文件夹中，我们创建了一个名为 print 的文件

911
01:43:18,820 --> 01:43:24,980
digits，现在记住，这只是一个社区约定，不是必需的，你可以命名为任何名称

912
01:43:24,980 --> 01:43:30,740
这个模块，任何你想要的名称都可以，现在考虑到这一点，让我折叠我的侧边栏，现在在

913
01:43:30,740 --> 01:43:36,660
这个模块中，让我们创建一个名为 up to 的函数，这样我们就可以使用关键字 def 来定义一个函数

914
01:43:36,660 --> 01:43:43,020
然后我们可以说 up to，现在这个函数将接受一个参数

915
01:43:43,020 --> 01:43:49,500
然后我们可以开始使用do和end块处理我们的数字，假设数字是三，我们可以简单地打印出如下内容，所以我们将输入设为三

916
01:43:49,500 --> 01:43:55,640
数字是三，然后我们想要打印从零到三的数字，这就是我们想要打印的内容，但我们需要以递归的方式来实现，你可能会想也许我们可以创建一个for循环

917
01:43:55,640 --> 01:44:01,880
然后我们想要打印从零到三的数字，这就是我们想要打印的内容，但我们需要以递归的方式来实现

918
01:44:01,880 --> 01:44:07,240
我们需要以递归的方式来实现这个，你可能会想也许我们可以创建一个for循环

919
01:44:07,240 --> 01:44:15,240
所以我们可以创建一个for循环，让i等于零，然后我们可以说i小于等于

920
01:44:15,240 --> 01:44:21,960
你的数字，然后i加加，然后我们可以简单地打印出i，所以如果你认为我们可以

921
01:44:21,960 --> 01:44:28,880
像这样做，答案是否定的，因为Elixir中的所有数据类型都是常量

922
01:44:28,880 --> 01:44:35,260
它们是不可变的，for循环内部的操作是在每次迭代中改变

923
01:44:35,260 --> 01:44:41,860
i的值是在这里改变的，所以我们不能在Elixir中使用这种类型的for循环

924
01:44:41,860 --> 01:44:48,720
那么我们可以使用什么呢？答案是使用递归，让我先删除注释

925
01:44:48,720 --> 01:44:54,100
让我先写代码，然后我会解释现在发生的情况，让我们考虑一个基本情况。

926
01:44:54,100 --> 01:45:01,000
假设数字本身是零，那么在那个时候我们不需要做任何事情。

927
01:45:01,000 --> 01:45:07,360
我们只需要返回零，所以我们在这里写零，现在记住最后一点。

928
01:45:07,360 --> 01:45:13,400
函数内部的行会自动返回，所以这是你的自动返回语句。

929
01:45:13,400 --> 01:45:18,920
最后一行不需要使用返回关键字，现在记住，Elixir是一种函数式的。

930
01:45:18,920 --> 01:45:24,900
编程语言，所以基本上我们必须为每个函数返回某种值。

931
01:45:24,900 --> 01:45:31,240
如果函数在那时创建某种副作用，默认情况下会返回一个值。

932
01:45:31,240 --> 01:45:37,300
返回一个OK，但现在让我们继续进行这个程序，让我写下一个基本情况。

933
01:45:37,300 --> 01:45:43,160
在Elixir中我们可以创建多个相同函数的副本。

934
01:45:43,400 --> 01:45:50,160
这也被称为函数重载，我们可以这样做，因为Elixir支持模式。

935
01:45:50,160 --> 01:45:55,880
匹配，所以我们在这里创建了一个名为up to的函数，我们

936
01:45:55,880 --> 01:46:01,840
在零上进行模式匹配，所以如果数字是零，我们只想返回零并且

937
01:46:01,840 --> 01:46:08,240
就这样，现在我们可以创建另一个相同函数的副本，我们可以说定义up to这个函数

938
01:46:08,240 --> 01:46:14,680
再次接受一个叫做numbers的参数，让我们看看这次我们能做什么，所以这一次

939
01:46:14,680 --> 01:46:20,840
我们想要做的是简单地打印出来，所以我们可以使用io.puts来打印出来，所以让我们

940
01:46:20,840 --> 01:46:26,640
打印出这个数字，但是我们想要做的是在每次迭代中减少这个数字

941
01:46:26,640 --> 01:46:33,720
减一，所以例如如果数字是三，那么在我们打印出三之后的下一次迭代中

942
01:46:33,720 --> 01:46:38,640
你的数字应该变成二，然后你的数字应该变成一，然后你的数字应该

943
01:46:38,640 --> 01:46:44,700
变成零，当你的数字变成零的时候，我们跳到第三行

944
01:46:44,700 --> 01:46:50,200
在那里我们只是简单地返回零，所以下一个问题是我们如何减少数字的值

945
01:46:50,200 --> 01:46:56,240
每次递归调用相同的函数，答案都是递减一个，所以

946
01:46:56,240 --> 01:47:02,740
每次迭代，我们可以调用自身，但每次我们可以做的是说出数字

947
01:47:02,740 --> 01:47:09,260
减一，所以我们假设这个数字是三，所以下一次我们调用时

948
01:47:09,260 --> 01:47:15,700
传递的是三减一，也就是我们传递的是两。现在不用担心

949
01:47:15,700 --> 01:47:22,000
如果你觉得这个逻辑有点混乱，我们会看看如何追踪这个函数以及如何创建

950
01:47:22,000 --> 01:47:27,900
递归树。所以我会用一个小图和一个小动画来解释。但首先让我们运行这个

951
01:47:27,900 --> 01:47:34,300
文件，看看它是否正常工作。所以让我保存文件，然后打开终端

952
01:47:34,300 --> 01:47:40,660
到现在为止，我们一直在使用IEX。但这次我们使用我们自己创建的项目

953
01:47:40,660 --> 01:47:47,500
的mix工具。但幸运的是，我们也可以在我们的mix项目中使用IEX，所以在这里我们可以说

954
01:47:47,500 --> 01:47:54,700
嘿，IEX，我想让你启动mix，所以我们只需要使用连字符和s标志，然后跟上mix命令</summary>

955
01:47:55,320 --> 01:48:01,100
所以背景中发生的是IEX简单地编译您的项目和所有的模块

956
01:48:01,100 --> 01:48:07,180
在我们的IEX中，所有这些模块都可以使用，让我来澄清一切，让我们调用这个函数

957
01:48:07,180 --> 01:48:14,120
但要记住，这个函数留在这个模块中，所以我们可以说

958
01:48:14,440 --> 01:48:21,220
从教程模块中，我想让你转到递归模块，从递归中我想让你

959
01:48:21,220 --> 01:48:27,320
去打印数字的模块，从这里我想使用up to函数，让我们通过

960
01:48:27,320 --> 01:48:33,120
在这里输入三，让我们看看得到的输出，这就是我们得到的结果

961
01:48:33,120 --> 01:48:39,020
输出是三、二和一，所以这个零不会打印，如果你想要，我们可以在这里打印零

962
01:48:39,020 --> 01:48:45,660
在第四行处，所以如果你想要，我们可以再次用io.puts和零替换这一行

963
01:48:45,660 --> 01:48:51,580
但我认为打印零没有意义，所以我们可以把这个去掉，或者我们也可以

964
01:48:51,580 --> 01:48:57,900
说，每当我们得到一个零，我们就简单地想要停止，并且我们可以返回一个被称为“okay”的原子

965
01:48:57,900 --> 01:49:04,660
这象征着我们的操作成功了，现在让我保存文件，既然我们已经保存了。

966
01:49:04,660 --> 01:49:11,820
文件后，我们还需要重新编译我们的项目，现在我们有两个选择，要么我们可以重新编译

967
01:49:11,820 --> 01:49:18,200
整个项目，要么我们可以只重新编译我们更改的模块，但每次

968
01:49:18,200 --> 01:49:24,280
键入如此庞大的模块名称非常麻烦，所以我们可以做的是创建一个小型的

969
01:49:24,280 --> 01:49:32,100
别名，这样我们就可以说我想为tutorials dot recursion dot print
digits创建一个别名

970
01:49:32,100 --> 01:49:38,170
让我清理一下屏幕，现在我们可以说我只想重新编译我的模块

971
01:49:38,730 --> 01:49:45,750
digits，就是这样，我们已经重新编译了那个模块，现在让我再清理一次

972
01:49:45,750 --> 01:49:52,950
这次我们再次可以使用print digits模块，并调用到现在的函数

973
01:49:52,950 --> 01:49:58,150
如果你想的话，你可以使用括号，或者你可以省略它们，所以让我传递三个

974
01:49:58,150 --> 01:50:03,730
就在这里，这次我们得到了三个两个一的输出，好的，让我们回到

975
01:50:03,730 --> 01:50:10,710
让我们看看发生了什么，这里发生的事情也被称为你的

976
01:50:10,710 --> 01:50:16,490
基本情况，让我在这里加上注释，所以你可以称之为你的基本情况

977
01:50:16,490 --> 01:50:23,070
这意味着，如果我们得到一个输入为零的情况，那么我们只是希望

978
01:50:23,070 --> 01:50:29,630
返回某种值，并且我们希望退出我们的递归函数，既然这个函数

979
01:50:29,630 --> 01:50:37,050
返回一个单一的值，我们可以使用一个更简短的语法，所以让我拿出来，让我拿出来

980
01:50:37,050 --> 01:50:43,910
写的声明，在函数定义之后，我必须在之后加上一个逗号，我必须加上一个

981
01:50:43,910 --> 01:50:50,670
冒号，让我把这里的好拿出来，然后我把它粘贴到这里，就这样

982
01:50:50,670 --> 01:50:55,490
这也是一个有效的函数定义，所以通常当我们返回一个单一的值时

983
01:50:55,490 --> 01:51:01,050
那个时候我们使用单行定义，现在不返回好了，让我回过头来

984
01:51:01,050 --> 01:51:06,670
返回零，所以发生的事情是我们有一个基本情况，每当我们得到输入的情况时

985
01:51:06,670 --> 01:51:12,550
那个时候我们只是返回零，但我们没有打印任何东西，在其他所有情况下

986
01:51:12,550 --> 01:51:19,870
在其他情况下，我们首先打印该数字，然后进行递归调用，现在让我们看看我们如何

987
01:51:20,430 --> 01:51:28,450
所以让我打开我的浏览器，这是我们的打印数字函数，所以

988
01:51:28,450 --> 01:51:35,530
打印直到零和零这是我们的基本情况，这是我们的递归函数，所以

989
01:51:35,530 --> 01:51:41,610
第四行是实际打印发生的地方，而第五行我们有

990
01:51:41,610 --> 01:51:47,970
一个对同一函数的递归调用，现在让我们看看我们如何跟踪这个函数，想象一下

991
01:51:47,970 --> 01:51:53,630
我们传递给这个函数的第一个参数是三，所以对于每次迭代，是什么

992
01:51:53,630 --> 01:51:59,130
会发生什么，elixir将从上到下比较三和零是否相等

993
01:51:59,130 --> 01:52:05,010
不，他们不相等，所以elixir将跳到这个函数定义，让我们看看发生了什么

994
01:52:05,010 --> 01:52:10,630
对于这个函数定义要发生的第一件事是我们只是告诉elixir打印出来

995
01:52:10,630 --> 01:52:16,130
数值的价值，所以接下来会发生什么，第一个调用是打印，我们得到的是

996
01:52:16,910 --> 01:52:22,830
接下来会发生什么，接下来是对同一函数的递归调用，但是传入的值是

997
01:52:22,830 --> 01:52:28,570
减去一，那么我们来看接下来会发生什么，接下来我们调用了同一函数

998
01:52:28,570 --> 01:52:35,090
但是值变为了两，现在两是否等于零，不等于零，所以再次 elixir

999
01:52:35,090 --> 01:52:46,110
会跳转到这个函数定义，再次发生了什么，第一行我们只是想要

1000
01:52:46,810 --> 01:52:53,550
我们自己返回，但是这次再次减去一，所以下一次调用变成了上一个

1001
01:52:53,550 --> 01:53:00,370
参数变成了一，同样的事情发生，一是否等于零，不等于零，所以再次 elixir

1002
01:53:00,370 --> 01:53:06,270
会跳转到这个函数定义，第一行是打印出数值，所以我们得到的是

1003
01:53:06,270 --> 01:53:12,810
一个回来，现在这里再次发生了什么，我们必须再次调用自己，所以我们再次调用同一个

1004
01:53:12,810 --> 01:53:19,770
函数，但是这次参数变成了零，记住一个减零，那就是我们得到的是

1005
01:53:19,770 --> 01:53:27,150
现在参数是零，再次跳到第一个子句，记住 Elixir 会从上到下扫描你的代码

1006
01:53:27,150 --> 01:53:34,650
从上到下扫描代码，第一个定义是使用零进行模式匹配，这次

1007
01:53:34,650 --> 01:53:40,810
正在发生的是我们有一个匹配，因为 up to 得到一个零参数，我们只想返回

1008
01:53:40,810 --> 01:53:47,150
零，所以这里会发生什么？所以对于这个函数，我们只会返回

1009
01:53:47,150 --> 01:53:53,650
零，就这样了，还有其他的调用吗？没有了，所以我们只是退出，就这样

1010
01:53:53,650 --> 01:53:59,150
我们在控制台中显示了从三到一，所以让我再次打开终端

1011
01:53:59,150 --> 01:54:06,210
在这里，我们得到了完全相同的输出，三、二和一，所以我们在这里做的就是

1012
01:54:06,210 --> 01:54:12,830
我们看到了如何跟踪递归程序，所以请记住绘制这种类型的树形结构

1013
01:54:12,830 --> 01:54:17,870
这将帮助你更好地理解递归编程，现在让我们继续

1014
01:54:17,870 --> 01:54:24,930
回到代码，这次让我做一个非常小的改变，现在不再打印数字

1015
01:54:24,930 --> 01:54:31,350
首先，如果我先打印数字，然后再看看会发生什么，这一次让我打开终端

1016
01:54:31,350 --> 01:54:38,650
再次打开我的终端，让我们重新编译我们的模块，因为我们改变了代码，然后让我

1017
01:54:38,650 --> 01:54:45,510
清除它，然后让我再次调用打印数字函数，让我们传入三，这一次

1018
01:54:45,510 --> 01:54:52,230
发生了什么，所以不是得到三、二和一的输出，我们得到了一、二和三的输出

1019
01:54:52,230 --> 01:54:59,030
以及三，所以发生了什么？我们只是在这里改变了一行代码，然后我们的整个输出都变了

1020
01:54:59,030 --> 01:55:05,990
逆转了，所以让我们回过头来，尝试追踪一下这个递归程序，这是之前的

1021
01:55:05,990 --> 01:55:13,230
一个，而这将是新的，所以记住我们之后有一个打印语句，但是

1022
01:55:13,230 --> 01:55:18,650
首先，我们递归调用函数，所以让我们看看这一次会发生什么

1023
01:55:18,650 --> 01:55:24,710
所以再次假设我们传入的参数是三，那么会发生什么呢？三等于零吗？

1024
01:55:24,710 --> 01:55:30,550
不是的，三不等于零，然后Elixir将跳到这个函数定义，现在发生了什么？</summary>

1025
01:55:30,550 --> 01:55:36,970
在这个定义中，首先我们调用了自己，所以会发生什么呢？我们有一个递归调用。

1026
01:55:36,970 --> 01:55:43,590
然后参数变为三减一，这意味着我们有一个名为两的参数，但是什么会发生呢？

1027
01:55:43,590 --> 01:55:51,050
在第五行发生了什么呢？这个语句没有执行，因为首先

1028
01:55:51,050 --> 01:55:56,730
我们必须用完这个函数，所以下一步会发生什么呢？让我们看一下

1029
01:55:56,730 --> 01:56:02,470
在这里，这个调用不会执行，而是首先我们必须用完

1030
01:56:02,470 --> 01:56:09,130
这个函数的所有参数，现在发生了什么呢？参数是两，两等于零吗？

1031
01:56:09,130 --> 01:56:15,110
不，不是，所以我们要进入这个函数定义，那么这一次会发生什么呢？

1032
01:56:15,110 --> 01:56:21,930
有一个递归调用，那么让我们再次调用自己，但这一次参数变为一

1033
01:56:21,930 --> 01:56:27,750
打印语句会发生什么呢？没有执行，它被保留在这里，现在让我们

1034
01:56:27,750 --> 01:56:33,370
回到这个函数，这里是一等于零吗？不是，所以我们进入这个函数

1035
01:56:33,370 --> 01:56:40,330
再次发生的是我们需要回调自己，所以让我们回调自己，但是这次

1036
01:56:40,330 --> 01:56:46,550
参数变成了零，那么打印语句又会发生什么呢，现在这个还是挂起的

1037
01:56:46,550 --> 01:56:53,430
这次会发生什么呢，我们在调用自己，但是参数是零，所以我们有一个

1038
01:56:53,430 --> 01:56:59,930
模式匹配就在这里，每当参数是零时，我们只是返回零，然后

1039
01:56:59,930 --> 01:57:10,070
这就是发生在这里的事情，所以这个调用导致了零，现在

1040
01:57:10,070 --> 01:57:16,090
在之前的函数中，这个打印语句还在等待中，但是number的值是多少呢

1041
01:57:16,090 --> 01:57:22,830
所以number的值是一，这就是为什么我们首先得到了一个的输出，现在我们再次耗尽了

1042
01:57:22,830 --> 01:57:29,350
这个子句，控制权会再次返回到这里，还有什么是等待中的呢，那就是这个打印语句还在等待中

1043
01:57:29,350 --> 01:57:35,770
但是number的值是多少呢，number的值是二，这就是为什么我们得到的输出是二

1044
01:57:35,770 --> 01:57:42,330
现在再次耗尽了这个函数，所以控制权再次返回到这个函数的这里

1045
01:57:42,330 --> 01:57:48,530
打印语句还在等待中，但是数字的值是三，这就是为什么。

1046
01:57:48,530 --> 01:57:54,470
我们得到了三的值，这正是发生在这里的情况，所以我们得到了值。

1047
01:57:54,470 --> 01:58:01,090
一、二和三，所以这里发生的是我们可以说我们的打印语句正在执行。

1048
01:58:01,090 --> 01:58:08,590
在返回阶段，但在之前的例子中，我们的打印语句是在升序执行的。

1049
01:58:08,590 --> 01:58:15,010
所以我们在执行递归函数时有一个基本的区别，让我们

1050
01:58:15,010 --> 01:58:20,910
尝试总结一下我们到目前为止学到的东西，我们所做的是创建了一个简单的

1051
01:58:20,910 --> 01:58:26,570
用于打印出数字的程序，但我们已经在递归函数中实现了逻辑

1052
01:58:26,570 --> 01:58:32,450
现在唯一的区别就在这里，第一次递归调用是在这里

1053
01:58:32,450 --> 01:58:38,370
在这个函数内部的最后一行，现在记住最后一行会自动返回，我们不需要

1054
01:58:38,370 --> 01:58:44,650
必须使用返回关键字，这为我们创建了一个循环，现在我们何时退出</summary>

1055
01:58:44,650 --> 01:58:51,710
我们在有基本情况时退出，而基本情况是在我们获得一个时，就会发生这种情况。

1056
01:58:52,330 --> 01:58:58,590
我们只是想要在获得时返回零，这是我们从递归函数中退出的时候。

1057
01:58:58,590 --> 01:59:04,290
因此，我们有两种不同的函数定义，第一个定义是针对我们的基本情况的。

1058
01:59:04,290 --> 01:59:10,490
第二个定义是针对我们的递归情况的，现在我们在第二次做的是简单地改变了。

1059
01:59:10,490 --> 01:59:16,550
我们的递归调用，所以在第二种情况下，首先我们有一个递归调用，然后我们有打印。

1060
01:59:16,550 --> 01:59:23,290
这一次发生了什么，执行从上升阶段转移到返回阶段。

1061
01:59:23,290 --> 01:59:29,570
因此，如果我必须在这里进一步总结发生的事情，打印是在上升阶段完成的。

1062
01:59:29,570 --> 01:59:35,470
而在第二种情况下，打印是在返回阶段完成的，这意味着工作或者

1063
01:59:35,470 --> 01:59:41,430
执行发生在返回而不是上升阶段，因此这种函数

1064
01:59:41,430 --> 01:59:48,070
也被称为尾递归，现在请记住，在尾递归中，我们调用相同的函数。

1065
01:59:48,070 --> 01:59:55,090
每次返回，但参数不同，在第二种情况下，这种递归被称为

1066
01:59:55,090 --> 02:00:00,530
头递归，因为首先我们有递归调用，然后有某种执行

1067
02:00:00,530 --> 02:00:07,450
现在你可以看到，我们可以通过使用递归在elixir中创建高效的循环

1068
02:00:07,450 --> 02:00:13,150
通过改变值来避免所有的副作用，就是这样了，希望你喜欢

1069
02:00:13,150 --> 02:00:18,310
喜欢递归讲座，下次再见，到目前为止我们看到了如何

1070
02:00:18,310 --> 02:00:25,430
通过使用递归打印数字，我们看到了两种方法，即尾递归和头递归

1071
02:00:25,430 --> 02:00:31,470
现在让我们通过递归进行更多练习，这次不仅打印数字

1072
02:00:31,470 --> 02:00:38,390
让我们将所有数字相加，例如，让我们创建一个名为up two的函数

1073
02:00:38,390 --> 02:00:44,830
如果你在那时传递了三个参数，我们希望得到所有数字的总和

1074
02:00:44,830 --> 02:00:52,330
所以这个函数应该返回三加上二等于五，五加上一等于六，所以这个函数

1075
02:00:52,330 --> 02:00:59,090
应该返回6，那么让我们继续并创建这个文件，所以在内部

1076
02:00:59,090 --> 02:01:07,750
递归目录下，让我创建一个新文件，然后命名为sum of digits.dot ex

1077
02:01:07,750 --> 02:01:14,610
首先，我们要定义一个模块，根据社区约定，让我们写

1078
02:01:15,350 --> 02:01:21,210
首先是应用程序名称，应用程序名称是tutorials，然后是文件夹recursion和

1079
02:01:21,210 --> 02:01:28,350
然后文件名是sum of our digits，让我关闭我的侧边栏，在这里先写

1080
02:01:28,350 --> 02:01:35,590
非常简单的递归函数，然后我们将尝试和重启函数，所以让我们调用一个函数

1081
02:01:35,590 --> 02:01:42,590
根据up to的名称，让我们传递数字的参数，让我们看看我们能做什么

1082
02:01:42,590 --> 02:01:48,350
这次我们可以使用一个非常简单的递归函数，我们可以说对于每一个

1083
02:01:48,350 --> 02:01:55,250
迭代i只是想要添加数字，下一次我想调用相同的函数up

1084
02:01:55,250 --> 02:02:02,830
但是每次我的参数应该是数字减一，但是这个函数永远不会结束，因为

1085
02:02:02,830 --> 02:02:08,810
我们没有基本条件，数字会不断变为负值，所以我们还需要

1086
02:02:08,810 --> 02:02:15,510
定义一个基本条件，所以让我们在顶部创建基本条件，让我创建一个新的

1087
02:02:15,510 --> 02:02:22,730
通过名称为up to的函数，这次让我们在零上进行模式匹配，假设数字为零

1088
02:02:22,730 --> 02:02:28,750
那么这时候我只想返回零，请记住，如果我们只有一行

1089
02:02:28,750 --> 02:02:34,410
返回语句，我们可以将其写在同一行，如果我们有一个普通函数

1090
02:02:34,410 --> 02:02:41,130
那么最后一行会自动返回，我们不需要使用return关键字，所以

1091
02:02:41,130 --> 02:02:47,450
先保存文件，然后运行文件，然后我们将尝试追踪递归函数

1092
02:02:47,450 --> 02:02:56,590
那么让我打开终端，让我们进入ix，这样我可以输入ix.s，这代表

1093
02:02:56,590 --> 02:03:04,130
开始，我想让ix启动我的mix，让我清除所有这些东西，让我们创建一个别名，这样我们就可以

1094
02:03:04,130 --> 02:03:12,190
可以说我想为tutorials.recursion.一些数字创建一个别名，让我清理一下

1095
02:03:12,810 --> 02:03:19,570
现在我们可以从一些数字的模型中保存，我想使用最多的函数，让我来使用

1096
02:03:19,570 --> 02:03:26,670
传递参数三，所以我们得到的答案是六，所以发生了什么，三加二

1097
02:03:26,670 --> 02:03:33,570
加一等于六，现在让我们看看我们如何追踪这个递归函数，所以这是我们的

1098
02:03:33,570 --> 02:03:39,790
一些数字的程序，这是我们在第一行写的函数，我们有基础

1099
02:03:39,790 --> 02:03:45,670
在线号码三，我们有递归的情况，现在让我们看看会发生什么

1100
02:03:45,670 --> 02:03:50,730
拿相同的例子，让我们将三传递给这个函数，现在三等于零吗

1101
02:03:50,730 --> 02:03:57,110
不是的，三不等于零，所以魔药会进入下一个函数，这里会发生什么

1102
02:03:57,110 --> 02:04:03,570
在这里，我们说我们想要添加这个数字，在添加数字之后，我们只想要调用

1103
02:04:03,570 --> 02:04:09,810
递归调用函数，所以会发生的是我们得到三加，然后再次调用

1104
02:04:09,810 --> 02:04:16,710
返回相同的函数，但是这次参数是数字减一，所以下次我们会这样做

1105
02:04:16,710 --> 02:04:22,230
现在我们用参数为2来调用相同的函数，接下来会发生什么呢？

1106
02:04:22,230 --> 02:04:28,350
2等于0吗？不是的，所以elixir会进入下一个函数，然后又发生了同样的事情。

1107
02:04:28,350 --> 02:04:35,250
数字加上递归调用，那么会发生什么呢？这将计算2，我们得到的结果是

1108
02:04:35,250 --> 02:04:41,070
数字，这种情况下的数字是2，所以是2加上，然后我们再次返回递归调用

1109
02:04:41,070 --> 02:04:47,810
函数，但这次的参数是2减去1，所以参数变成了1

1110
02:04:47,810 --> 02:04:53,570
再次回到同样的函数，1等于0吗？不是的，然后我们进入下一个

1111
02:04:54,010 --> 02:05:00,450
现在这里又重复了同样的事情，所以这次又是数字加上，也就是1加上

1112
02:05:00,450 --> 02:05:06,850
然后让我们再次调用相同的函数，但这次参数变为0，所以接下来会发生什么呢？

1113
02:05:06,850 --> 02:05:12,450
这次会发生什么呢？这次我们有一个基本条件，就在这里

1114
02:05:12,450 --> 02:05:18,770
我们说的是，每当参数为零时，我们只想返回零

1115
02:05:18,770 --> 02:05:24,950
所以这个函数就在这里简单地返回一个零，现在发生了什么呢

1116
02:05:24,950 --> 02:05:31,690
已经用完了这个调用，现在控制权必须返回到之前的函数，那么发生了什么呢

1117
02:05:31,690 --> 02:05:38,470
接下来会发生什么呢，这整个表达式中的一个加上这个函数将被评估为一加

1118
02:05:38,470 --> 02:05:45,590
零等于一，所以这整个表达式的值是一，现在控制权将回到

1119
02:05:45,590 --> 02:05:50,970
此函数，但这次发生了什么呢，所以这整个函数调用

1120
02:05:50,970 --> 02:05:57,330
评估为一，所以这里会发生什么呢，这整个表达式将会

1121
02:05:57,330 --> 02:06:02,890
评估为二加一等于三，现在控制权再次回到之前的

1122
02:06:02,890 --> 02:06:09,670
函数调用，所以这次发生了什么呢，up to和two的函数调用已经被评估为

1123
02:06:10,550 --> 02:06:17,590
所以这整个表达式被评估为三加三，这意味着我们得到了六

1124
02:06:17,590 --> 02:06:23,550
这就是从我们的函数返回的结果，你现在可以看到，如果你

1125
02:06:23,550 --> 02:06:28,750
看看这个函数，这个函数既不是头递归，也不是尾递归。

1126
02:06:28,750 --> 02:06:35,010
递归函数，但我们能将这个函数转换为尾递归吗？

1127
02:06:35,790 --> 02:06:41,750
是的，我们可以，让我来展示一下如何将这个函数从普通函数转换为尾递归。

1128
02:06:41,750 --> 02:06:47,550
递归函数，所以让我们在这里创建一个新函数，我们可以说这次的函数是

1129
02:06:47,550 --> 02:06:54,050
上一个函数将是尾递归的，现在先让我写出函数的定义，然后

1130
02:06:54,050 --> 02:06:59,410
我将解释发生了什么，所以这个函数将接受两个不同的参数

1131
02:06:59,410 --> 02:07:06,310
第一个参数是原样的数字，我还想接受一个额外的参数

1132
02:07:06,310 --> 02:07:13,070
称为累加器，简称为acc，接下来让我们考虑一下我们的基本条件

1133
02:07:13,070 --> 02:07:19,170
所以正如我们刚才在这里看到的，我们有一个基本条件，当数字为零时，让我们尝试一下

1134
02:07:19,170 --> 02:07:25,530
并在这里复制相同的逻辑，所以如果我说我的数字本身为零

1135
02:07:25,530 --> 02:07:32,850
那个时候，我只是想把我的累加器还回去，所以我可以说做累加器，这就是我们的

1136
02:07:32,850 --> 02:07:39,290
基本条件，现在让我们看看如何定义我们的递归条件，所以让我复制粘贴

1137
02:07:39,290 --> 02:07:44,690
就在这里，这次我们想要得到一个数字，让我们使用返回语句

1138
02:07:44,690 --> 02:07:50,810
在不同的行上，让我把它拿出来，现在让我们看看我们可以使用什么作为我们的递归调用

1139
02:07:50,810 --> 02:07:55,930
现在再请让我重复一遍，首先让我写代码，然后当我们看到如何时

1140
02:07:55,930 --> 02:08:01,230
追踪递归算法的逻辑将变得清晰，但现在我想要的是

1141
02:08:01,230 --> 02:08:08,490
要做的就是简单地再次调用相同的函数，但对于每次迭代，我想说的是

1142
02:08:08,490 --> 02:08:15,750
我的数字必须减一，而对于每次迭代，我只想要添加我的累加器

1143
02:08:15,750 --> 02:08:21,490
与数字一起，就是这样，我们完成了，让我保存文件，让我打开终端

1144
02:08:21,490 --> 02:08:28,950
现在我可以重新编译一些数字的模块，现在让我清理屏幕，我们可以说

1145
02:08:28,950 --> 02:08:35,510
我们想要使用尾递归版本，并让我把三传给这个函数，哦，出错了。

1146
02:08:35,510 --> 02:08:41,870
那是因为我们还需要传递累加器，所以这个尾递归函数需要两个参数。

1147
02:08:41,870 --> 02:08:48,870
我只传递了一个参数，这就是为什么出错的原因，所以让我搞清楚这个问题，然后我们就可以

1148
02:08:48,870 --> 02:08:56,550
说累加器必须为零，这次我们得到的答案是六，现在我们可以

1149
02:08:56,550 --> 02:09:02,410
每次稍微改进我们的程序，而不是传递一个累加器，我可以做的是

1150
02:09:02,410 --> 02:09:09,710
简单地设置默认值，让我们回到代码编辑器，让我复制粘贴这个

1151
02:09:09,710 --> 02:09:15,870
所以我们要做的是创建一个函数定义，因为我们

1152
02:09:15,870 --> 02:09:21,030
只是创建函数定义或者可以说函数头，我们不需要

1153
02:09:21,030 --> 02:09:27,330
指定返回语句，所以这个要去掉，我们可以说默认值为

1154
02:09:27,330 --> 02:09:34,230
累加器是零，所以如果没有指定累加器，那么累加器将会

1155
02:09:34,230 --> 02:09:40,110
将其设置为零，而不是零，我们可以说第一个参数可以是任意数字

1156
02:09:40,110 --> 02:09:45,730
所以我们在这里所做的就是简单地创建了一个公共函数，这样我们的代码

1157
02:09:45,730 --> 02:09:52,030
编辑器帮助我们，它只是一个具有给定名称和体的公共函数，所以通常这些

1158
02:09:52,030 --> 02:09:57,610
这些东西在帮助您编写代码文档方面非常有用，我们首先需要重新编译

1159
02:09:57,610 --> 02:10:03,750
让我们清除屏幕上的一些数字模块，然后让我们尝试调用相同的函数

1160
02:10:03,750 --> 02:10:09,350
但是这次由于累加器有一个默认参数，所以我可以简单地忽略它

1161
02:10:09,350 --> 02:10:16,230
在我们继续并跟踪这个递归函数之前，我们再次得到与之前的六相同的答案

1162
02:10:16,230 --> 02:10:22,330
我们现在可以做一件小事，这个函数稍微有点昂贵，因为它需要

1163
02:10:22,330 --> 02:10:28,410
稍微多一点内存，所以我们在这里可以简单地调用尾递归函数

1164
02:10:28,410 --> 02:10:35,110
并传入数字参数，就是这样，所以现在让我们打开终端，让我们再次

1165
02:10:35,110 --> 02:10:42,870
重新编译，让我澄清一切。这一次，如果我做数字点升两倍，如果我...

1166
02:10:42,870 --> 02:10:48,270
将参数传递为三，那么在幕后发生了什么？我们仍然在调用尾递归

1167
02:10:48,270 --> 02:10:53,730
函数，我们得到的答案与六相同，现在让我们继续前进

1168
02:10:53,730 --> 02:11:01,210
看看我们如何追踪尾递归函数，所以这是最后一个函数，现在我们要追踪

1169
02:11:01,210 --> 02:11:07,270
尾递归函数在第二行，我们只有函数定义，所以这个函数

1170
02:11:07,270 --> 02:11:13,270
接受一个数字，累加器的默认值设为零，第三行

1171
02:11:13,270 --> 02:11:18,870
有基础条件，我们说当我们得到的数字为零时

1172
02:11:18,870 --> 02:11:24,970
我们只想返回累加器，接下来是我们的递归调用，现在让我们传递

1173
02:11:24,970 --> 02:11:30,850
参数为三传递给这个函数，让我们尝试追踪这个递归函数，所以我们有

1174
02:11:30,850 --> 02:11:37,990
这样的初始调用，数字的值为三，累加器默认为零

1175
02:11:37,990 --> 02:11:44,410
现在让我们看看现在发生了什么，三等于零吗？不等于零，所以魔药会...

1176
02:11:44,410 --> 02:11:49,810
这里的函数右边，现在发生了什么，我们正在调用同一个函数...

1177
02:11:49,810 --> 02:11:56,130
好的，所以我们需要做的是需要调用同一个函数回来，但是参数会发生什么...

1178
02:11:56,130 --> 02:12:02,610
所以第一个参数是我们只是想将数字减一，所以在这个条件下...

1179
02:12:02,610 --> 02:12:08,010
发生了什么，数字是三，好的，我们在这里得到了三，而且对于每个调用，我们只是...

1180
02:12:08,010 --> 02:12:13,590
想从中减去一个，所以这里的答案是二，而下一个参数在这里...

1181
02:12:13,590 --> 02:12:20,630
所以我们只是想将累加器与数字相加，所以让我们在这里继续，那么是什么...

1182
02:12:20,630 --> 02:12:26,710
累加器，正如你所看到的，最初累加器是零，所以我们得到了一个零，在这里...

1183
02:12:26,710 --> 02:12:32,350
在这里，数字是三，所以零加三我们得到了一个三，在这里...

1184
02:12:32,350 --> 02:12:37,750
所以整个函数看起来会像这样，新的数字是二，和新的...

1185
02:12:38,210 --> 02:12:44,550
是三现在让我们看看会发生什么，两个等于零吗？不，不是，所以我们继续

1186
02:12:44,550 --> 02:12:50,410
在这个函数内部，我们再次需要递归调用相同的函数，所以让我们看看会发生什么

1187
02:12:50,410 --> 02:12:56,570
所以再次调用相同的函数，但这次会发生什么？数字是负一

1188
02:12:56,570 --> 02:13:03,510
所以这个两减去一个，那么余数是什么？是一，下一个是累加器

1189
02:13:03,510 --> 02:13:09,670
加上这个数字，那么在这种情况下累加器是什么？累加器是三，它来自

1190
02:13:09,670 --> 02:13:15,250
就在这里，数字是什么？数字是二，所以二就在这里，所以我们有三加二

1191
02:13:15,250 --> 02:13:22,110
等于五，所以这个函数被计算到这里，直到数字变成一，还有

1192
02:13:22,110 --> 02:13:28,170
累加器变成五，现在我们必须再次调用自己，现在是一

1193
02:13:29,030 --> 02:13:34,770
不，所以我们进入下一个条件，再次调用自己，那么接下来会发生什么

1194
02:13:34,770 --> 02:13:40,970
这次数字是一，减去一，所以这就是为什么我们得到了一个零在这里

1195
02:13:40,970 --> 02:13:47,050
下一个仍然是同样的累加器加上数字，那么累加器是什么

1196
02:13:47,050 --> 02:13:58,150
累加器是五，所以我们在这里得到了五，数字是一，所以我们得到

1197
02:13:58,150 --> 02:14:05,470
计算出来的结果是从这里到零和六，所以这次数字变成了

1198
02:14:05,470 --> 02:14:11,870
零，所以会发生什么呢，它会走到这里，所以数字是零，是的

1199
02:14:11,870 --> 02:14:18,210
数字是零，那我们应该怎么办，我们只需返回累加器，这就是将要发生的

1200
02:14:18,210 --> 02:14:23,850
就在这里发生，我们只需返回累加器，那么累加器是什么

1201
02:14:23,850 --> 02:14:29,890
累加器是六，这就是我们写的，所以现在还有什么吗，没有，没有

1202
02:14:29,890 --> 02:14:36,970
剩下的就是这样了，我们得到的答案是六，所以正如你所见，这些尾递归函数

1203
02:14:36,970 --> 02:14:43,610
非常特殊，第一个原因是它们需要更少的内存，为什么它们需要更少的内存

1204
02:14:43,610 --> 02:14:48,910
这是因为它们在递归地再次调用自己，现在如果你来自于

1205
02:14:48,910 --> 02:14:54,730
其他编译语言，比如Java或者可能是Python，你一定在想，对于每个调用，我们必须分配不同的堆栈内存，但事实并非如此，在Elixir中不会发生这种情况。

1206
02:14:54,730 --> 02:15:01,870
这些调用，我们必须分配不同的堆栈内存，但在Elixir中并不会发生这种情况。

1207
02:15:01,870 --> 02:15:07,590
Elixir是一种函数式编程语言，这些函数调用进行了高度优化，那么问题是什么呢？

1208
02:15:07,590 --> 02:15:13,710
正在发生的是我们只是重用相同的堆栈，因此没有额外的内存分配。

1209
02:15:13,710 --> 02:15:18,910
所以，无论何时可能，请尽量使用尾递归函数，因为它们的内存占用更少。

1210
02:15:18,910 --> 02:15:24,890
从速度上来说更高效，可能更多也可能更少，你不知道，但从内存方面来说，它们要求的内存少得多。

1211
02:15:24,890 --> 02:15:29,910
肯定要求较少的内存，好了，这就是本视频的内容了，我会继续下一个，我们在最后一个视频中练习了一些递归，计算了不同数字的和，但是对于本视频，我想计算一个数字的阶乘，先让我把它改回旧代码。

1212
02:15:29,910 --> 02:15:36,410
下一个视频见，我们在下一个视频中继续练习递归，在上一个视频中，我们编写了一个简单的递归程序来计算不同数字的和，但是在本视频中，我想计算一个数字的阶乘。

1213
02:15:36,410 --> 02:15:42,250
非常简单的递归程序，用于计算不同数字的和，但是在本视频中，

1214
02:15:42,250 --> 02:15:49,210
我想计算一个数字的阶乘，首先让我把它改回旧代码。

1215
02:15:49,210 --> 02:15:58,670
旧代码是数字加上的总和，然后我们只需要调用减去一个的数字，所以这样

1216
02:15:58,670 --> 02:16:04,550
时间，我想要做的是编写一个计算阶乘的程序，例如

1217
02:16:04,550 --> 02:16:13,410
比如三，那么阶乘就会是这样的，三乘以二乘以一，输出就是

1218
02:16:13,410 --> 02:16:19,970
六，所以我想要暂停一下视频，然后你自己试一试，我希望你能做到

1219
02:16:19,970 --> 02:16:26,850
如果不行，我们一起来做，首先让我创建一个新文件，让我把它叫做

1220
02:16:26,850 --> 02:16:34,770
阶乘.dot.ex，首先让我们创建模块，让我们得到模块的名称，这一点很重要

1221
02:16:34,770 --> 02:16:41,270
是tutorials.dot.recursion.dot.factorial，这里让我创建一个名为的函数

1222
02:16:41,270 --> 02:16:47,970
off，这样我们就可以简单地调用阶乘.off，所以第一个条件是，如果我得到一个

1223
02:16:47,970 --> 02:16:55,330
在那个时候，我只是想要返回一个，接下来让我们写递归情况，所以如果我们得到了

1224
02:16:55,330 --> 02:17:01,670
其他数字，我们可以说数字，这次让我来展示一下你如何计算，通过

1225
02:17:01,670 --> 02:17:07,410
使用一个普通的递归程序，然后我还会教你如何编写这个程序

1226
02:17:07,410 --> 02:17:13,890
使用尾递归，但现在让我们顺其自然，所以在这里我们可以说每次迭代

1227
02:17:13,890 --> 02:17:20,870
我们想要乘以一个数字，每次调用自己，但每次

1228
02:17:20,870 --> 02:17:28,450
要将数字减一，所以这是一个非常简单的递归案例，让我们打开我们的

1229
02:17:28,450 --> 02:17:36,570
终端让我清理一切，让我们使用我们的 ix，让我调整一下我的终端，在这里

1230
02:17:36,570 --> 02:17:44,930
可以创建一个别名，所以我们可以说tutorials dot recursion dot
factorial，让我们调用我们的函数

1231
02:17:44,930 --> 02:17:52,730
我们可以说阶乘的结果是，让我们传入三，所以答案是六，让我们试试四

1232
02:17:52,730 --> 02:17:58,950
所以我们得到24的答案，现在让我们尝试跟踪这个递归程序，看看发生了什么

1233
02:17:58,950 --> 02:18:05,850
所以这是我们写的第一个递归程序，所以这里有一个基本条件

1234
02:18:05,850 --> 02:18:12,410
如果我们得到一个，我们只想返回一个，否则我们想调用这个函数

1235
02:18:12,410 --> 02:18:19,250
让我们尝试追踪发生的情况，假设我们使用参数三调用这个函数

1236
02:18:19,250 --> 02:18:25,950
那么在那个时候会发生什么呢？三等于一吗？不，所以elixir会进入这个函数

1237
02:18:25,950 --> 02:18:32,850
接下来会发生什么？我们需要将数字相乘，并再次调用函数本身

1238
02:18:32,850 --> 02:18:39,030
这里我们要将三相乘，并再次调用相同的函数

1239
02:18:39,030 --> 02:18:45,410
但是由于我们将数字减一，所以这次参数变为了二，现在再次是

1240
02:18:45,410 --> 02:18:51,090
二等于一吗？不，所以我们将再次跳转到这个函数，同样的事情会发生

1241
02:18:51,090 --> 02:18:56,790
首先需要将数字相乘，并再次调用相同的函数，所以这次再次

1242
02:18:56,790 --> 02:19:04,890
我们有两个，这次两个将与相同的函数相乘，新的参数是一，所以在

1243
02:19:04,890 --> 02:19:11,930
下一次迭代中，我们在基本情况下找到了匹配，所以既然我们找到了匹配，我们只需要返回

1244
02:19:11,930 --> 02:19:19,650
一，所以这个函数将被计算为一个简单的一，现在控制权将返回到这里

1245
02:19:19,650 --> 02:19:26,170
在这里的语句是两乘以这个函数，所以这将被计算为二

1246
02:19:26,170 --> 02:19:33,250
这句话就在这里，所以整个表达式将被计算为二，现在

1247
02:19:33,250 --> 02:19:39,410
控制流将再次回到这里，所以这个将被计算为类似这样的

1248
02:19:39,410 --> 02:19:44,990
三乘以二，我们有六，现在顶部没有任何东西了

1249
02:19:44,990 --> 02:19:51,450
同样这个函数，这就是为什么我们得到六作为返回值，这是三的阶乘

1250
02:19:51,450 --> 02:19:57,450
回到我们的程序，这是一个非常简单的递归方式来创建阶乘

1251
02:19:57,450 --> 02:20:03,710
接下来你能否用尾递归方式写出相同的程序，所以如果你可以就给出

1252
02:20:03,710 --> 02:20:08,570
暂停一下，自己尝试一下，否则我会告诉你我们如何编写相同的程序

1253
02:20:08,570 --> 02:20:14,450
使用尾递归，让我在这里创建一个新函数，我可以说是的但是

1254
02:20:14,450 --> 02:20:19,910
这次它将使用尾递归，这个函数将接受两个参数

1255
02:20:19,910 --> 02:20:25,850
所以第一个数字将是数字，对于尾递归函数，让我们首先创建

1256
02:20:25,850 --> 02:20:32,550
在这里，我们可以在数字上进行模式匹配，所以我们可以说如果数字是一的情况下

1257
02:20:32,550 --> 02:20:39,170
第二个参数是我们的累加器，所以这次我只是想返回我的

1258
02:20:39,170 --> 02:20:43,910
累加器，所以不用担心如果你不懂，我们也会追踪这个程序

1259
02:20:43,910 --> 02:20:51,350
接下来是我们的递归情况，所以我们可以说我们的尾递归版本，所以第一个参数

1260
02:20:51,350 --> 02:20:56,870
是我们的数字，第二个参数是我们的累加器，所以在这里我可以说对于每一个

1261
02:20:56,870 --> 02:21:04,150
迭代，我只想再次调用同一个函数，所以尾递归，但是对于每次迭代

1262
02:21:04,150 --> 02:21:12,530
我只想让我的数字减一，并且对于每次迭代，我还想乘以我的

1263
02:21:12,530 --> 02:21:18,810
累加器和我的数字，接下来我们还可以对这个程序进行一点改进

1264
02:21:18,810 --> 02:21:23,830
我们还可以为累加器设置一个默认值，所以让我们继续吧

1265
02:21:23,830 --> 02:21:28,690
在顶部创建函数定义，记住函数定义总是在顶部

1266
02:21:28,690 --> 02:21:35,850
在顶部定义我们的尾递归函数，第一个

1267
02:21:35,850 --> 02:21:41,550
参数总是成为数字，第二个参数是累加器，对于

1268
02:21:41,550 --> 02:21:47,170
累加器我们希望默认值为1，而且这只是一个函数

1269
02:21:47,170 --> 02:21:53,350
定义我们不需要编写这个函数的主体，让我打开终端并且

1270
02:21:53,350 --> 02:21:58,810
因为我们已经修改了模块的内容，让我们先尝试重新编译这个模块

1271
02:21:58,810 --> 02:22:04,870
现在让我清理一切，然后让我们尝试使用尾递归版本，所以我们可以说

1272
02:22:04,870 --> 02:22:11,230
这次我们想要使用我们的尾递归函数来计算阶乘，并且让我们传递参数

1273
02:22:11,790 --> 02:22:18,890
这样我们得到的答案是6，让我们再试一次，用5的阶乘，对于5我们得到的答案是

1274
02:22:18,890 --> 02:22:25,630
120，现在让我们继续并尝试追踪这个递归程序，这就是我们的尾部

1275
02:22:25,630 --> 02:22:31,510
递归版本，正如你所见，对于第一行，我们有函数定义，第一个

1276
02:22:31,510 --> 02:22:37,130
参数是数字，我们为累加器和默认值

1277
02:22:37,130 --> 02:22:43,230
是1，接下来我们有基本情况，在这里我们只想在数字上进行模式匹配

1278
02:22:43,230 --> 02:22:49,750
因此，我们在数字为1的情况下，我只想返回我的

1279
02:22:49,750 --> 02:22:56,490
累加器接下来，我们有递归案例，所以对于每次迭代，我们只想递减

1280
02:22:56,490 --> 02:23:03,250
数字减一，我们还想用数字乘以我们的累加器，现在让我们

1281
02:23:03,250 --> 02:23:08,690
看看会发生什么，假设我们用三个参数调用函数

1282
02:23:08,690 --> 02:23:14,630
累加器的默认值是1，那么下一次迭代会发生什么

1283
02:23:14,630 --> 02:23:20,590
所以三等于一吗？不，所以elixir将直接跳过这里，那么接下来会发生什么

1284
02:23:20,590 --> 02:23:27,550
这次我们想回调自己，所以这个函数会回调自己，但这次的

1285
02:23:27,550 --> 02:23:33,470
参数是数字减一，所以三减一，所以我们在这里得到了一个二。

1286
02:23:33,470 --> 02:23:39,750
对于下一个参数，我们只想用累加器乘以数字。

1287
02:23:39,750 --> 02:23:45,010
累加器是一个，数字是三，所以我们在这里得到了一个三，所以这个函数会。

1288
02:23:45,010 --> 02:23:51,390
看起来像这样，所以下一步再次，所以二等于一吗，不，所以我们必须再调用一次。

1289
02:23:51,390 --> 02:23:56,670
再多一次，所以这一次会发生什么是我们想将数字减一。

1290
02:23:56,670 --> 02:24:03,610
所以这个求值为一，我们还想用累加器乘以数字，所以

1291
02:24:03,610 --> 02:24:09,790
累加器是三，数字是二，所以我们在这里得到了一个六，所以这个函数会

1292
02:24:09,790 --> 02:24:15,430
看起来像这样，这次会发生什么，哦，所以这次我们有一个匹配的

1293
02:24:15,430 --> 02:24:21,290
数字，我们正在进行模式匹配并说在那个时候，如果数字是一个

1294
02:24:21,290 --> 02:24:27,190
想要返回累加器，所以这个函数会求值为这样的东西，我们只是简单地

1295
02:24:27,190 --> 02:24:33,170
必须将累加器返回，并且累加器的值是六，这就是你的最终答案。

1296
02:24:33,170 --> 02:24:39,170
在此之后我们只需退出，因为没有其他事情要做，这只是一个小提示。

1297
02:24:39,170 --> 02:24:44,150
每当你感到对递归感到困惑，或者不知道递归内部发生了什么时，

1298
02:24:44,150 --> 02:24:49,830
递归调用时，画这种递归树总是一个好主意，它们肯定会

1299
02:24:49,830 --> 02:24:55,730
帮助你更好地理解递归，好了，就到这里，我会理解的

1300
02:24:55,730 --> 02:25:01,670
在下一个视频中见到你，让我们继续练习递归，这次我想让你

1301
02:25:01,670 --> 02:25:08,490
编写一个程序，将数字反转，例如数字是一二三，那么

1302
02:25:08,490 --> 02:25:14,290
输出应该是三二一，我在幕后创建了一个新的

1303
02:25:14,970 --> 02:25:22,350
在递归内部创建了一个反转数字，并为它创建了一个空模型，现在你可以使用

1304
02:25:22,350 --> 02:25:28,490
你自己的逻辑来反转数字，或者如果你想要一些参考，我给出了一个简单的算法。

1305
02:25:28,490 --> 02:25:34,110
就在这里，但不一定要按照我的逻辑来做，如果你可以用其他方式做到，你可以。

1306
02:25:34,110 --> 02:25:39,830
欢迎你这样做，让我们看看我在这里给出的步骤，例如数字。

1307
02:25:39,830 --> 02:25:47,630
如果是123，那么输出应该是321，所以对于这种情况，假设我想写一个尾递归的。

1308
02:25:47,630 --> 02:25:53,370
在那个时候，我想要一个名为累加器的变量。

1309
02:25:53,370 --> 02:25:59,230
将累加器的默认值设为零，现在你不必写一个尾递归。

1310
02:25:59,230 --> 02:26:04,870
递归版本，你可以写任何你认为好的版本，但我要写一个尾递归的。

1311
02:26:04,870 --> 02:26:10,850
递归版本，所以我又取了一个变量，接下来我要做的是。

1312
02:26:10,850 --> 02:26:18,490
我正在创建一个循环，每次迭代我都想创建一个新的数字和一个新的累加器。

1313
02:26:18,490 --> 02:26:24,250
让我们看看每次迭代对于新的数字和新的累加器会发生什么。

1314
02:26:24,250 --> 02:26:31,690
在循环中，我只是想将这个数字除以10，这样每次都会得到一个新的数字。

1315
02:26:31,690 --> 02:26:41,550
第一次，数字是123，所以123除以10，答案是12，现在是新的累加器

1316
02:26:41,550 --> 02:26:48,830
有两个步骤，第一步是我只想把现有的累加器乘以10

1317
02:26:48,830 --> 02:26:55,950
现在现有的累加器是零，所以零乘以10，所以我得到了一个零

1318
02:26:55,950 --> 02:27:02,810
所以这是第一部分，下一部分是我还想取这个数字的余数

1319
02:27:02,810 --> 02:27:09,730
所以我使用取模运算符，这里会发生的是123除以10的余数

1320
02:27:09,730 --> 02:27:17,850
是三，最后一步是零加上三，我们立刻得到了三，下一步是

1321
02:27:17,850 --> 02:27:24,450
我想继续循环，直到我的数字变为零，但是现在我的数字是

1322
02:27:24,450 --> 02:27:32,890
所以这个数字从123变成12，而新的累加器是三，这就是为什么这个零

1323
02:27:32,890 --> 02:27:40,470
变成了一个三，现在我的数字是否等于零？不是，所以我们继续循环，所以下一个循环

1324
02:27:40,470 --> 02:27:48,090
迭代中我们的数字是12，所以12除以10，我们得到了一个一，就在这里，而且对于新的

1325
02:27:48,930 --> 02:27:55,550
累加器中的值是三，所以三乘以10得到30，就在这里。

1326
02:27:55,550 --> 02:28:04,570
接下来，数字是12，12除以10的余数是2，所以这里有30加上2。

1327
02:28:04,570 --> 02:28:12,750
这就是为什么结果是32，现在再次检查我的数字是否等于零，不，我的新数字是。

1328
02:28:12,750 --> 02:28:19,970
是1，我的新累加器是32，所以我们继续执行相同的循环，这次我的数字是。

1329
02:28:19,970 --> 02:28:27,010
1，所以1除以10得到0，就在这里，然后对于新累加器，我的值是。

1330
02:28:27,010 --> 02:28:35,010
累加器是32，正如你在这里看到的，我们有32，所以32乘以10，这就是为什么。

1331
02:28:35,010 --> 02:28:43,030
我们在这里得到320，下一部分的数字是1，1除以10的余数变成了。

1332
02:28:43,030 --> 02:28:52,130
1，所以这里有1加上320，所以我们得到了3、2和1，在这里，所以发生了什么呢？

1333
02:28:52,130 --> 02:28:59,910
现在你的数字变成了零，你的累加器变成了321，由于你的数字变成了零，

1334
02:28:59,910 --> 02:29:06,470
我们只需要返回累加器，累加器是三二一，恰好是。

1335
02:29:06,470 --> 02:29:11,850
逆序为321，现在在您尝试这个问题之前，让我给您展示一件事情。

1336
02:29:11,850 --> 02:29:19,670
在Elixir中，如果您执行这样的操作123除以10，您会发现我们得到的是

1337
02:29:19,670 --> 02:29:25,790
一个浮点数值，但是如果您想要得到一个整数除法，那么可以使用内置的

1338
02:29:25,790 --> 02:29:34,750
除法函数div，所以我们可以说我们想要将123除以10，并得到整数

1339
02:29:34,750 --> 02:29:41,690
值为12，现在对于计算余数，我们没有无操作符，而是可以使用

1340
02:29:41,690 --> 02:29:47,830
内置的remainder函数，所以我们可以说我们想要得到123的余数

1341
02:29:47,830 --> 02:29:53,690
除以10，我们得到值3。所以考虑到这些事情，我希望您尝试一下这个问题

1342
02:29:53,690 --> 02:29:59,990
现在，让我再次重复一遍，您可以使用自己的逻辑，暂停一下视频，然后尝试一下

1343
02:29:59,990 --> 02:30:05,990
自己尝试。否则，我们将一起做。所以我希望您能够完成它，如果不能，让我们一起做

1344
02:30:05,990 --> 02:30:11,150
。一起，我将为这个程序编写一个尾递归版本，首先

1345
02:30:11,150 --> 02:30:18,070
我想要做的就是定义我的基本情况，我的基本情况是什么，我的基本情况

1346
02:30:18,070 --> 02:30:24,530
就在这里，所以如果我的数字是零，那么我只想返回累加器，让我

1347
02:30:24,530 --> 02:30:30,730
创建一个名为off的函数，这个函数将接受两个参数，我的数字和

1348
02:30:30,730 --> 02:30:37,970
我的累加器和我的基本情况就像这样，如果我的数字是零，那么我只想要

1349
02:30:37,970 --> 02:30:45,150
返回我的累加器，这就是我们的基本情况，现在让我们定义递归情况，所以我们

1350
02:30:45,150 --> 02:30:50,970
可以说off函数将接受一个参数表示数字，第二个

1351
02:30:50,970 --> 02:30:57,590
一个用于累加器，让我们在这里创建do和end块，我们可以说我的新数字

1352
02:30:57,590 --> 02:31:05,770
将是我的数字除以10的整数除法，而且对于每次迭代，我都想要

1353
02:31:05,770 --> 02:31:11,650
创建一个新的累加器，这样我可以说我的新的累加器，让我们再次使用我们的逻辑

1354
02:31:11,650 --> 02:31:17,770
在这里定义的逻辑是这样的，对于每次迭代，我只想要将其乘以

1355
02:31:17,770 --> 02:31:24,110
累加器为10，接下来我们只需将余数加上即可

1356
02:31:24,110 --> 02:31:30,550
再加上10，现在只需简单地再调用一次相同的函数就可以了

1357
02:31:30,550 --> 02:31:37,750
但这次参数将是我们的新数字，现在我们有了新的累加器

1358
02:31:37,750 --> 02:31:43,310
我们还需要将累加器的默认值设置为零，让我创建一个函数

1359
02:31:43,310 --> 02:31:49,490
在顶部进行定义，这样我们可以说off函数接受一个名为number的参数

1360
02:31:49,490 --> 02:31:56,570
第二个参数被称为accumulator，默认值为零，因为这只是

1361
02:31:56,570 --> 02:32:02,690
函数定义，我们不需要创建函数体，让我保存这个程序，让我打开我的

1362
02:32:03,570 --> 02:32:09,870
现在，由于我这次添加了一个新文件，让我们重新编译整个项目，这样我们就可以说

1363
02:32:09,870 --> 02:32:17,950
我想重新编译，然后让我为tutorials.dot.recursion.dot.reverse创建一个别名

1364
02:32:17,950 --> 02:32:27,340
number哦，抱歉，我拼错了，所以应该是alias，让我清除屏幕，现在让我们

1365
02:32:27,340 --> 02:32:35,840
新定义的函数，我们可以说是反转数字，并让我们传入参数123。

1366
02:32:35,840 --> 02:32:43,080
我们得到了正确的答案，让我们尝试一下12345，我们得到的答案是

1367
02:32:44,380 --> 02:32:50,660
到目前为止，我们已经看到了如何在我们的elixir中使用递归，现在是时候

1368
02:32:50,660 --> 02:32:58,540
我们如何将列表与我们的elixir结合起来，我再怎么强调elixir内部的列表也不为过

1369
02:32:58,540 --> 02:33:06,240
这不是你常规的数组或者列表，elixir中的列表实际上是链表，所以即使是一个列表

1370
02:33:06,240 --> 02:33:12,320
看起来像这样，它并不是看起来那样，所以对于那些不知道什么是的人来说

1371
02:33:12,320 --> 02:33:19,320
这是一个链表，我们这里有三个不同的节点，对于第一个节点，数据是

1372
02:33:19,320 --> 02:33:25,800
头部内的数据是1，所以你可以看到列表内的数据，这个数据实际上是

1373
02:33:25,800 --> 02:33:31,960
在内存中看起来像这样，所以整个东西就是你的节点编号

1374
02:33:31,960 --> 02:33:39,220
一个，你头部内的数据就是1，你可以在这里看到的较暗部分，所以

1375
02:33:39,220 --> 02:33:45,480
这将成为您的节点编号一的尾部，这个尾部实际上指向另一个节点

1376
02:33:45,480 --> 02:33:52,060
另一个节点，该节点内部的数据是二，你可以在这里看到，所以整个

1377
02:33:52,060 --> 02:33:58,660
结构，这是我们的节点编号二，头部内部的数据是二，现在再次，这个节点

1378
02:33:58,660 --> 02:34:05,540
也有一个尾部，这个尾部指向另一个节点，节点内部的数据是三

1379
02:34:05,540 --> 02:34:11,200
正如您所见，这将成为我们的节点编号三，头部和内部数据

1380
02:34:11,200 --> 02:34:17,820
头部是三，现在如果您查看列表，我们没有剩下任何其他参数，所以

1381
02:34:17,820 --> 02:34:24,060
您的节点编号三的尾部实际上指向一个空值，这意味着它是

1382
02:34:24,060 --> 02:34:30,160
不指向其他任何东西，这就是链表在内存中的样子，现在只是

1383
02:34:30,160 --> 02:34:35,680
为了刷新您的记忆，让我们回到我们的终端，这样我们就可以说我们有一个列表和

1384
02:34:35,680 --> 02:34:41,540
元素是一、二和三，现在正如我们刚才看到的，我们有三个不同的节点

1385
02:34:41,540 --> 02:34:46,400
如果你想看到第一个元素的头部，那么你可以使用内置的

1386
02:34:46,400 --> 02:34:52,380
头部的函数，或者我们也可以使用模式匹配，如果你想使用模式

1387
02:34:52,380 --> 02:34:59,060
匹配，我们可以说第一个元素应该是头部，那么我们需要我们的cons运算符

1388
02:34:59,060 --> 02:35:06,320
然后我们需要另一个变量来表示尾部，让我们在列表上进行模式匹配，这样我们就可以看到

1389
02:35:06,320 --> 02:35:13,260
头部是1，尾部是2和3，现在假设我们有另一个列表，我们称之为

1390
02:35:13,260 --> 02:35:20,320
作为第二个列表，其中包含一个元素a，现在如果我尝试

1391
02:35:20,320 --> 02:35:26,780
对这个列表进行模式匹配，所以让我们进行模式匹配并看到让我们写下头部，我们也

1392
02:35:26,780 --> 02:35:33,000
想要尾部，这次我们想对第二个列表进行模式匹配，所以你可以看到

1393
02:35:33,000 --> 02:35:40,280
头部中的数据是a，但是尾部发生了什么，让我们来检查一下，所以你可以看到

1394
02:35:40,280 --> 02:35:45,940
尾部为空，这意味着我们已经用完了这个链表，没有更多的元素了

1395
02:35:45,940 --> 02:35:51,540
所以记住这个模式，我们将看到如何使用递归和列表进行工作，对吧。

1396
02:35:51,540 --> 02:35:58,000
从下一个视频开始，让我们开始使用链表，但在开始之前，我想要

1397
02:35:58,000 --> 02:36:05,700
向你展示一些东西，让我们返回到终端，我现在在我的iex中，以防万一

1398
02:36:05,700 --> 02:36:12,480
如果我想查看列表的信息，让我们创建一个列表，包括one，two和three，这样我们就会得到

1399
02:36:12,480 --> 02:36:18,720
我们的列表有一些信息参数，我们可以看到我们有一些

1400
02:36:19,680 --> 02:36:26,040
协议，其中一个最重要的协议就是这个，它代表可枚举的

1401
02:36:26,040 --> 02:36:32,260
简而言之，就是enum，让我们去官方文档，我可以在那里解释

1402
02:36:32,260 --> 02:36:40,140
所有这些东西，这是elixir的官方网站，它是elixirlang.org，让我们去文档

1403
02:36:40,140 --> 02:36:46,180
在这里，我们想要看到当前稳定版本的文档，所以这会带我们去一个新的

1404
02:36:46,180 --> 02:36:53,580
网站，正如你所见，这个网站被称为hexdocs.pm，所以hex就像是软件包注册表

1405
02:36:53,580 --> 02:37:00,280
对于Elixir，如果你去这个网站hex.pm，在这里我们可以搜索不同的

1406
02:37:00,280 --> 02:37:05,200
包，假设你想搜索Phoenix，你可以在这里搜索Phoenix

1407
02:37:05,200 --> 02:37:11,060
这将列出所有的包，所以这是Phoenix的官方包

1408
02:37:11,060 --> 02:37:17,060
如果你点击在线文档，它将带你到文档页面，这是

1409
02:37:17,060 --> 02:37:22,420
Phoenix的官方文档，现在让我们回到Elixir的文档

1410
02:37:22,960 --> 02:37:28,760
正如你所见，我们在这里有两个选项卡，这个选项卡是用于页面，而这个选项卡是

1411
02:37:28,760 --> 02:37:35,120
用于模块，现在内核模块是自动导入的，我们不需要

1412
02:37:35,120 --> 02:37:42,420
导入这个内核，我想要展示给你的下一个模块是用于我们的列表，所以让我们滚动一下

1413
02:37:42,420 --> 02:37:48,820
稍微往下滚动，在这个集合和枚举的部分，我们有我们的列表

1414
02:37:48,820 --> 02:37:55,800
在这里，我们可以看到我们有很好的文档，并且我们还有一些

1415
02:37:55,800 --> 02:38:02,000
关于列表类型的函数的实现，我们可以看到这里有不同的函数。

1416
02:38:02,000 --> 02:38:07,000
如果你想查看任何函数的文档，只需点击这个。

1417
02:38:07,000 --> 02:38:12,820
这将打开所请求函数的文档。现在在终端中我们看到

1418
02:38:12,820 --> 02:38:19,260
列表还实现了我们的枚举的协议，所以让我们查看一下文档。

1419
02:38:19,260 --> 02:38:27,200
枚举，让我收起我的列表，让我们去枚举的文档。枚举基本上帮助你

1420
02:38:27,200 --> 02:38:33,400
迭代你的列表或任何集合，并且大多数可迭代对象的函数都在枚举中。

1421
02:38:33,400 --> 02:38:39,780
枚举中，其中一些函数可能在列表、映射或哈希映射中，但枚举将是你最常用的模块。

1422
02:38:39,780 --> 02:38:46,180
经常使用的模块，正如你在文档中看到的，第一个例子本身就使用了一个列表。

1423
02:38:46,180 --> 02:38:53,260
第二个例子也接受一个列表，并简单地返回列表的总和，所以我们可以做什么

1424
02:38:53,260 --> 02:39:00,480
让我们尝试使用我们的列表和递归来复制这个功能，所以现在让我们去吧

1425
02:39:00,480 --> 02:39:08,020
回到我们的代码编辑器，现在让我们创建一个新的文件夹，所以在我的lib目录下

1426
02:39:08,020 --> 02:39:14,340
我们创建一个名为list的文件夹，在这个文件夹里创建一个名为list.ex的新文件

1427
02:39:16,000 --> 02:39:25,560
list.ex，让我们首先定义模块，它必须是dot tutorials和这个命名

1428
02:39:25,560 --> 02:39:30,820
转换没有意义，所以现在让我把这个list拿出来，然后我们给它命名

1429
02:39:30,820 --> 02:39:38,080
模块命名为tutorials.dot.list，所以让我定义一个名为sum的函数，这个函数将会接受

1430
02:39:38,080 --> 02:39:45,840
我们的数字列表，现在首先让我们考虑一个基本情况，假设我们得到一个空列表，那么在那种情况下

1431
02:39:45,840 --> 02:39:52,380
我们可以简单地返回零，让我在顶部定义一个基本情况，我可以说定义

1432
02:39:52,380 --> 02:39:58,840
我的sum，让我们对空列表进行模式匹配，所以我们可以直接在这里写空列表

1433
02:39:58,840 --> 02:40:05,180
所以如果我们得到一个空列表，我们只需要返回零，现在让我们看看我们如何

1434
02:40:05,180 --> 02:40:11,400
递归情况下，我们可以做的是这个参数numbers，实际上是一个列表

1435
02:40:11,400 --> 02:40:17,400
所以我们可以在这里进行模式匹配，我可以将这个参数拿出来

1436
02:40:17,400 --> 02:40:23,500
让我们在函数定义中进行模式匹配，让我们将头部收集到一个叫做的变量中

1437
02:40:23,500 --> 02:40:30,940
作为h，让我们将尾部收集到一个叫做的变量中，现在让我们看看我们要做什么

1438
02:40:30,940 --> 02:40:37,460
每次迭代，我们只想将头部与总和相加，每次我们只想

1439
02:40:37,460 --> 02:40:43,820
传递尾部，就这样，我们有一个递归函数，用于将所有元素相加

1440
02:40:43,820 --> 02:40:49,980
现在，正如你所看到的，这不是一个尾递归版本，所以我们可以

1441
02:40:49,980 --> 02:40:56,880
试着给这个函数改个名字，不叫sum了，我们把它重命名为sum

1442
02:40:58,340 --> 02:41:04,400
这样做很简单，因为这只是一行返回语句，让我来处理一下

1443
02:41:04,400 --> 02:41:11,140
变成一行代码，我们不需要结束块，让我们打开我们的

1444
02:41:11,140 --> 02:41:18,000
终端，看看这个是否正常工作，让我进入我的ix，让我清理一下

1445
02:41:18,000 --> 02:41:23,940
终端，我们可以说从教程模块跳转到列表模块

1446
02:41:23,940 --> 02:41:31,460
然后我想调用简单求和函数，并让我们传递列表[1, 2, 3]

1447
02:41:31,460 --> 02:41:39,000
正如预期的那样，我们得到了答案六。现在我们可以写这个函数

1448
02:41:39,000 --> 02:41:45,700
通过使用尾递归，让我们看看如何创建尾递归函数，以便我们可以调用

1449
02:41:45,700 --> 02:41:52,620
将该函数命名为sum_and_tail_recursive，让我们考虑可以传递的不同参数

1450
02:41:52,620 --> 02:41:58,900
对于我们的尾递归版本，此函数将接受两个参数，第一个参数显然是我们的

1451
02:41:58,900 --> 02:42:05,280
数字列表，我们还需要一个累加器，我们可以定义这个函数

1452
02:42:05,280 --> 02:42:12,040
在这里定义，因此我们可以说累加器的默认值必须为零

1453
02:42:12,040 --> 02:42:17,460
现在，由于我们刚刚创建了函数定义或函数头，我们不需要

1454
02:42:17,460 --> 02:42:23,620
为这个函数创建函数体，接下来让我们编写实际的实现，让我复制一下

1455
02:42:23,620 --> 02:42:30,620
所以在这里我们不需要默认参数，首先让我们考虑基本情况，所以如果

1456
02:42:30,620 --> 02:42:37,100
numbers只是一个空列表，所以在那时我们只想返回我们的累加器

1457
02:42:37,100 --> 02:42:44,000
下一个是我们的递归情况，所以让我再次复制和粘贴，这一次我们可以模式匹配

1458
02:42:44,000 --> 02:42:49,900
在头部和尾部进行匹配，所以我们可以说我们想收集头部，我们也想要

1459
02:42:49,900 --> 02:42:56,300
收集尾部，并且对于每次迭代，我们只想调用相同的函数，但是

1460
02:42:56,300 --> 02:43:02,100
现在对于每次迭代，我们只想传递尾部，我们不需要为每次传递头部

1461
02:43:02,100 --> 02:43:09,600
迭代，我们的累加器变成了我们的累加器加上我们的头部，就这样我们有了一个尾部

1462
02:43:09,600 --> 02:43:15,620
递归函数，现在让我们做一件简单的事情，让我来到顶部，这里让我

1463
02:43:15,620 --> 02:43:22,380
创建一个名为sum的函数，它接受我们的numbers，在这里让我们简单地

1464
02:43:22,380 --> 02:43:28,200
调用尾递归版本，所以我们可以说我想调用我的尾递归版本

1465
02:43:28,200 --> 02:43:34,560
让我把数字传递给它，这样我们就有一个更小的名字，这让我们的生活更轻松

1466
02:43:34,560 --> 02:43:43,180
更容易，所以让我们回到终端，重新编译tutorials.dot.list，让我清理一下

1467
02:43:43,180 --> 02:43:49,400
屏幕上，让我们调用相同的函数，但这次函数的名字只是sum

1468
02:43:49,400 --> 02:43:55,600
正如预期的那样，我们得到的答案是六，这次计算总和我们使用的是

1469
02:43:55,600 --> 02:44:02,260
尾递归版本。现在，我不会再画递归树了，但如果你

1470
02:44:02,260 --> 02:44:07,920
感到自信，或者感到困惑，那么我强烈建议你画出递归树

1471
02:44:07,920 --> 02:44:13,920
现在，在结束这个视频之前，我想向你展示一些东西。第一件事是

1472
02:44:13,920 --> 02:44:19,080
让我们看看如何为我们的所有代码做文档。第一件事是我们可以使用一些东西

1473
02:44:19,080 --> 02:44:25,600
称为模块属性，所以在顶部，我们可以说我们想要为

1474
02:44:25,600 --> 02:44:31,580
整个模块，所以让我们记录下我们要为这个列表模块做的事情

1475
02:44:31,580 --> 02:44:37,740
实现一些可用于列表的函数，以便我可以为我们创建一个标题。

1476
02:44:37,740 --> 02:44:44,000
函数概要，我们实现的第一个函数是求和函数，这是它的用法。

1477
02:44:44,000 --> 02:44:49,320
接下来，写模块级文档，让我来展示一下我们如何编写文档。

1478
02:44:49,320 --> 02:44:55,920
我们的函数，我们可以使用`__doc__`模块属性，在引号内编写文档。

1479
02:44:55,920 --> 02:45:01,400
让我们编写文档，说明这个函数返回数字的和。

1480
02:45:01,400 --> 02:45:06,760
在一个列表中，现在如果你将鼠标悬停在sum的定义上，我们可以看到代码。

1481
02:45:06,760 --> 02:45:11,900
编辑器正在显示文档，这是我在这个视频中想要向你展示的最后一件事。

1482
02:45:11,900 --> 02:45:19,360
在这个视频中，我想向你展示如何定义类型规范或类型提示，我们可以使用另一个模块。

1483
02:45:19,360 --> 02:45:31,360
通过spec这个名称来定义属性，这代表函数的规范，所以这里我们想要定义

1484
02:45:31,360 --> 02:45:39,140
这个参数的类型，在我们的例子中，sums实际上是一个列表，这个列表包含不同的

1485
02:45:39,140 --> 02:45:45,740
数字，所以这就是我们定义数字类型的方式，接下来是返回类型，所以我们可以将返回类型定义为数字，所以在这里

1486
02:45:45,740 --> 02:45:51,760
可以使用双引号，并且我们可以说返回类型也将是一个数字，所以

1487
02:45:51,760 --> 02:46:01,340
我们所做的是我们还添加了文档，也添加了规范，所以在

1488
02:46:01,980 --> 02:46:07,500
你的代码内部，接下来让我们也为我们的其他函数编写规范

1489
02:46:07,500 --> 02:46:14,640
所以让我复制这个并粘贴到这里，这个函数将是我们的求和函数

1490
02:46:14,640 --> 02:46:21,120
接下来让我们也为我们的尾递归函数编写规范，所以我可以说

1491
02:46:21,120 --> 02:46:27,560
这个函数的名称实际上是我的尾递归求和函数，现在这个函数接受两个参数

1492
02:46:27,560 --> 02:46:34,260
第一个参数是一个数字列表，第二个参数只是一个整数，所以我们可以说

1493
02:46:34,260 --> 02:46:40,060
第二个参数是整数，返回类型是数字，如果你想阅读更多

1494
02:46:40,060 --> 02:46:47,060
关于类型规范的信息，我们可以查阅官方文档，我们可以去

1495
02:46:47,060 --> 02:46:53,180
页面标签上，我们可以看到我们的类型规范文档没错了

1496
02:46:53,180 --> 02:46:58,240
不要过于担心类型规范，我会向你展示如何编写规范

1497
02:46:58,240 --> 02:47:04,020
从这里开始，我们就结束了这个视频，我会在下一个视频中与你见面

1498
02:47:04,540 --> 02:47:10,760
现在让我们看看如何在elixir中反转一个列表，例如我们有一个列表，它是这样的

1499
02:47:10,760 --> 02:47:16,340
列表有两个元素两个和三，所以在你的内存中，这个列表会像这样

1500
02:47:16,340 --> 02:47:23,200
我们有两个节点，所以这个节点是为了两个，这个节点是为了三，现在我有一个问题

1501
02:47:23,200 --> 02:47:28,960
假设我们在左边有两个节点，我们可以看到我们有一个节点，在右边

1502
02:47:28,960 --> 02:47:36,000
在这里我们可以看到我们有一个节点，所以现在的问题是将这个节点添加到我们的列表中

1503
02:47:36,000 --> 02:47:42,020
将两个和三添加到列表中是更快的，还是将四添加到我们的列表中是更快的，所以

1504
02:47:42,020 --> 02:47:48,280
你认为哪个操作会更快，这个操作会更快，所以答案是

1505
02:47:48,280 --> 02:47:55,480
添加这个节点会更快，这是因为它在常数时间内完成，原因是我们没有

1506
02:47:55,480 --> 02:48:01,660
为了遍历整个列表，我们只需取一个节点，然后将尾部指向

1507
02:48:01,660 --> 02:48:08,640
现有列表，就这样，但如果我们想在最后添加一个节点，那时它

1508
02:48:08,640 --> 02:48:14,620
效率不高，因为它需要线性时间，添加这个节点也需要线性时间

1509
02:48:14,620 --> 02:48:20,420
因为我们必须遍历整个链表，所以需要一些时间，因此在这种情况下，我们必须从

1510
02:48:20,420 --> 02:48:28,280
这个节点到这个节点，然后我们就可以将这个节点的尾部指向最后一个节点，所以它需要

1511
02:48:28,280 --> 02:48:34,200
线性时间，所以请记住，将节点添加到头部始终更快

1512
02:48:34,200 --> 02:48:40,640
而且，使用这种逻辑，在最后添加一个节点需要线性时间，让我们看看我们如何

1513
02:48:40,640 --> 02:48:46,300
可以反转一个列表，例如，我们有一个列表在这里，并且我们有元素one，two

1514
02:48:46,300 --> 02:48:52,960
和three，所以这时候我们将使用一个额外的累加器列表，对于每次迭代我们都将

1515
02:48:52,960 --> 02:48:59,180
将这个元素的头部取出，并将该头部插入我们的累加器列表中，那么会发生什么呢？

1516
02:48:59,180 --> 02:49:05,020
第一次迭代时，我们只需取出头部并将其插入累加器中

1517
02:49:05,560 --> 02:49:11,800
由于我们是在头部插入，所以此操作的时间是恒定的，并且对于下一步

1518
02:49:11,800 --> 02:49:17,740
迭代中会发生什么呢？由于我们已经取出了一个，您的列表现在变为两个和三个

1519
02:49:17,740 --> 02:49:24,020
在下一次迭代中，我们只需取出两个，并将两个添加到现有列表的头部

1520
02:49:24,020 --> 02:49:29,640
由于我们是在头部添加，这个操作也是按线性时间进行的，现在进入我们的

1521
02:49:29,640 --> 02:49:35,360
原始列表，由于我们已经取出了两个，所以只剩下一个元素，同样的情况再次发生

1522
02:49:35,360 --> 02:49:41,440
我们只需将三取出，并将三添加到累加器列表的头部，就是这样

1523
02:49:41,440 --> 02:49:46,920
已经反转了一个链表，或者说我们只是在elixir中简单地反转了一个列表，所以让我们

1524
02:49:46,920 --> 02:49:52,300
为这个编写代码，让我们看看这些东西是如何运作的，所以让我加上一个注释

1525
02:49:52,300 --> 02:49:58,760
这将是我们的反转功能，在这里让我们定义一个名为reverse的函数。

1526
02:49:58,760 --> 02:50:04,980
现在这个函数接受两个参数，第一个是我们的元素，第二个是

1527
02:50:04,980 --> 02:50:10,260
是用于累加器的，并让我们在这里定义函数签名，以防万一

1528
02:50:10,260 --> 02:50:16,420
累加器在那时没有给出，那么我们只需将累加器设置为空列表

1529
02:50:16,420 --> 02:50:22,900
接下来是我们的基本情况，所以让我复制粘贴，这里我们可以进行模式匹配，我们可以

1530
02:50:22,900 --> 02:50:28,740
说在这里如果我们有一个空列表，那么我们只想要返回

1531
02:50:28,740 --> 02:50:35,640
我们的累加器，所以我可以说做和我的累加器，接下来是我们的递归情况

1532
02:50:35,640 --> 02:50:41,200
所以再让我复制粘贴，现在我们可以做的是对列表进行简单的模式匹配

1533
02:50:41,200 --> 02:50:47,620
所以我们可以取头部，也可以取尾部，对于每次迭代，我们必须调用

1534
02:50:47,620 --> 02:50:53,640
相同的函数回来，现在让我们看看如何为我们的尾递归函数传递参数

1535
02:50:53,640 --> 02:50:59,640
首先让我们为累加器编写参数，所以如果我们回到我们的图表

1536
02:50:59,640 --> 02:51:05,560
所以这里我们想做的是，我们想要取出头部，然后将头部插入到

1537
02:51:05,560 --> 02:51:12,260
我们的累加器中，这就是我们可以在这里做的，所以我们只想取出头部，然后

1538
02:51:12,260 --> 02:51:18,460
将头部添加到我们的累加器中，现在让我们再回到图表，因为我们已经

1539
02:51:18,460 --> 02:51:24,700
取出了一个列表，下一次迭代应该是两个和三个，而且我们可以很容易地

1540
02:51:24,700 --> 02:51:35,540
做到这一点，所以对于下一次迭代，我们只需要将尾部传递回来，就这样我们就有了一个

1541
02:51:35,540 --> 02:51:42,780
这个程序在我们的 ix 中，所以让我打开我的终端，现在让我进入我的 ix，现在让我

1542
02:51:42,780 --> 02:51:49,240
清屏，我可以说我想要从我的教程模块转到我的列表，然后我

1543
02:51:49,240 --> 02:51:56,400
想要反转，然后让我们传递参数 one two 和 three，正如预期的那样，我们得到了

1544
02:51:56,400 --> 02:52:02,880
答案为 three two 和 one，现在视频中的最后一件事是让我们也写一下

1545
02:52:03,350 --> 02:52:09,540
对于这个函数，我们可以使用模块属性来进行规范，我们可以说

1546
02:52:09,540 --> 02:52:15,480
我们的reverse函数现在可以说，elements实际上是一个列表

1547
02:52:15,480 --> 02:52:21,380
由于我们不知道列表中会有什么类型的元素，我们可以说

1548
02:52:21,380 --> 02:52:27,240
它们可以是任何类型，并且累加器也是同样的情况，让我给你展示一下

1549
02:52:27,240 --> 02:52:33,420
更多的替代语法，所以我们可以简单地写成这样的列表，里面

1550
02:52:33,420 --> 02:52:39,620
我们可以指定这个列表可以容纳任何类型的元素，而且对于返回类型

1551
02:52:39,620 --> 02:52:45,880
我们可以说返回类型也是一个列表，而且这个列表可以容纳任何东西，所以我们可以指定

1552
02:52:45,880 --> 02:52:51,280
这里可以是任何东西，为了保持一致，让我也将这个转换一下，所以让

1553
02:52:51,280 --> 02:52:57,040
我放上方括号，我们不需要这个，就这样结束了，下一个视频见

1554
02:52:57,040 --> 02:53:04,300
下一个，让我们看看如何实现map函数，但首先让我向你展示一下我做了什么

1555
02:53:04,300 --> 02:53:12,200
在这里我是想说，让我们看看文档，我想要查看枚举模型的文档。

1556
02:53:12,200 --> 02:53:20,600
要查看map函数的文档，正如你在这里所看到的，这个map函数接受一个列表。

1557
02:53:20,600 --> 02:53:28,960
元素列表和一个函数作为参数，对于每次迭代，它会简单地应用这个函数。

1558
02:53:28,960 --> 02:53:35,740
将这个函数应用于元素，例如，我们可以看到第一个元素是1，这个函数将1乘以2，所以我们得到了答案2。

1559
02:53:35,740 --> 02:53:42,320
这个函数接受1并返回1乘以2，这就是为什么我们得到了答案2。

1560
02:53:42,320 --> 02:53:48,760
现在我们转到下一个元素，下一个元素是2，所以2乘以2等于4。

1561
02:53:48,760 --> 02:53:55,160
得到4，下一个元素是3，3乘以2等于6，就是这样。

1562
02:53:55,160 --> 02:54:01,240
还有一个例子就在这里，在这种情况下，这是一个关键字列表，这个函数会对键值对进行模式匹配，并将值从正数变为负数。

1563
02:54:01,240 --> 02:54:06,880
这个函数会对键和值的对进行模式匹配，并简单地改变值。

1564
02:54:06,880 --> 02:54:14,740
从正数变为负数，因此对于第一次迭代，你的键是a的项，然后将其值变为负数。

1565
02:54:14,740 --> 02:54:21,420
是一个，这个函数正在做的是返回一个负值，所以我们有

1566
02:54:21,420 --> 02:54:27,760
这里右边是负一，用于下一次迭代，键是b的项，值是两个

1567
02:54:27,760 --> 02:54:34,420
在这里我们只是翻转符号，这就是为什么我们得到负二在这里，让我们看看

1568
02:54:34,420 --> 02:54:40,340
我们如何通过使用我们的列表来实现这个函数，所以让我们回到我们的代码编辑器和

1569
02:54:40,340 --> 02:54:47,080
在这里，让我们创建一个叫做map的新函数，看看我们如何实现这个功能

1570
02:54:47,080 --> 02:54:53,460
所以这个函数将接受三个参数，第一个是我们的元素

1571
02:54:53,460 --> 02:55:00,020
第二个是函数，第三个显然是我们的累加器，还让我们设置一下

1572
02:55:00,020 --> 02:55:06,180
累加器是一个空列表，现在在继续之前，我想给你展示一件事

1573
02:55:06,180 --> 02:55:12,660
我们在模块中定义的所有这些函数，所以这个sum的函数

1574
02:55:12,660 --> 02:55:19,260
一些简单的尾递归反转所有这些函数都被称为命名函数

1575
02:55:19,260 --> 02:55:24,480
它们被称为命名函数，因为所有这些函数都属于一个模块

1576
02:55:24,480 --> 02:55:31,260
而在我们的例子中，模块被称为tutorials.list，但是对于这个map函数来说

1577
02:55:31,260 --> 02:55:38,340
我们传递了一个匿名函数，所以这个函数不属于任何模块，所以让我们看看我们如何使用匿名函数

1578
02:55:38,340 --> 02:55:43,960
看看我们如何与匿名函数一起工作，我们可以这样做

1579
02:55:43,960 --> 02:55:49,740
我们可以在需要的地方创建一个匿名函数，或者我们也可以将其单独定义

1580
02:55:49,740 --> 02:55:56,520
我们定义一个名为double的函数，我们可以说这是一个匿名函数

1581
02:55:56,520 --> 02:56:03,020
这个函数接受一个元素，并简单地返回该元素乘以2的结果

1582
02:56:03,020 --> 02:56:10,540
现在记住语法，开头是fn，代表函数，结束位于

1583
02:56:10,540 --> 02:56:16,980
在这里结束块，为了使用这个函数，我们必须使用点符号

1584
02:56:16,980 --> 02:56:26,300
为了调用这个函数，我们可以说我们想调用double的匿名函数，但是我们

1585
02:56:26,300 --> 02:56:32,060
因为这是一个匿名函数，所以我们必须使用点表示法，记住这一点

1586
02:56:32,060 --> 02:56:38,420
让我们回到我们的代码编辑器，让我滚动到函数定义的位置，就在这里

1587
02:56:38,840 --> 02:56:44,960
像往常一样，首先让我们考虑基本情况，让我复制粘贴一下，基本情况是

1588
02:56:44,960 --> 02:56:51,640
如果元素为空，那就是一个空列表，这时我们只需要

1589
02:56:51,640 --> 02:56:57,340
想要返回累加器，我们可以说do和我们的累加器，现在这里发生了什么

1590
02:56:57,340 --> 02:57:03,000
我们不需要这个参数，还有一件事可以做，因为我们不使用这个函数

1591
02:57:03,000 --> 02:57:08,920
通过使用下划线来忽略它，所以这个下划线的意思是我们只是想忽略

1592
02:57:08,920 --> 02:57:15,140
在我们的基本情况下，函数的值是什么，接下来让我们来看看我们的递归情况，让我再来一次

1593
02:57:15,140 --> 02:57:22,860
像往常一样复制和粘贴在这里，让我模式匹配头部和尾部，接下来是我们的函数

1594
02:57:23,380 --> 02:57:29,220
由于这是一个尾递归函数，我们每次都必须调用自己，所以首先让我们

1595
02:57:29,220 --> 02:57:34,020
忽略第一个值，稍后再讲。接下来的参数是用于

1596
02:57:34,020 --> 02:57:39,180
对于每次迭代，我们只需要按原样传递函数，不需要做任何处理

1597
02:57:39,800 --> 02:57:46,440
现在第三个参数是我们收集累加器的地方，累加器内部我们想要做什么？

1598
02:57:46,440 --> 02:57:53,020
我们只是想要拿到这个函数，并在头部上应用这个函数，现在记住

1599
02:57:53,020 --> 02:57:58,660
因为这是一个匿名函数，我们可以使用点语法，所以我们可以说首先我们

1600
02:57:58,660 --> 02:58:04,280
想要拿到这个函数并使用点语法，然后我们想要将这个函数应用在头部

1601
02:58:04,280 --> 02:58:10,060
我们只想在后面附加上我们的累加器，现在让我们来看第一个参数

1602
02:58:10,060 --> 02:58:16,140
现在既然我们已经使用了头部，剩下的就是传递尾部了，就这样，让我

1603
02:58:16,140 --> 02:58:23,080
保存文件，然后让我们打开我们的ix，让我们进入我们的ix，并让我清理一切

1604
02:58:23,080 --> 02:58:30,520
然后让我们试试，我们可以说教程.列表.映射，我们可以说我们的映射是一个

1605
02:58:30,520 --> 02:58:37,180
和三，我们要传递的函数是相同的，让我们取元素并且

1606
02:58:37,180 --> 02:58:44,760
每个元素，让我们简单地乘以二，不要忘记结尾，就这样，我们得到了答案

1607
02:58:44,760 --> 02:58:51,140
但是正如你所看到的，顺序不对，发生了什么事，是我们把列表反转了

1608
02:58:51,140 --> 02:58:57,080
同样，这个三是正确的，所以三乘以二应该是六，但在我们的情况下

1609
02:58:57,080 --> 02:59:03,500
是第一个元素，两乘以二，我们在这里有四，而对于第一个元素是一乘以

1610
02:59:03,500 --> 02:59:09,680
二，我们在这里有两个，但正如你所看到的，这不是正确的答案

1611
02:59:09,680 --> 02:59:16,500
我们也反转了元素的顺序，所以我们可以做的是，首先我们可以调用我们的tutorials dot

1612
02:59:16,500 --> 02:59:24,320
list dot reverse，在其中让我们传递我们的map函数，让我复制并粘贴过来

1613
02:59:24,320 --> 02:59:31,460
现在我们可以看到我们有正确的答案二四和六，但正如你所看到的

1614
02:59:31,460 --> 02:59:38,100
语法可能会让人困惑，所以让我向您介绍管道运算符，让我们粘贴map

1615
02:59:38,100 --> 02:59:44,660
在这里有一个函数，我们可以看到我们只是想要获取这个map函数的输出，

1616
02:59:44,660 --> 02:59:51,080
我们想要将该输出传递给新的函数，新的函数是我们的tutorials.list，

1617
02:59:51,080 --> 02:59:58,740
dot reverse，现在我们不需要指定参数，管道操作符会发生什么

1618
02:59:58,740 --> 03:00:05,220
简单地接受前面语句的输出，并将该输出传递给我们的函数，

1619
03:00:05,220 --> 03:00:11,500
作为第一个参数，所以让我们按下回车键，看看发生了什么，正如我们所预期的那样

1620
03:00:11,500 --> 03:00:19,120
我们得到了正确的答案两个四个和六个，让我来澄清一下，让我们再做一些，例如

1621
03:00:19,120 --> 03:00:25,420
如果您想要反转相同的列表，那么我们可以调用tutorials.list.reverse，假设

1622
03:00:25,420 --> 03:00:32,720
在我们的例子中，列表是一个两个三个和四个，现在我们可以不使用这种语法，我们可以做的是

1623
03:00:32,720 --> 03:00:39,180
我们可以先获取我们的元素，我们可以使用管道操作符，所以我们可以说我想要你

1624
03:00:39,180 --> 03:00:45,580
获取所有这些元素，并将它们传递给我的tutorials.list.reverse函数

1625
03:00:45,580 --> 03:00:52,080
所以发生的是，如果我们有多个转换，我们可以使用这个管道操作符

1626
03:00:52,080 --> 03:00:59,440
所以让我们再次使用相同的例子，在这里让我们创建一个匿名函数称为

1627
03:00:59,440 --> 03:01:05,060
double，我们想要做的就是简单地取出元素并将其返回

1628
03:01:05,060 --> 03:01:11,200
乘以二的元素，现在让我们看看如何使用管道操作符，例如

1629
03:01:11,200 --> 03:01:17,400
我们有一个列表，像这样的一个、二、三和四，我们可以拿这些元素

1630
03:01:17,400 --> 03:01:25,600
我们可以将这些元素传递给我们的函数tutorials.dot.list.dot.map，现在要记住

1631
03:01:25,600 --> 03:01:32,020
map函数接受两个参数，元素和函数，现在这里发生的是因为

1632
03:01:32,020 --> 03:01:38,500
我们使用了管道操作符，这些元素会自动传递给map函数

1633
03:01:38,500 --> 03:01:44,600
而且管道操作符总是将这些元素作为第一个参数传递，所以由于我们有

1634
03:01:44,600 --> 03:01:50,320
第一个参数，我们只需传递第二个参数，所以我们可以说我们想要

1635
03:01:50,320 --> 03:01:56,120
传递名为double的匿名函数，对于累加器，我们不需要传递任何值

1636
03:01:56,120 --> 03:02:02,080
因为累加器的默认值是一个空列表，所以不需要传递值，让我们看看这个的输出

1637
03:02:02,080 --> 03:02:08,660
所以我们得到了8、6、4和2的输出，现在我们可以采用完全相同的方式

1638
03:02:08,660 --> 03:02:14,560
表达式，并将map函数的输出传递给我们的reverse函数，这样我们就可以使用

1639
03:02:14,560 --> 03:02:21,540
tutorials.list.reverse，这次我们得到了预期的答案：2、4、6和8

1640
03:02:21,540 --> 03:02:27,780
现在，我们可以使用内置模块，而不是使用list.reverse，如果我们进入

1641
03:02:27,780 --> 03:02:34,300
enum模块，所以在这里我们可以说我们想将输出传递到enum

1642
03:02:34,300 --> 03:02:40,860
reverse，我们得到了完全相同的答案，所以我们可以使用内置函数，而不是使用我们定义的函数

1643
03:02:40,860 --> 03:02:46,780
也可以使用内置函数，正如你所看到的，这个管道操作符非常方便，无论何时

1644
03:02:46,780 --> 03:02:53,680
我们想进行多个转换，让我们回到map函数，我们想要的是

1645
03:02:53,680 --> 03:03:00,940
要做的就是将这个累加器传送到我们的反转函数中，就这样，现在如果我们打开

1646
03:03:00,940 --> 03:03:08,560
打开我们的终端，重新编译教程.列表，清理一切，这一次如果

1647
03:03:08,560 --> 03:03:16,620
我有一个包含1、2、3和4的列表，如果我只是将这个列表传送到教程.列表.点

1648
03:03:16,620 --> 03:03:23,300
映射，让我们传递一个匿名函数，这样我们就可以说让我们取出那个元素，然后让我们乘以

1649
03:03:23,300 --> 03:03:30,160
这次将元素乘以3，就这样，我们得到了正确的输出，现在再回到

1650
03:03:30,160 --> 03:03:35,540
我们的代码编辑器，你可以使用这个管道运算符，或者你可以使用转换语法

1651
03:03:35,540 --> 03:03:41,380
这样你可以简单地调用反转函数，传递累加器的元素，让我来

1652
03:03:41,380 --> 03:03:47,380
拿出这个，我们还要看一下如何编写这个函数的规格，所以让我们使用

1653
03:03:47,380 --> 03:03:53,600
映射函数的规格的模型属性，现在第一个参数

1654
03:03:53,600 --> 03:04:00,500
将是一个列表，类型可以是任何东西，所以任何东西都可以放在这里，下一个

1655
03:04:00,500 --> 03:04:06,100
现在是一个函数，为了表示这是一个函数，我们可以在这里使用括号

1656
03:04:06,100 --> 03:04:12,880
在这里，我们可以说这个函数接受一个输入，输入可以是任何类型的，然后它

1657
03:04:12,880 --> 03:04:19,420
返回值，并且还会返回一些值，所以这就是我们定义的方式

1658
03:04:19,420 --> 03:04:24,360
函数类型，下一个是累加器，累加器又是

1659
03:04:24,360 --> 03:04:31,220
任何类型的列表，返回类型也将是我们的任何类型的列表，好了，就这些

1660
03:04:31,220 --> 03:04:36,760
这个，我会在下一个视频中和你见面，现在让我们看看如何连接或如何

1661
03:04:36,760 --> 03:04:43,500
将两个列表合并在一起，首先让我在终端里演示一下，假设我们有

1662
03:04:43,500 --> 03:04:50,680
一个像这样的列表，其中包含1、2和3，现在我们想要添加另一个列表，为了添加我们的

1663
03:04:50,680 --> 03:04:58,540
要使用双加号，下一个列表将是4、5和6，在这里

1664
03:04:58,540 --> 03:05:05,040
我们得到了合并后的列表，让我们看看如何编写一个连接函数来实现这一点

1665
03:05:05,550 --> 03:05:12,500
现在为了添加或连接，我们有两个列表，例如第一个列表是一二三

1666
03:05:12,500 --> 03:05:19,940
还有一个列表，是四五六，所以我们实际上想要做的是

1667
03:05:19,940 --> 03:05:26,640
取出最后一个元素，并将该元素插入到下一个列表的头部，但是

1668
03:05:26,640 --> 03:05:32,360
取出最后一个元素不是高效的，因为我们需要遍历整个列表，并且

1669
03:05:32,360 --> 03:05:38,560
到达最后一个元素，所以我们可以简单地将第一个列表反转，使得第一个

1670
03:05:38,560 --> 03:05:44,720
列表变成了这样的三二一，对于每一次迭代，我们只需要取出

1671
03:05:44,720 --> 03:05:51,220
头部并将其插入到我们的第二个列表的头部位置，所以对于第一个

1672
03:05:51,220 --> 03:05:57,640
迭代，我们插入三，对于下一次迭代，我们插入二，最后一次迭代我们插入一

1673
03:05:57,640 --> 03:06:03,860
当我们插入一时，这个列表就变成了一个空列表，所以这就是我们要做的

1674
03:06:03,860 --> 03:06:09,780
实现我们的连接函数，所以让我们在这里定义这个函数，我们可以说定义

1675
03:06:09,780 --> 03:06:16,620
现在，concat函数接受两个参数，我们可以将第一个列表称为源列表，第二个列表称为目标列表

1676
03:06:16,620 --> 03:06:23,340
列表可以是我们的目标列表，对于这个函数，我们不需要一个累加器，第二个列表

1677
03:06:23,340 --> 03:06:29,140
它本身就像一个累加器，所以我要做的是编写一个辅助函数

1678
03:06:29,140 --> 03:06:34,700
所以首先让我们编写这个函数，然后我们可以定义它，这样我们就可以简单地调用这个函数

1679
03:06:34,700 --> 03:06:41,000
将辅助函数称为concat函数，现在记住，就像我刚才说的几分钟

1680
03:06:41,000 --> 03:06:47,200
首先要将这个列表反转，我们可以在函数定义的内部完成

1681
03:06:47,200 --> 03:06:53,160
所以在这里我们可以说，让我们取出源列表，然后将其传递给我们的函数

1682
03:06:53,160 --> 03:07:00,880
接下来是我们的目标列表，我们希望目标列表保持不变，现在我们可以

1683
03:07:00,880 --> 03:07:06,280
继续定义这个辅助函数，所以我们可以说我们想创建一个函数

1684
03:07:06,280 --> 03:07:13,200
名为concat_func的函数，它接受两个参数，第一个列表称为源列表，第二个列表称为目标列表

1685
03:07:13,200 --> 03:07:20,660
称为目标，现在作为我们的基本情况，我们可以简单地在源上进行模式匹配，因此在

1686
03:07:20,660 --> 03:07:27,680
如果源为空，我们只想返回我们的目标，然后

1687
03:07:27,680 --> 03:07:34,120
让我们看看如何定义递归情况，因此我们可以说我们想再次定义concat函数

1688
03:07:34,120 --> 03:07:39,620
在这里，我们可以简单地对第一个列表进行模式匹配，所以对于第一个列表，我们可以进行模式匹配

1689
03:07:39,620 --> 03:07:47,320
对头部进行模式匹配，对尾部进行模式匹配，第二个参数是我们的目标列表，让我们看看如何

1690
03:07:47,320 --> 03:07:53,940
可以定义这个逻辑，现在对于每一次迭代，我们想要回调自己，对吧

1691
03:07:53,940 --> 03:08:00,600
在这里，首先让我们定义第二个参数，因此对于每次迭代，我们想要做的就是简单地

1692
03:08:00,600 --> 03:08:07,060
想要获取头部，然后将我们的目标列表附加到这个上面，现在最后一件事情

1693
03:08:07,060 --> 03:08:13,900
要做的就是将尾部作为我们的第一个参数传递，让我打开我的终端

1694
03:08:13,900 --> 03:08:20,860
让我进入我的ix并清理一切，现在我们可以说我们想要去教程

1695
03:08:20,860 --> 03:08:29,560
点号列表点号连接现在第一个列表将是一二三第二个列表将是四

1696
03:08:29,560 --> 03:08:36,880
五和六就是这样我们得到了期望的输出最后要做的是我们只是想要

1697
03:08:36,880 --> 03:08:42,740
添加我们的类型说明所以让我删除注释我不需要注释在这里我们可以

1698
03:08:42,740 --> 03:08:49,500
规范的模型属性用于我们的连接函数的规范第一个参数是一个列表

1699
03:08:49,500 --> 03:08:56,660
并且元素是任意的下一个参数也是一个列表并且元素是任意类型

1700
03:08:56,660 --> 03:09:04,480
这将返回一个列表类型可以是任意类型接下来是我们的连接函数的辅助函数

1701
03:09:04,480 --> 03:09:11,400
下划线函数现在这个函数只用于内部使用所以我们能做的是

1702
03:09:11,400 --> 03:09:17,380
辅助函数是私有的所以在这里我们可以写def而不是只写def

1703
03:09:17,380 --> 03:09:23,480
p这意味着这将成为一个私有函数就这样让我们来看一下

1704
03:09:23,480 --> 03:09:29,840
我们列表中的最后一个函数这个函数被称为flat map坦率地说我是

1705
03:09:29,840 --> 03:09:35,180
有点困惑，我是否应该在这个系列中包含这个函数，然后我想好了，为什么不呢

1706
03:09:35,180 --> 03:09:40,720
让我添加这个，让我们看看它的运行情况，首先让我给你展示一下我所说的平坦是什么意思

1707
03:09:40,720 --> 03:09:46,860
map，所以让我们回到终端，这里让我们看一下我们枚举模块的文档

1708
03:09:46,860 --> 03:09:54,140
以及 flat map 函数，所以这个函数的作用是接受一个枚举，还接受一个

1709
03:09:54,140 --> 03:10:00,560
函数，现在 flat map 就是关于你两个函数的组合，也就是说

1710
03:10:00,560 --> 03:10:06,740
它是你的 map 和 concat 的组合，这里还有一个例子，我们得到了一个输入

1711
03:10:06,740 --> 03:10:13,620
作为一个列表，在第一次迭代期间，我们得到了一个 a 的项，我们返回一个包含 a 和 a 的列表

1712
03:10:13,620 --> 03:10:18,700
但是如果你看这里，我们没有一个 a 的列表，我们也没有一个单独的 b 的列表

1713
03:10:18,700 --> 03:10:25,060
我们也没有一个单独的 c 的列表，这是因为我们把整个列表变成了平坦的，所以让

1714
03:10:25,060 --> 03:10:30,460
我们来看看我们如何使用递归函数来实现这一点，现在你一定在想我们为什么要这样做

1715
03:10:30,460 --> 03:10:35,480
实施那么多已经存在于标准库中的函数，所以答案是

1716
03:10:35,480 --> 03:10:40,000
我希望你真正熟悉递归，并且从下一个视频开始

1717
03:10:40,000 --> 03:10:45,680
看看我们如何使用所有内置模块，但对于最后一个，让我们看看如何

1718
03:10:45,680 --> 03:10:51,540
通过使用我们的尾递归函数来实现此功能，让我们回到我们的代码

1719
03:10:51,540 --> 03:10:59,440
在这里，让我们创建一个叫做 flat map 的函数，我们可以说定义我的 flat map

1720
03:10:59,440 --> 03:11:04,560
这个函数接受两个参数，所以如果我们回到文档，我们可以看到

1721
03:11:04,560 --> 03:11:10,400
这个接受两个参数，第一个参数是元素，第二个参数是

1722
03:11:10,400 --> 03:11:16,360
函数，所以让我们在这里做同样的事情，我们可以说第一个参数是元素

1723
03:11:16,360 --> 03:11:22,760
第二个参数是一个函数，现在我们还需要一个累加器的参数

1724
03:11:22,760 --> 03:11:27,440
因为我们想要做的就是在我们的累加器中收集输出

1725
03:11:28,080 --> 03:11:33,720
所以在这里我们可以说我们也想要一个累加器和一个默认值

1726
03:11:33,720 --> 03:11:40,720
以及一个空列表的默认值现在让我复制粘贴现在让我们考虑一下我们的基本情况

1727
03:11:40,720 --> 03:11:47,120
基本情况非常简单，如果元素是一个空列表，那么我们不需要这个函数

1728
03:11:47,120 --> 03:11:52,340
所以你可以在这里放一个下划线，或者你可以直接用整个函数替换

1729
03:11:52,340 --> 03:11:58,500
只是一个下划线，它们都是有效的语法，在这种情况下，我们只是想返回

1730
03:11:58,500 --> 03:12:04,420
累加器的值，现在让我们再复制粘贴一次，这将是我们的

1731
03:12:04,420 --> 03:12:09,920
递归情况，现在在这种情况下我们也需要我们的函数，并且对于第一个参数

1732
03:12:09,920 --> 03:12:17,160
让我们对头部和尾部进行模式匹配，对于每次迭代我们都想要调用自己

1733
03:12:17,160 --> 03:12:22,520
所以让我们现在调用flat map，如你所知，第一个参数应该是我们的尾部，因为对于

1734
03:12:22,520 --> 03:12:27,880
每次迭代我们都想要取出头部，所以第一个参数变成了尾部，第二个参数变成了头部

1735
03:12:27,880 --> 03:12:33,060
我们的论点是我们想按原样传递函数，我们不想改变函数，现在让我们

1736
03:12:33,060 --> 03:12:39,020
看看我们可以将什么作为第三个参数传递，现在如果你回到我们的文档中，清楚地说明了

1737
03:12:39,020 --> 03:12:45,720
说这是我们的map和concat的组合，所以我们不要动脑筋，让我们遵循

1738
03:12:45,720 --> 03:12:57,500
这些人说的完全一样，所以我们想做的是简单地连接和

1739
03:12:57,500 --> 03:13:05,100
我们想将这个匿名函数应用于头部，现在请记住，由于函数是一个

1740
03:13:05,100 --> 03:13:11,720
匿名函数，我们可以使用点运算符来调用它，所以我们可以说function dot，让我们

1741
03:13:11,720 --> 03:13:18,260
将头部传递给这个函数，就这样我们已经实现了flat map函数，现在让我打开

1742
03:13:18,260 --> 03:13:24,760
我的终端，让我们重新编译tutorials dot list的模块，让我清理屏幕

1743
03:13:24,760 --> 03:13:31,460
让我们做一件事，让我们过来，让我复制所有这些东西，现在在这里面

1744
03:13:31,460 --> 03:13:38,480
在我们的终端中，我们可以说从tutorials dot list dot flat
map，让我们传递参数

1745
03:13:38,480 --> 03:13:45,900
现在让我们试着比较一下输出，这里我们有与之完全相同的输出

1746
03:13:45,900 --> 03:13:50,980
就在这里，这就是我们完成了这一节关于列表的部分

1747
03:13:50,980 --> 03:13:56,240
在这一部分中，我们使用了标准库中的许多函数进行了实现

1748
03:13:56,240 --> 03:14:01,040
在下一个视频中，我们将使用尾递归代替手动编写所有这些函数

1749
03:14:01,040 --> 03:14:06,180
我们将尝试使用标准库中的函数，但现在就是这样

1750
03:14:06,180 --> 03:14:11,820
我会在下一个视频中与你见面，嗨，恭喜你走到了这一步，到目前为止

1751
03:14:11,820 --> 03:14:18,040
我们已经看到了很多递归，具体来说，我们已经看到了很多尾递归，现在整个

1752
03:14:18,040 --> 03:14:24,080
向你展示这么多递归的想法是我希望你习惯递归的概念

1753
03:14:24,080 --> 03:14:29,120
以及我们如何使用函数式编程，但前进时，不再编写所有的

1754
03:14:29,120 --> 03:14:35,480
函数，我们将使用标准库中的函数，现在Elixir附带了

1755
03:14:35,480 --> 03:14:42,180
有很多内置函数，你可以在模块中找到这些函数，比如枚举，然后我们有

1756
03:14:42,180 --> 03:14:47,960
为你的列表和关键字列表等创建单独的模块，这就是我们将要看到的，所以

1757
03:14:47,960 --> 03:14:53,180
本节是关于数据转换的，我们如何使用所有这些函数和方法

1758
03:14:53,180 --> 03:14:59,160
我们可以转换数据以获得我们想要的输出，所以我会在下一个视频中见到你

1759
03:14:59,160 --> 03:15:06,280
那么再见，现在让我们看看我们如何开始使用我们的结构体和内置模块，所以

1760
03:15:06,280 --> 03:15:12,200
我想要做的第一件事是让我们在我们的lib文件夹中创建一个新文件夹，我们可以叫它

1761
03:15:13,240 --> 03:15:20,080
结构体，在这个文件夹里让我再创建一个名为seven wonders的文件

1762
03:15:20,080 --> 03:15:25,580
我折叠我的侧边栏，让我们看看我们可以用这个结构体做什么，第一件事通常是

1763
03:15:25,580 --> 03:15:32,580
我们需要定义我们的模块，所以这将是我们的tutorials. structs. seven
wonders

1764
03:15:32,580 --> 03:15:38,580
所以让我们使用def struct关键字来创建一个结构体，在这里我们需要指定字段

1765
03:15:38,580 --> 03:15:43,640
对于我们的结构体，我们可以说第一个字段是七大奇迹的名称

1766
03:15:44,180 --> 03:15:50,840
而第二个字段将是那个七大奇迹所在的国家，现在我们可以进行一点小改进

1767
03:15:50,840 --> 03:15:56,740
我们还可以在这里初始化这些值，而不仅仅是传递一个普通的列表

1768
03:15:56,740 --> 03:16:04,580
我们可以传递一个关键字列表，所以在这里我们可以说名称的默认值应该是一个空字符串

1769
03:16:04,580 --> 03:16:10,700
对于国家也是一样的情况，所以如果没有给出参数的话

1770
03:16:10,700 --> 03:16:17,060
我们想把国家初始化为空字符串，现在让我们看看如何定义

1771
03:16:17,060 --> 03:16:22,700
我们的结构体的类型规范，现在为了定义我们的结构体的类型，我们必须使用关键字

1772
03:16:22,700 --> 03:16:29,620
类型，所以让我们在这里定义一个类型，让我们把类型称为t，所以这更像是

1773
03:16:29,620 --> 03:16:35,780
你的社区约定，你的t只是代表你的类型，在这里我们可以指定我们想要的

1774
03:16:35,780 --> 03:16:44,080
为我们的tutorials.structs.seven
wonders指定该类型，现在记住，这个结构体

1775
03:16:44,080 --> 03:16:50,200
始终采用模块的名称，这种情况下我们的模块名称是tutorials点

1776
03:16:50,200 --> 03:16:55,940
structs点七个奇迹，因此默认情况下这将是我们结构的名称，既然如此

1777
03:16:55,940 --> 03:17:01,180
这是一个结构体，让我们使用正确的语法，我们需要在这里放置我们的百分号符号和我们的

1778
03:17:01,180 --> 03:17:07,500
大括号，所以现在我们有了一个结构体，现在我们可以做的是输入这样一个长的名称可能很无聊

1779
03:17:07,500 --> 03:17:13,640
所以我们可以简单地起一个别名，让我们创建一个顶部的别名，我们可以说我们只是想要

1780
03:17:13,640 --> 03:17:20,280
创建一个别名，我们可以在这里简单地拿出所有这些东西，现在在大括号里面

1781
03:17:20,280 --> 03:17:26,320
让我们为各个字段定义类型，所以在我们的七个奇迹的结构体中的第一个字段

1782
03:17:26,320 --> 03:17:34,660
是用于名称的，我们可以在这里定义类型为字符串，所以我们可以说字符串点t，所以

1783
03:17:34,660 --> 03:17:40,800
字符串的类型，下一个是用于国家的，同样国家将是字符串的类型

1784
03:17:40,800 --> 03:17:47,870
所以这就是你如何为你的结构体定义类型规范的方法，下面让我们做一个

1785
03:17:47,870 --> 03:17:53,950
让我们创建一个包含世界七大奇迹的列表，所以让我们创建一个简单的函数

1786
03:17:53,950 --> 03:18:00,910
称为all的函数，该函数不接受任何参数，并返回你的列表。现在在函数内部

1787
03:18:00,910 --> 03:18:06,450
在列表中，让我们初始化世界七大奇迹，所以我们可以说第一个奇迹是

1788
03:18:06,450 --> 03:18:12,430
泰姬陵，因为我来自印度，所以第一个必须是泰姬陵，你可以说

1789
03:18:12,430 --> 03:18:17,910
国家是印度，让我复制并粘贴剩下的六个奇迹

1790
03:18:17,910 --> 03:18:23,770
现在我们有了一个包含世界七大奇迹的好列表，接下来让我们看看如何

1791
03:18:23,770 --> 03:18:29,210
为这个新函数编写类型规范，我们可以使用model属性

1792
03:18:29,210 --> 03:18:35,310
根据我们的规范，我们希望为all函数定义规范，现在由于

1793
03:18:35,310 --> 03:18:40,170
这个函数不接受任何参数，你可以使用括号或者跳过它们

1794
03:18:40,170 --> 03:18:46,530
在这里我们还可以定义返回类型，返回类型是一个列表，其中的元素是

1795
03:18:46,530 --> 03:18:51,490
这里我们定义了t的类型，并且指定了不同的参数。

1796
03:18:51,490 --> 03:18:57,630
这是我们引用的结构的参数，让我放一个分隔符。

1797
03:18:57,630 --> 03:19:04,170
在这里滚动一下，让我们看看如何开始使用我们的七个。

1798
03:19:04,170 --> 03:19:10,150
所以我们在这里做一件事，让我们定义一个名为print names的函数，这样

1799
03:19:10,150 --> 03:19:16,290
函数将接受所有的奇观，并简单地打印出它们的名字。

1800
03:19:16,290 --> 03:19:21,470
奇观的名字有很多，比如泰姬陵、佩特拉

1801
03:19:21,470 --> 03:19:26,910
基督救世主等等。所以我希望你为这个函数做的是这个函数

1802
03:19:26,910 --> 03:19:32,590
要接受这个列表，并且我们只想看到名字，就这样

1803
03:19:32,590 --> 03:19:38,690
让我们看看现在如何实现这个函数，这一次不用写函数了

1804
03:19:38,690 --> 03:19:46,370
让我们看看如何使用标准库，让我打开终端，这是第一个

1805
03:19:46,370 --> 03:19:52,950
你想要检查的模块是枚举模块，所以我可以让我们调用帮助函数。

1806
03:19:52,950 --> 03:19:58,910
让我们看一下枚举模块中的不同函数，所以如果我输入一个点并且

1807
03:19:58,910 --> 03:20:05,910
按下tab键，我们可以看到这个内置模块有很多内置函数，现在我想要看一下

1808
03:20:05,910 --> 03:20:13,050
一个非常特定的函数的文档，那就是“for each”函数，所以让我调用一下

1809
03:20:13,050 --> 03:20:20,070
枚举模块的each函数的帮助，这个each函数接受两个参数，第一个参数是

1810
03:20:20,070 --> 03:20:27,070
用于枚举，第二个参数是用于函数，我们还有一个示例实现，所以在这里

1811
03:20:27,070 --> 03:20:34,090
我们可以看到第一个参数是一个列表，我们有一个简单的函数，所以发生的情况是

1812
03:20:34,090 --> 03:20:40,750
对于每次迭代，这个函数从列表中接收一个元素，所以对于第一次迭代

1813
03:20:40,750 --> 03:20:47,490
你的x是字符串"sum"，这个函数所做的就是简单地将它打印出来，这就是为什么

1814
03:20:47,490 --> 03:20:54,550
我们在第二次迭代时得到了"sum"的输出，你的x变成了"example"，这就是正在发生的事情。

1815
03:20:54,550 --> 03:20:59,690
在这里打印出来，让我们看看如何使用这个内置的打印函数

1816
03:20:59,690 --> 03:21:06,030
我们七大奇迹的名称，让我们回到我们的代码编辑器，看看我们能做什么

1817
03:21:06,030 --> 03:21:12,730
我们可以使用相同的函数，我们可以说enum dot each，现在我们的枚举将是我们的奇迹列表

1818
03:21:12,730 --> 03:21:19,730
接下来，让我们定义我们的函数，对于每次迭代的函数，我们将要

1819
03:21:19,730 --> 03:21:26,130
从我们的奇迹列表中接收一个奇迹，所以对于每次迭代，会发生的是

1820
03:21:26,130 --> 03:21:31,830
我们将接收一个奇迹，我们必须对奇迹做些什么，这就是结束

1821
03:21:31,830 --> 03:21:38,190
我们的函数的代码块，由于我们只想打印出我们奇迹的名称，我们实际上可以

1822
03:21:38,190 --> 03:21:44,030
在这里进行模式匹配，现在我们知道这个奇迹将是七个结构体的

1823
03:21:44,030 --> 03:21:53,930
奇迹，我们可以通过使用我们的map语法轻松进行结构体的模式匹配，所以让我们来做一下

1824
03:21:54,650 --> 03:21:59,030
我们想要进行模式匹配，我们想要对name参数进行模式匹配

1825
03:21:59,030 --> 03:22:05,710
而且我们想要将名称收集到一个名为name的变量中，对于每次迭代，我们只需要

1826
03:22:05,710 --> 03:22:12,030
想要将其打印出来，让我们将变量name放在这里，就这样，让我们打开

1827
03:22:12,030 --> 03:22:21,070
打开我们的终端，让我进入我的ix，现在让我为我们的教程创建一个别名，不是结构体

1828
03:22:21,070 --> 03:22:28,070
七大奇迹，让我把一切都搞清楚，这里我们可以说是所有奇迹的列表

1829
03:22:28,070 --> 03:22:34,950
就是我们的七大奇迹，记住我们定义了一个all的函数，现在我们有了所有的

1830
03:22:34,950 --> 03:22:41,050
奇迹，让我再次澄清一下，接下来我们可以做的是再次使用相同的模块

1831
03:22:41,050 --> 03:22:47,950
七大奇迹的，并且我们可以打印出名称，所以这个函数需要一个参数，就是

1832
03:22:47,950 --> 03:22:54,570
所有奇迹的，就是这样，现在我们可以看到我们有了正确的输出，我们回来了

1833
03:22:54,570 --> 03:23:00,470
只是我们的七大奇迹的名称，让我们回到代码编辑器，让我们也定义一下

1834
03:23:00,470 --> 03:23:06,950
这个函数的类型规范，所以在这里我们可以说我们的函数的规范

1835
03:23:06,950 --> 03:23:17,010
打印名称，所以第一个参数是我们所有奇迹的列表，所以我们可以说这是

1836
03:23:17,010 --> 03:23:23,210
现在，由于该函数没有返回任何内容，我们可以说它只返回一个原子

1837
03:23:23,210 --> 03:23:30,370
好的，如果你想的话，你也可以使用管道操作符，所以我可以把这个拿出来

1838
03:23:30,370 --> 03:23:36,370
让我把它放在这一行上，在下一行上让我使用管道操作符，所以默认情况下

1839
03:23:36,370 --> 03:23:43,130
我们的奇迹列表作为函数enum.dot.each的第一个参数传递，让我来

1840
03:23:43,910 --> 03:23:51,250
打开我的终端，让我重新编译一切，让我们尝试运行相同的函数

1841
03:23:51,250 --> 03:23:56,950
再试一次，正如预期的那样，我们得到了正确的答案，接下来让我们看看如何过滤

1842
03:23:56,950 --> 03:24:03,570
从我们的列表中选择一个七大奇迹，所以在这里让我们创建一个新函数，让我给函数命名

1843
03:24:03,570 --> 03:24:09,770
作为按国家过滤，现在这个函数将接受两个参数，第一个参数显然是

1844
03:24:09,770 --> 03:24:15,770
我们所有奇迹的列表，第二个参数是我们想要的国家的名称

1845
03:24:15,770 --> 03:24:22,850
筛选出来的，例如如果国家是印度，那么我们应该得到这个七大奇迹

1846
03:24:22,850 --> 03:24:28,910
那么让我们看看我们如何在这里实现这个筛选函数，让我添加我的do和end块

1847
03:24:28,910 --> 03:24:34,330
让我把这个稍微提高一点，所以让我们再回到我们的终端，看看我们能不能

1848
03:24:34,330 --> 03:24:40,370
在我们的标准库中有一个筛选函数，所以让我再次调用助手文档

1849
03:24:40,370 --> 03:24:46,970
从我们的枚举模块中，让我们看看这个模块是否有一个筛选函数，所以在这里

1850
03:24:46,970 --> 03:24:54,430
我们有一个筛选函数，所以让我们看看这个函数的文档，所以这个函数

1851
03:24:54,430 --> 03:24:59,730
筛选器接受两个不同的参数，第一个显然是我们的枚举类型，第二个参数

1852
03:24:59,730 --> 03:25:06,310
将是一个函数，这里我们有一个示例实现，因此我们可以看到第一个

1853
03:25:06,310 --> 03:25:11,470
元素是一个列表，第二个参数将是一个函数，现在如果我们阅读

1854
03:25:11,470 --> 03:25:18,030
文档中说，这个函数只返回那些符合你的函数的元素

1855
03:25:18,030 --> 03:25:24,790
返回一个布尔值，让我们来看看这个示例中发生了什么，这里有一个条件

1856
03:25:24,790 --> 03:25:30,990
每当这个条件评估为true时，只返回那个值，所以这里我们有一个

1857
03:25:30,990 --> 03:25:37,630
一个由1、2和3组成的列表，这个条件只对2这个元素满足，那就是

1858
03:25:37,630 --> 03:25:43,090
这就是为什么我们会得到一个列表和一个单独的元素2，那么让我们看看如何使用这个内置的

1859
03:25:43,090 --> 03:25:49,370
用于按照我们国家的名称进行过滤的函数，所以这里我们可以使用我们的奇迹列表

1860
03:25:49,370 --> 03:25:57,070
我们可以将这个参数传递给我们的枚举点过滤器，现在再次默认情况下，奇迹的第一个参数是

1861
03:25:57,070 --> 03:26:02,850
会被传递，并且我们只需要为我们的函数传递第二个参数，这个函数

1862
03:26:02,850 --> 03:26:08,950
每次迭代都会接收一个奇迹，所以它的样子就是这样，这里我们需要

1863
03:26:08,950 --> 03:26:14,850
指定一个条件，该条件将评估为true，所以在这里我们可以做的是再次模式匹配

1864
03:26:14,850 --> 03:26:21,730
在这个由七个奇迹组成的结构上进行模式匹配，所以让我们来做这件事，这一次我们只想提取出来

1865
03:26:21,730 --> 03:26:27,450
国家的名称，让我们在国家字段上进行模式匹配，并收集数据。

1866
03:26:27,450 --> 03:26:34,590
在一个名为country name的变量内，接下来我们来看一下我们的条件判断，我们可以说

1867
03:26:34,590 --> 03:26:41,750
我们只想在国家名称等于国家名称时进行过滤，所以这个

1868
03:26:41,750 --> 03:26:47,570
国家是作为参数传递给我们的函数的，就在这里，而这个country的参数

1869
03:26:47,570 --> 03:26:53,650
我们是通过在这里使用我们的模式匹配来提取的country的名称，所以让我保存文件

1870
03:26:53,650 --> 03:27:01,610
让我们打开终端，重新编译七大奇迹的模块，接下来我们可以做的是

1871
03:27:01,610 --> 03:27:08,030
我们可以说我们想要使用七大奇迹的按国家进行过滤，让我们传递所有的奇迹

1872
03:27:08,590 --> 03:27:14,670
接下来让我们传递印度，看看我们得到什么输出，正如预期的那样

1873
03:27:14,670 --> 03:27:20,370
我们发现我们得到了正确的答案，让我们再试一次，试一下

1874
03:27:20,370 --> 03:27:26,170
墨西哥，我们再次得到了正确的答案，所以让我们回到这里

1875
03:27:26,170 --> 03:27:32,850
让我们编写类型规范，以便过滤器按国家进行过滤

1876
03:27:32,850 --> 03:27:40,270
第一个参数是七大奇迹的类型列表，第二个参数是类型

1877
03:27:40,270 --> 03:27:47,690
返回类型是列表，其中包含一个单独的类型，就是这样

1878
03:27:47,690 --> 03:27:52,870
在下一个视频中，我们将继续对我们的结构体进行不同的函数操作，所以让我们

1879
03:27:52,870 --> 03:27:58,370
继续使用我们的结构体，并且在幕后我添加了一些函数

1880
03:27:58,370 --> 03:28:03,790
让我们看看如何实现所有这些函数，所以首先的函数是

1881
03:28:03,790 --> 03:28:09,810
在这里可以看到，这个函数也是关于过滤的，我们只是想要过滤掉

1882
03:28:09,810 --> 03:28:16,130
七大奇迹的国家以i开头，所以让我们看看我们如何做到这一点

1883
03:28:16,130 --> 03:28:23,350
让我复制这个，然后将其粘贴到这里，我稍微处理一下所有这些东西

1884
03:28:23,350 --> 03:28:30,070
所以在这种情况下，我们的真值函数将发生变化，我们只是想要比较这些值并检查是否

1885
03:28:30,070 --> 03:28:35,750
这个国家的名字是以i开头还是不以i开头，让我把这个去掉，这次我们可以

1886
03:28:35,750 --> 03:28:41,590
将变量名从country name改为只是country，让我们看看我们如何比较

1887
03:28:41,590 --> 03:28:48,290
我们字符串的第一个字母是i，为此让我们使用另一个模块，模块的名称是

1888
03:28:48,290 --> 03:28:55,310
将是字符串，并且这个模块有一个非常方便的函数starts with，如果我悬停在上面

1889
03:28:55,310 --> 03:29:00,450
在函数定义上方，我们可以看到这个函数接受两个不同的参数，所以它们

1890
03:29:00,450 --> 03:29:06,930
这里有一个例子elixir和eli，所以在这种情况下，elixir以eli开头，这就是为什么我们

1891
03:29:06,930 --> 03:29:13,890
得到答案为true，所以第一个参数将是我们的国家，第二个参数将是

1892
03:29:13,890 --> 03:29:21,770
i，所以让我再次打开终端，重新编译我们的七大奇迹模块，让我

1893
03:29:21,770 --> 03:29:28,090
清理一切，现在让我们调用这个函数，这样我们就可以说七大奇迹点国家

1894
03:29:28,090 --> 03:29:35,550
以i开头，让我们把所有的奇迹都传递给它，正如预期的那样，我们得到了两个奇迹

1895
03:29:35,550 --> 03:29:41,650
所以第一个奇迹是在印度制造的，第二个奇迹是在意大利制造的，下一个函数是

1896
03:29:41,650 --> 03:29:47,330
按国家长度排序，哦，在继续之前，让我们也为这个添加类型规格

1897
03:29:47,330 --> 03:29:54,270
规格非常简单，这些奇迹是我们的t型列表

1898
03:29:54,270 --> 03:30:02,210
这也返回一个t型列表，好吧，现在让我们去这个排序函数

1899
03:30:02,210 --> 03:30:08,430
所以这一次我们想做的是，我们只是想按长度对所有的奇迹进行排序

1900
03:30:09,190 --> 03:30:16,150
所以让我们看看我们如何做到这一点，如果我回到我的终端，让我们来看看枚举

1901
03:30:16,150 --> 03:30:23,110
点排序，所以我们在枚举模块内有一个方便的排序函数，正如你所看到的

1902
03:30:23,110 --> 03:30:29,150
有很多文档，但我想向您展示一些关键参数，所以这是

1903
03:30:29,150 --> 03:30:35,570
排序函数，这个函数接受两个参数，第一个是枚举，第二个是

1904
03:30:35,570 --> 03:30:42,690
是一个排序器，现在这个排序器参数可以是多种类型，所以让我们参考官方的说明

1905
03:30:42,690 --> 03:30:48,230
这个函数的规格，让我们试着找出来。第一个显然是你的。

1906
03:30:48,230 --> 03:30:54,530
现在对于 sorter 的第二个参数，我们可以看到我们可以传递多个参数。

1907
03:30:54,530 --> 03:31:00,010
所以这个规格是在说，我们可以传递一个函数，这个函数接收

1908
03:31:00,010 --> 03:31:06,270
两个元素，这个函数必须返回一个布尔值，或者你可以选择传递

1909
03:31:06,270 --> 03:31:11,690
这些参数也是如此，现在让我们看看我们如何处理这个，这是一个非常简单的

1910
03:31:11,690 --> 03:31:19,070
我们可以传递给我们的 enum.sort 的函数，所以让我们回到我们的代码编辑器，再次

1911
03:31:19,070 --> 03:31:26,290
使用 wonder 的参数，然后将其传递给我们的 enum.sort，现在让我们看看

1912
03:31:26,290 --> 03:31:32,770
定义 sorter 函数，这将是你的常规函数，现在对于每次迭代

1913
03:31:32,770 --> 03:31:39,150
这个函数将接收两个不同的 wonders，所以我们可以称它们为 x 和 y，接下来

1914
03:31:39,150 --> 03:31:45,590
对于函数的主体，我们可以简单地说我们想检查字符串的长度

1915
03:31:45,590 --> 03:31:52,630
第一个，我们来比较这个长度是否小于下一个奇迹的长度

1916
03:31:52,630 --> 03:31:58,450
所以我们可以再次使用相同的函数string.length，并让我们传递变量y

1917
03:31:58,450 --> 03:32:03,630
所以我们所做的是定义了一个函数，对于每次迭代，这个函数

1918
03:32:03,630 --> 03:32:08,990
接收两个不同的奇迹，我们只是尝试比较这些奇迹的长度

1919
03:32:08,990 --> 03:32:16,310
就是这样，让我保存文件，打开终端，再次重新编译

1920
03:32:16,990 --> 03:32:23,670
让我们尝试调用这个函数sevenwonders.sort按国家长度排序，并让我们传递

1921
03:32:23,670 --> 03:32:30,550
所有的奇迹，哦，我们遇到了一个错误，那是因为我们在这里试图找到

1922
03:32:30,550 --> 03:32:36,350
整个结构体的长度，我忘记了指定我们想要检查的参数的长度

1923
03:32:36,350 --> 03:32:42,330
国家的名称，对于这个结构体也是一样的，所以我们要检查

1924
03:32:42,850 --> 03:32:51,070
这个国家，现在让我保存文件，打开终端，让我重新编译一次，清理一下

1925
03:32:51,070 --> 03:32:57,230
屏幕上让我们再试一次调用这个函数，这次如您所见我们有

1926
03:32:57,230 --> 03:33:03,130
一个漂亮的排序列表，所以现在您可以看到列表按照国家的长度进行了排序

1927
03:33:03,130 --> 03:33:09,250
名称是秘鲁，这是四个字符长，所以这是第一个，接下来是中国，这是五个

1928
03:33:09,790 --> 03:33:16,410
然后我们有意大利和印度，然后我们有巴西等等，所以您可以看到我们有一个

1929
03:33:16,410 --> 03:33:21,750
漂亮的排序列表，所以现在让我们回去看看我们想对下一个做什么

1930
03:33:21,750 --> 03:33:28,090
所以对于名称国家列表的下一个函数，这个函数接受我们的奇迹，我希望

1931
03:33:28,090 --> 03:33:34,690
一个像这样的输出，所以输出必须是列表，列表中又有另一个列表

1932
03:33:34,690 --> 03:33:40,530
第一个元素必须是七大奇迹的名称，第二个名称必须是国家

1933
03:33:40,530 --> 03:33:46,190
所以让我们看看我们如何做到这一点，让我去掉注释，我不需要注释

1934
03:33:46,730 --> 03:33:52,490
在我展示这个之前，让我带您回到我的终端，并让我清理所有这些

1935
03:33:52,490 --> 03:33:58,970
事情和这次让我们查看 enum dot reduce 的文档，现在这个

1936
03:33:58,970 --> 03:34:05,650
reduce 这是一个非常强大的函数，实际上你可以在里面实现所有的函数

1937
03:34:05,650 --> 03:34:11,310
enum 模块只需使用这个简单的函数，所以让我们先看看这个函数

1938
03:34:11,310 --> 03:34:17,910
签名，因此这个 reduce 函数接受三个参数，第一个参数是你的 enum

1939
03:34:17,910 --> 03:34:24,470
第二个参数是你的累加器，第三个参数是你的函数，我们

1940
03:34:24,470 --> 03:34:31,350
一个示例就在这里，所以第一个参数是一个列表，第二个参数是

1941
03:34:31,350 --> 03:34:36,970
累加器，第三个参数你在这里可以看到，这是一个函数，现在这个

1942
03:34:36,970 --> 03:34:43,670
函数在每次迭代中接收一个元素，这个函数还接收累加器

1943
03:34:43,670 --> 03:34:49,630
因此，对于第一次迭代，由于累加器是零，这将是零，并且对于第一次

1944
03:34:49,630 --> 03:34:56,390
迭代，我们的 x 将为一，现在这个函数会发生什么，结果会被传递

1945
03:34:56,390 --> 03:35:02,350
作为下一次迭代的累加器，所以您可以在这里阅读文档。

1946
03:35:02,350 --> 03:35:07,970
发生什么事情，所以对于第二次迭代，无论这个值评估为何，这个值将会

1947
03:35:07,970 --> 03:35:13,910
成为您的新累加器，让我们看看这个reduce函数的实际效果，让我们回到

1948
03:35:13,910 --> 03:35:19,830
代码编辑器，现在让我们看看如何使用reduce函数，因此我们可以说enum点

1949
03:35:19,830 --> 03:35:26,470
reduce的第一个参数是我们的wonders，第二个参数将是我们的累加器

1950
03:35:26,470 --> 03:35:32,890
因此，作为我们的初始累加器，我们只需传递一个空列表，第三个参数将是一个

1951
03:35:32,890 --> 03:35:41,230
函数，现在让我做一件事，让我把这个拿出来，让我们管道到我们的enum点reduce

1952
03:35:41,230 --> 03:35:47,050
现在，对于每次迭代，此函数将接收两个参数，第一个参数是

1953
03:35:47,050 --> 03:35:52,690
将是我们的wonder，第二个参数将是我们的累加器，所以最初的

1954
03:35:52,690 --> 03:35:58,190
累加器将是一个空列表，对于每次迭代，我们想做什么，我们只需简单地

1955
03:35:58,190 --> 03:36:04,850
想要在这个列表内创建一个列表，我们需要另一个列表，在这个内部列表内，第一个

1956
03:36:04,850 --> 03:36:09,610
参数将是奇迹的名称，第二个参数将是奇迹的国家

1957
03:36:09,610 --> 03:36:16,330
所以在这里我们可以说，从奇迹中，我只想要你提取名称，第二个参数是

1958
03:36:16,330 --> 03:36:22,570
将成为这个奇迹的国家，之后我们只想要将其添加到累加器中

1959
03:36:22,570 --> 03:36:29,950
然后就是这样了，让我保存文件，打开终端，重新编译模块

1960
03:36:29,950 --> 03:36:36,550
然后让我清屏，让我们调用这个函数，我们可以说七大奇迹点

1961
03:36:36,550 --> 03:36:43,810
country list，让我们传递所有的奇迹，正如预期的那样，我们得到了答案，所以在这里

1962
03:36:43,810 --> 03:36:49,630
我们可以看到第一个参数将是奇迹的名称，后面是奇迹的名称

1963
03:36:49,630 --> 03:36:55,430
现在，只是为了给你更多的练习，让我们再试试使用这个reduce函数

1964
03:36:55,430 --> 03:37:01,210
这次，对于这个函数，在这里是国家名称关键字列表，所以这就是我想让你做的事情

1965
03:37:01,210 --> 03:37:08,150
所以这个函数将接受我们的奇迹，这是我期望的输出，所以我们

1966
03:37:08,150 --> 03:37:13,890
想要一个列表，在列表内部我们想创建我们的关键字列表，所以你可以看到这是

1967
03:37:13,890 --> 03:37:19,890
将是一个原子，这将是值，所以让我将所有这些东西复制一遍

1968
03:37:19,890 --> 03:37:27,110
让我复制这个，然后粘贴到这里，我不需要这个注释，让我拿走

1969
03:37:27,110 --> 03:37:33,450
看看我们如何使用这个函数，现在我想做的是

1970
03:37:33,450 --> 03:37:41,550
不想要一个内部列表，我们想要一个元组，所以让我将其从列表改为元组

1971
03:37:41,550 --> 03:37:47,990
让我解释为什么我想要一个元组，让我打开我的终端，例如，如果我们有一个

1972
03:37:47,990 --> 03:37:54,850
像这样的关键字列表 a 和 one，所以这个关键字列表实际上被保存为我们元组的列表

1973
03:37:54,850 --> 03:37:59,990
所以如果我必须进行模式匹配，那么在左侧让我们创建一个更多的列表

1974
03:37:59,990 --> 03:38:06,310
在这里，如果我创建一个元组，第一个元素将是 a 的项，第二个元素

1975
03:38:06,310 --> 03:38:12,690
将是一个的值，让我们看看是否是一个模式匹配，是的，这是一个

1976
03:38:12,690 --> 03:38:18,810
模式匹配，所以发生的情况是这个关键字列表保存在这个格式中，我想我有

1977
03:38:18,810 --> 03:38:24,130
在解释关键字列表时也有涵盖到，所以这是一个小回顾给你，这就是

1978
03:38:24,130 --> 03:38:29,570
相同的逻辑，我们在这里使用的原因，这就是为什么我们想要一个元组而不是一个

1979
03:38:29,570 --> 03:38:36,050
内部列表，现在第一个元素必须是一个原子，所以我可以做的是让我抓住这个内部

1980
03:38:36,050 --> 03:38:43,910
我们可以通过使用字符串点到原子来将这个字符串转换为原子，现在就是这样

1981
03:38:43,910 --> 03:38:51,190
让我再次打开终端，让我们重新编译我们的模块，让我清理屏幕并让

1982
03:38:51,190 --> 03:38:57,870
我们尝试调用这个函数七个奇迹点国家名字关键字列表，让我们传递

1983
03:38:57,870 --> 03:39:03,470
所有奇迹的参数，所以这次你可以看到第一个参数将是

1984
03:39:03,470 --> 03:39:09,610
我们的原子，值将是国家的名字，现在在进入最后一个函数之前

1985
03:39:09,610 --> 03:39:16,330
我想给你展示一些东西，所以再让我打开终端，清除所有的

1986
03:39:17,050 --> 03:39:23,570
所以，如果我们只想列出奇迹的名称，我们可以使用多个模块

1987
03:39:23,570 --> 03:39:30,310
所以，让我再展示给你一种替代方法。我们可以使用`enum.map`，第一个参数

1988
03:39:30,310 --> 03:39:36,670
将成为我们所有奇迹的参数，我们可以简单地调用一个

1989
03:39:36,670 --> 03:39:46,310
函数。这个函数每次接收一个奇迹，我们只需要做的是

1990
03:39:46,310 --> 03:39:52,730
获取所有的名字。现在，Elixir实际上提供了一种简写语法，所以我们可以

1991
03:39:52,730 --> 03:39:59,130
做的是将这个函数改成简写语法，我们可以说我们想要

1992
03:39:59,130 --> 03:40:04,870
发送一个匿名函数的引用，这个函数将接收一个参数，所以

1993
03:40:04,870 --> 03:40:11,230
我们可以说对于第一个参数，我们只需要返回名称，就这样。所以这是

1994
03:40:11,230 --> 03:40:17,490
简写语法，我们得到完全相同的答案。所以如果你感觉舒服，你可以使用这个

1995
03:40:17,490 --> 03:40:23,350
速记语法，或者您可以使用常规语法，现在是这个视频的最后一部分。

1996
03:40:23,350 --> 03:40:29,550
想向您展示 Elixir 内的四种理解，我们可以通过使用相同的输出得到完全相同的结果。

1997
03:40:29,550 --> 03:40:35,830
这四个理解，因此我们可以说对于每次迭代，我们只需

1998
03:40:35,830 --> 03:40:42,570
想要进行模式匹配，并且我们想要将名称提取到一个名为 name 的变量中，并且我们想要

1999
03:40:42,570 --> 03:40:48,850
从我们的奇迹列表中提取出这个，对于每次迭代，我只想返回

2000
03:40:48,850 --> 03:40:56,270
奇迹的名字，就这样，我们得到了完全相同的结果，现在这个语法是

2001
03:40:56,270 --> 03:41:02,190
有点奇怪，所以我们想要做的是，我们想要说对于每个元素来说

2002
03:41:02,190 --> 03:41:08,610
我们想要对 enum 进行模式匹配，并且我们想要在 name 上进行模式匹配，并且对于每次迭代

2003
03:41:08,610 --> 03:41:14,570
我们只想简单地将名称返回，因此您可以使用您感觉舒适的任何语法

2004
03:41:14,570 --> 03:41:21,090
更舒适，现在让我复制这个，然后让我回到我的代码编辑器，所以对于这个

2005
03:41:21,090 --> 03:41:27,750
让我们使用这四个理解，我把它粘贴在这里，我们还需要传递一个参数

2006
03:41:28,360 --> 03:41:36,470
所以这个参数变成了我们的奇迹，这也需要改成奇迹，现在让我打开

2007
03:41:36,470 --> 03:41:43,450
我的终端让我重新编译模块，让我清理一下这个，让我们尝试运行一下

2008
03:41:43,450 --> 03:41:52,150
所以七个奇迹.全部名称 哦，我忘记传递参数了，所以全部名称和参数是

2009
03:41:53,190 --> 03:41:59,110
奇迹，我们得到了完全相同的答案，好了，这个视频就这样，下次见

2010
03:41:59,110 --> 03:42:05,230
在下一个视频里见，让我们再多练习一下我们的结构体，所以我做的是在背后

2011
03:42:05,230 --> 03:42:12,190
幕后，我创建了一个名为expense的新文件，让我们开始吧，首先

2012
03:42:12,190 --> 03:42:19,510
像往常一样，让我们创建我们的模块，让我将这个模块命名为tutorials.structs.expense

2013
03:42:20,270 --> 03:42:26,850
现在想象一下，我们正在创建一个管理费用的应用程序，让

2014
03:42:26,850 --> 03:42:33,990
我们定义一个结构体来保存我们的费用，所以我们可以说我们想定义一个结构体，而且这个

2015
03:42:33,990 --> 03:42:39,590
结构体将有多个字段，让我将它们放在不同的行上，所以第一个字段

2016
03:42:39,590 --> 03:42:45,050
将用于我们的费用标题，我们可以将标题初始化为空字符串

2017
03:42:45,610 --> 03:42:50,570
第二个是我们的费用日期，起初我们可以将其保持为

2018
03:42:50,570 --> 03:42:56,850
nil 接下来是我们的费用金额，让我们将金额初始化为

2019
03:42:56,850 --> 03:43:02,590
零 接下来是我们购买的商店，让我们将商店初始化为

2020
03:43:02,590 --> 03:43:10,170
也是一个空字符串，现在让我们为我们的结构体定义类型，首先让我创建

2021
03:43:10,970 --> 03:43:20,630
因此，我想为我的教程中的结构体创建一个别名，并在这里让我们定义

2022
03:43:20,630 --> 03:43:29,810
此字段的类型，因此我们可以说对于我们的费用结构体的t类型，标题的第一个字段

2023
03:43:29,810 --> 03:43:38,270
因此，它将是字符串类型，第二个是日期，我们可以指定

2024
03:43:38,270 --> 03:43:46,870
类型将是日期类型，或者也可以是nil，下一个是金额的类型

2025
03:43:46,870 --> 03:43:54,450
所以这将是一个数字，下一个是给商店的，这将是某种类型的

2026
03:43:54,450 --> 03:44:01,370
字符串，现在我们已经有了类型规范，现在让我们看看如何处理我们的

2027
03:44:01,370 --> 03:44:08,150
首先，让我创建一些示例费用，所以让我定义，所以让我定义

2028
03:44:08,150 --> 03:44:14,110
一个名为示例的函数，这个函数将简单地返回一些我们的费用

2029
03:44:14,650 --> 03:44:18,870
让我们在这里创建一个费用，所以我们可以说我们想要创建一个

2030
03:44:18,870 --> 03:44:27,070
费用，现在对于标题，我们可以说我们买了一些杂货，下一个字段是日期

2031
03:44:27,070 --> 03:44:33,810
现在这个类型必须是日期，所以让我进入我的终端，然后让我

2032
03:44:33,810 --> 03:44:40,250
向您展示如何创建日期，elixir有一个日期模块，所以我们可以使用该模块

2033
03:44:40,250 --> 03:44:46,290
让我给你看，让我们检查一下该模块的文档，这样我们就可以说我们想要查看

2034
03:44:46,290 --> 03:44:54,010
日期点新的帮助文档，正如您所见，这个 new 函数接受一个年份

2035
03:44:54,010 --> 03:45:01,830
月份和日期，让我们试试这个，让我把一切弄清楚，所以在这里我们可以创建一个新的

2036
03:45:01,830 --> 03:45:08,090
日期，所以我们可以说日期点新的，第一个参数是年份，所以我们可以说

2037
03:45:08,090 --> 03:45:16,130
2023年，下一个参数是月份，所以我们可以说四月，日期我们可以说

2038
03:45:16,130 --> 03:45:23,950
四月一号，就是这样我们得到了一个日期，但是正如你所看到的，我们得到了一个回归的复数

2039
03:45:23,950 --> 03:45:29,730
所以让我们进行模式匹配并提取日期，我们可以做的就是在左手边

2040
03:45:29,730 --> 03:45:36,210
让我进行模式匹配，第一个元素将是项目，让我们创建一个

2041
03:45:36,210 --> 03:45:42,910
日期的变量，让我们看看日期的内容，就这样我们有了一个新的

2042
03:45:43,590 --> 03:45:49,930
现在你可以在这里看到的语法是这个符号和d，这也表示一个日期，事实上

2043
03:45:49,930 --> 03:45:55,170
我们可以使用这个语法来创建一个新的日期，我们不必总是调用日期函数

2044
03:45:55,170 --> 03:46:00,950
点新的，所以我们可以创建一个 sigil，这是 sigil 的标志，让我们

2045
03:46:00,950 --> 03:46:08,090
为我们的日期创建一个标记，这里我们可以说年份必须是2023年，月份可以是

2046
03:46:08,090 --> 03:46:15,370
日期可以是3月31日，就这样，我们有了一个新的日期，现在让我们回到

2047
03:46:15,370 --> 03:46:20,930
到结构体中，让我们在这里创建一个日期，让我在这里使用标记，这样我可以说

2048
03:46:20,930 --> 03:46:28,670
我想创建一个日期，假设我的年份是2023年，月份可以是九月，假设

2049
03:46:28,670 --> 03:46:36,390
日期是9月12日，接下来是金额，假设金额是18.99，假设商店是

2050
03:46:36,390 --> 03:46:42,770
地铁，所以现在我们已经创建了一个费用，现在让我只是复制和粘贴一堆

2051
03:46:42,770 --> 03:46:49,470
更多的费用，就这样，让我打开我的终端，让我清理所有这些东西

2052
03:46:49,470 --> 03:46:58,110
让我们进入ix，让我为我的教程.结构.费用创建一个别名

2053
03:46:58,110 --> 03:47:04,070
让我再清理一次，让我们为我们的样本费用创建一个变量，这样我们就可以说

2054
03:47:04,070 --> 03:47:10,770
我的样本费用等于我的费用.样本函数，所以现在我们有了一堆

2055
03:47:10,770 --> 03:47:17,790
在样本的基础上，让我们回到代码编辑器，看看我们可以如何处理我们的开支

2056
03:47:17,790 --> 03:47:24,550
哦，在那之前，让我们为这个添加类型规范，这样我们可以指定

2057
03:47:24,550 --> 03:47:31,730
我们的样本的规范，这个不接受任何参数，返回一个列表

2058
03:47:31,730 --> 03:47:37,330
接下来，让我们编写一个函数来获取我们刚刚定义的 t 的总金额

2059
03:47:37,330 --> 03:47:43,470
我们已经花费了多少，我们可以说这个函数是我们的总金额，这个函数接受

2060
03:47:43,470 --> 03:47:49,970
我们的开支，让我们定义这个函数的主体，这个开支将是一个列表

2061
03:47:49,970 --> 03:47:55,370
我们所有的开支，例如，如果我们获得这些开支，我们只是想把所有的

2062
03:47:55,370 --> 03:48:00,550
金额加在一起，我们想返回总金额，让我们看看我们怎么做

2063
03:48:00,550 --> 03:48:05,890
让我把这些事情稍微提高一点，现在你可以通过使用多种方法来解决这个问题，但是

2064
03:48:05,890 --> 03:48:12,450
我将使用枚举点减少，所以让我先拿出开支，然后让我引用开支

2065
03:48:12,450 --> 03:48:19,170
在枚举dot reduce中，现在为了这个reduce函数，让我们定义一个累加器，假设

2066
03:48:19,170 --> 03:48:26,070
我的初始累加器是零，下一个是函数，现在对于每次迭代

2067
03:48:26,690 --> 03:48:32,790
有两个参数，第一个是expense，第二个是累加器，对于每次迭代

2068
03:48:32,790 --> 03:48:39,930
每次迭代，我只是想去我的expense，取出金额，然后将该金额加到我的累加器中

2069
03:48:39,930 --> 03:48:46,690
就是这样，现在让我们返回终端，重新编译我们的expense，让我清理一下

2070
03:48:46,690 --> 03:48:53,510
现在让我们调用这个函数，所以我们可以说expense点，让我们得到total for

2071
03:48:53,510 --> 03:49:01,530
示例，我们得到的答案是1025.62，让我们回去，让我们也写一下类型

2072
03:49:01,530 --> 03:49:07,970
这个函数的规格是，total函数接受一个类型为t的列表

2073
03:49:07,970 --> 03:49:13,490
并且返回一个数字，所以如果你悬停在数字上，你会看到你的数字可以是整数或浮点数

2074
03:49:13,490 --> 03:49:20,330
可以是整数或浮点数，接下来，让我们编写一个按日期对我们的expenses进行排序的函数

2075
03:49:20,330 --> 03:49:26,150
我们可以说我们想要定义一个函数，这个函数接受我们的费用清单。

2076
03:49:26,150 --> 03:49:32,450
现在让我们看看如何对列表进行排序，所以在上个视频中我们已经看过如何对列表进行排序了。

2077
03:49:32,450 --> 03:49:38,410
但这次我们想按日期排序，所以让我带你回到我的终端，让我们看看。

2078
03:49:38,410 --> 03:49:45,730
我们的枚举点排序的文档，上次我们使用了排序，但我们还有一个函数。

2079
03:49:45,730 --> 03:49:51,110
排序的名字，现在让我们看看这个的文档，让我稍微。

2080
03:49:51,110 --> 03:49:57,370
向上滚动，在这里他们有一个例子，其中他们使用日期，例如他们有一个。

2081
03:49:57,370 --> 03:50:02,910
不同地图的列表，每个地图都有一个日期字段，这是他们的做法。

2082
03:50:02,910 --> 03:50:08,750
对日期进行排序，所以第一个参数显然是你的枚举类型，第二个参数他们在使用。

2083
03:50:08,750 --> 03:50:13,570
这是一种缩写的语法，你可以使用你的常规函数，他们想要说的是

2084
03:50:13,570 --> 03:50:19,730
对于每次迭代，他们想按生日排序，所以让我们使用这种缩写语法。

2085
03:50:19,730 --> 03:50:25,310
让我们来看看如何对日期进行排序，首先让我拿出我的所有开销

2086
03:50:25,310 --> 03:50:32,310
然后让我将所有这些东西传送到我的enum dot sort by中，并且让我们使用简写语法

2087
03:50:32,310 --> 03:50:38,010
因此，我们可以说我想要给一个匿名函数的引用，并且对于每个迭代

2088
03:50:38,010 --> 03:50:45,590
我想按日期排序，让我们打开终端，重新编译我们的开销，让我来

2089
03:50:45,590 --> 03:50:51,550
清除屏幕，这里我们可以说dot expense dot sort by date，让我们传递

2090
03:50:51,550 --> 03:50:57,270
我们的样本列表，让我们看看发生了什么，所以在这里你可以看到日期已经排序了

2091
03:50:57,270 --> 03:51:05,390
最后一个是10月30日，之前的一个是10月18日，所以这个是9月份的

2092
03:51:05,390 --> 03:51:11,990
这个是7月份的，所以我们有一个按升序排列的漂亮列表，以防万一

2093
03:51:11,990 --> 03:51:16,110
如果您想更改顺序，可以参考文档，是的，他们在说

2094
03:51:16,110 --> 03:51:22,010
以防万一你想要降序，你也可以添加这些参数，让我们回去吧，让我们

2095
03:51:22,010 --> 03:51:30,050
为这个函数编写规范，按日期排序，所以这个函数接受类型为 t 的列表。

2096
03:51:30,050 --> 03:51:36,810
这个函数也返回相同类型的 t 列表，接下来让我们看看如何向列表中添加一个 expense。

2097
03:51:36,810 --> 03:51:43,050
我们的 expense 列表，所以让我们定义一个名为 add expense
的函数，它接受一个单独的 expense。

2098
03:51:43,050 --> 03:51:50,290
然后让我们编写函数的主体，这将是一个非常简单的函数。

2099
03:51:50,290 --> 03:51:56,950
我们只需要获取 expense，然后将其追加到我们现有的列表中。

2100
03:51:56,950 --> 03:52:03,230
对于这个函数，我想向你展示一个小技巧，以防你想要强制执行。

2101
03:52:03,230 --> 03:52:09,230
这个 expense 必须是 expense 结构体类型的，我们可以做的就是

2102
03:52:09,230 --> 03:52:14,890
简单地在这里使用模式匹配，我们可以说我们想要进行模式匹配。

2103
03:52:14,890 --> 03:52:21,800
我们的 expense 结构体，所以我们要强制执行类型的。

2104
03:52:21,800 --> 03:52:28,260
参数必须是我们结构体的类型，让我们也为这个函数添加规范。

2105
03:52:28,260 --> 03:52:37,600
我们可以说我们的add expense函数接受t类型，并返回一个列表，这个列表包含

2106
03:52:37,600 --> 03:52:43,860
再者，我们还需要打开终端，重新编译我们的模型

2107
03:52:43,860 --> 03:52:49,740
现在让我把一切都弄清楚，首先让我创建一个expense，让我们创建一个变量

2108
03:52:49,740 --> 03:52:55,980
为我们的expense初始化结构体，所以这里我们要说我们的expense假设

2109
03:52:55,980 --> 03:53:03,220
我们想买一些咖啡，假设日期是4月1日，这样我们就可以

2110
03:53:03,220 --> 03:53:08,640
使用sigil，我们可以说我们想要一个日期的sigil，日期将是2023年

2111
03:53:08,640 --> 03:53:14,980
月份是4月，日期是4月1日，假设金额是

2112
03:53:14,980 --> 03:53:23,080
假设我们从地铁买了这个，现在我们有了一个expense，现在让我们试着添加

2113
03:53:23,080 --> 03:53:29,300
这个expense，所以我们可以说expense.add(our
expense)，让我们传递新创建的expense

2114
03:53:30,080 --> 03:53:34,740
然后我们会得到一个答案，所以让我们看看这个列表中是否有咖啡

2115
03:53:36,700 --> 03:53:43,460
所以是的，正如我们所看到的，第一项是咖啡，所以我们已经将我们的费用添加到列表中了。

2116
03:53:43,460 --> 03:53:48,460
让我们回去看看我们还能做什么，让我们看看我们如何更新单个

2117
03:53:48,460 --> 03:53:54,680
在我们的费用清单中的项目，例如，让我们看看如何更新金额

2118
03:53:54,680 --> 03:53:59,440
特定的费用，所以让我们创建一个函数，然后我们称之为更新金额的函数

2119
03:53:59,440 --> 03:54:05,560
现在，这个函数将接受两个参数，第一个参数是我们费用的标题

2120
03:54:05,560 --> 03:54:10,980
第二个可以是金额，因此是更新的金额，让我们看看如何编写函数体

2121
03:54:11,520 --> 03:54:18,040
所以例如，我想要做的是假设我们在购买日用品，并且我们想要更新

2122
03:54:18,040 --> 03:54:25,760
金额从18.99美元更新为20美元，所以让我们看看如何做到这一点，要更新金额，我们需要

2123
03:54:25,760 --> 03:54:31,320
要做一些事情，首先我们需要筛选出我们想要的费用

2124
03:54:31,320 --> 03:54:36,560
要更新的第二步是我们要创建一个带有更新金额的新费用，因为

2125
03:54:36,560 --> 03:54:42,300
请记住，Elixir 中的所有数据类型都是不可变的，第三个是我们只想添加

2126
03:54:42,300 --> 03:54:47,940
将这个费用添加到我们的样本中，我们想要删除旧的条目，所以让我们看看我们如何做到这一点

2127
03:54:47,940 --> 03:54:54,120
所以第一步是使用给定的标题筛选出确切的费用

2128
03:54:54,120 --> 03:55:00,260
我们想要使用 enum dot filter，第一个参数是我们的样本费用

2129
03:55:00,260 --> 03:55:05,220
将样本的函数传递到这里，接下来我们必须在这里定义一个函数，让我来使用

2130
03:55:05,220 --> 03:55:11,980
函数和 end，对于每次迭代，该函数接收一个单一的费用，所以让我们

2131
03:55:11,980 --> 03:55:18,900
在费用标题上进行模式匹配，所以我们可以说我们想要提取标题，我们想要

2132
03:55:18,900 --> 03:55:25,940
在一个新变量中捕获标题，让我们将变量命名为 expense title，对于每个

2133
03:55:25,940 --> 03:55:32,980
迭代中，我们只需要检查费用标题是否等于给定的标题，所以这个标题

2134
03:55:32,980 --> 03:55:38,280
来自函数定义，就在这里，我们还需要记录这个费用

2135
03:55:38,280 --> 03:55:44,420
所以如果你只是将鼠标悬停在过滤器上，我们可以看到结果是一个列表，所以让我们进行模式匹配。

2136
03:55:44,420 --> 03:55:50,580
让我们提取那个支出，在左边让我们进行模式匹配，并且让我们创建。

2137
03:55:50,580 --> 03:55:56,780
让我们创建一个名为item的变量，这个变量将保存我们的支出，同时创建一个新的列表。

2138
03:55:56,780 --> 03:56:02,100
刚刚筛选完成后的下一步是创建一个新的支出，所以我们可以说我们想要创建。

2139
03:56:02,100 --> 03:56:08,460
为新项目创建一个变量，并通过更新此项目来创建一个新的支出，所以我们可以说。

2140
03:56:08,460 --> 03:56:16,080
对于我的项目结构，我想要根据新的金额更新金额，所以这个金额来自于。

2141
03:56:16,080 --> 03:56:21,520
函数定义就在这里，所以现在我们有了新的金额，最后我们只需要。

2142
03:56:21,520 --> 03:56:27,860
将新项目添加到我们的样本列表中，但是在添加之前，我们还需要删除。

2143
03:56:28,240 --> 03:56:34,400
从我们的样本列表中删除，但是我们可以在一个地方的一条语句中完成所有这些事情。

2144
03:56:34,400 --> 03:56:40,520
所以让我向你展示我们如何做到这一点，我们可以说我们想要将新项目添加到。

2145
03:56:40,520 --> 03:56:46,780
我们的样本列表，但在我们追加之前，我们还需要删除旧条目，所以我们需要

2146
03:56:46,780 --> 03:56:52,880
我们可以简单地将样本的输出传送到一个新的函数中，我们可以这样说

2147
03:56:52,880 --> 03:56:59,460
list.delete，然后让我将旧项目传递给这个函数，就是这样，那么会发生什么呢

2148
03:56:59,460 --> 03:57:05,120
首先，我们将从样本列表中删除该条目，然后将新的条目

2149
03:57:05,120 --> 03:57:11,120
追加到列表中，现在让我打开终端，像往常一样，让我们重新编译

2150
03:57:11,120 --> 03:57:18,020
我们的开销，让我清理屏幕，让我们尝试调用这个函数 expense.update

2151
03:57:18,020 --> 03:57:25,560
现在，例如，我们想将我们的杂货金额从18.99更新为30美元

2152
03:57:25,560 --> 03:57:31,500
让我们检查一下我们是否已经更新了金额，是的，所以这是杂货的条目

2153
03:57:31,500 --> 03:57:38,040
新金额是13，所以让我们回去，到目前为止，我们已经看到了很多不同的方式

2154
03:57:38,040 --> 03:57:43,000
我们可以使用我们的结构来工作，我们已经看到了如何使用递归和如何

2155
03:57:43,000 --> 03:57:49,100
现在使用内置模块，对于此视频的最后一部分，我想向你展示with。

2156
03:57:49,100 --> 03:57:55,320
语句，例如我们可能需要处理多个条件，例如

2157
03:57:55,320 --> 03:58:01,020
你正在编写一个Web应用程序，你想要有登录功能，现在为了

2158
03:58:01,020 --> 03:58:06,240
登录用户，我们必须满足多个不同的条件，例如首先我们需要

2159
03:58:06,240 --> 03:58:12,240
进行身份验证，然后我们还需要验证密码等等，所以基本上我们想要的是

2160
03:58:12,240 --> 03:58:18,720
要做的是为了登录，我们必须满足多个条件，而且你可以满足

2161
03:58:18,720 --> 03:58:24,900
使用with语法来满足多个条件，让我先给你展示一下，这样你就很容易理解了

2162
03:58:24,900 --> 03:58:31,240
要理解的是，首先让我们为我们的用户创建一个虚拟数据库，我们可以这样做

2163
03:58:31,240 --> 03:58:37,660
通过编写我们自己的自定义模块属性，所以在这里我们可以说我们想要定义一个模块

2164
03:58:37,660 --> 03:58:43,380
属性的名称为users，并让我们分配一个不同用户的列表，所以我们所做的是

2165
03:58:43,380 --> 03:58:48,980
所以这是一个模型属性，我们为这个模型属性分配了一个不同用户的列表。

2166
03:58:48,980 --> 03:58:55,240
所以我们可以在整个模块中将这些用户作为常量使用，接下来让我们写一下。

2167
03:58:55,240 --> 03:59:00,420
一些虚拟函数来进行身份验证和密码验证，所以我可以说我想定义一下。

2168
03:59:00,420 --> 03:59:06,100
一个用来进行身份验证的函数，这个函数将接受一个用户，我们可以在这里做的是。

2169
03:59:06,100 --> 03:59:13,280
这是一个称为函数保护的东西，所以我们可以说当用户在我的列表中时。

2170
03:59:13,280 --> 03:59:20,220
我们的用户中的时候，我想返回一个元组，第一个元素将是ok的。

2171
03:59:20,220 --> 03:59:25,980
消息将被授权，所以你可以在这里看到的语法就是所谓的保护。

2172
03:59:25,980 --> 03:59:30,700
在Elixir中，我们可以使用不同类型的保护，所以你会逐渐理解保护的作用。

2173
03:59:30,700 --> 03:59:36,080
学习更多的Elixir知识，但现在让我们跟着这个流程继续，接下来让我们创建一个函数。

2174
03:59:36,080 --> 03:59:41,100
为我们的身份验证创建定义，以防万一我们的数据库中没有该用户。</summary>

2175
03:59:41,100 --> 03:59:47,720
所以在那个时候，我们想要返回一个元组，第一个元素将是错误，我们可以发送

2176
03:59:47,720 --> 03:59:52,800
返回一个称为未经授权的消息，接下来让我们为验证密码创建一些虚拟函数

2177
03:59:52,800 --> 03:59:58,020
同样，我们可以说我们想要定义验证密码，现在这个函数将接受两个参数

2178
03:59:58,020 --> 04:00:04,020
参数，第一个将是用户，第二个将是密码，这里

2179
04:00:04,020 --> 04:00:10,680
我们可以使用函数 guard，所以我们可以说，如果用户在我们的用户数据库中

2180
04:00:10,680 --> 04:00:16,840
只有在那个时候，我想返回一个元组，第一个元素将是正常的，然后

2181
04:00:16,840 --> 04:00:22,200
我们可以将消息传递为密码已验证，现在如果用户名和密码不匹配

2182
04:00:22,200 --> 04:00:28,040
不匹配，所以对于这个，让我们创建一个额外的子句，这个我不需要一个 guard

2183
04:00:28,040 --> 04:00:35,100
这个必须是错误的，让我们将消息传递为错误的密码，这种情况下

2184
04:00:35,100 --> 04:00:39,680
我们对密码不做任何操作，让我使用一个下划线，这里也不是这样

2185
04:00:39,680 --> 04:00:45,100
现在我们已经有了基本的框架，可以对用户和密码进行任何操作了。

2186
04:00:45,100 --> 04:00:52,020
现在让我们创建一个登录函数，我们可以说定义了登录，该函数接受

2187
04:00:52,020 --> 04:00:57,960
用户和密码，现在让我把这些东西提升一点，为了登录

2188
04:00:57,960 --> 04:01:03,360
一个用户，我们必须满足几个不同的条件，第一个条件是首先我们有

2189
04:01:03,360 --> 04:01:08,940
进行身份验证，然后我们还必须验证密码，让我们看看如何使用

2190
04:01:08,940 --> 04:01:14,880
宽度语法，所以让我先在这里写宽度块，宽度为do，我们还可以写

2191
04:01:14,880 --> 04:01:20,020
在这里写else块，现在让我们看看如何定义宽度的主体，为了登录

2192
04:01:20,020 --> 04:01:25,660
首先我们需要进行身份验证，同时我们还需要进行验证，现在让我们调用一下

2193
04:01:26,500 --> 04:01:32,460
进行身份验证，让我们传递用户，现在我们必须说我们必须满足这个条件

2194
04:01:32,460 --> 04:01:38,980
我们可以使用箭头语法在这里指定，我们可以指定在我们获得的情况下

2195
04:01:38,980 --> 04:01:44,520
只有在特定输出的情况下，用户才能被验证，我们可以在这里指定

2196
04:01:44,520 --> 04:01:53,820
如果第一个元素是“okay”，那么我们只会得到一条消息

2197
04:01:53,820 --> 04:01:59,900
在验证的情况下，我们还需要检查密码是否可以验证，所以让我们

2198
04:01:59,900 --> 04:02:06,220
调用验证密码的函数，让我们传递用户和密码，现在我们

2199
04:02:06,220 --> 04:02:11,880
可以说，验证密码的函数还必须满足一些不同的条件

2200
04:02:11,880 --> 04:02:17,840
所以让我从这里复制这个，并粘贴到这里，以防这个函数

2201
04:02:17,840 --> 04:02:23,860
也成功了，我们会得到一个带有“okay”的元组，假设第二个元素是消息

2202
04:02:23,860 --> 04:02:28,420
让我在这里加一个下划线，因为我们没有对变量进行任何操作，那么现在

2203
04:02:28,420 --> 04:02:33,100
我们要做的是检查两个不同的条件，验证和验证

2204
04:02:33,100 --> 04:02:39,380
如果我们满足了这两个函数，那么我们可以说我们想要返回一个

2205
04:02:39,380 --> 04:02:45,920
消息，所以第一项将是 "okay"，然后让我们创建一个字符串，这样我们就可以说用户

2206
04:02:45,920 --> 04:02:52,120
成功登录，但是如果身份验证或密码验证函数失败，那么在

2207
04:02:52,120 --> 04:02:57,600
这种情况下，我们将进入else块，现在我们可以根据多个条件进行模式匹配，以防万一

2208
04:02:57,600 --> 04:03:04,100
我们得到一个元组，并且第一个元素是错误项，第二个元素可能是某种类型的

2209
04:03:04,100 --> 04:03:09,280
消息，所以那个时候我们只想返回相同的东西，所以我们想要返回

2210
04:03:09,280 --> 04:03:15,180
错误元组和返回的消息，但是如果我们遇到其他错误，我们可以指定

2211
04:03:15,180 --> 04:03:21,040
使用下划线，在所有其他情况下，我们只想返回一个项，表示

2212
04:03:21,040 --> 04:03:26,680
这是一个未经授权的操作，哦，我忘记在这里放逗号了，所以你的

2213
04:03:26,680 --> 04:03:31,260
with块看起来是这样的，让我打开终端，让我们看看这个东西的实际效果

2214
04:03:31,260 --> 04:03:38,080
所以让我重新编译我的费用模块，让我清除屏幕，我们可以说从这里开始

2215
04:03:38,780 --> 04:03:45,080
expense dot login，首先让我们传递一个已经在我们的数据库中的用户，例如

2216
04:03:45,080 --> 04:03:51,360
在我们的数据库中，我们有一个名为louis的用户，所以让我们传递louis这个参数，对于

2217
04:03:51,360 --> 04:03:56,060
密码没有关系，因为我们不会对密码做任何操作，让我们看一下

2218
04:03:56,060 --> 04:04:01,340
我们得到什么样的输出，是的，我们得到了一条消息，说louis已登录成功

2219
04:04:01,340 --> 04:04:07,020
成功了，让我们再试一次，使用一个不存在的用户，所以让我改一下

2220
04:04:07,020 --> 04:04:13,080
拼写，这次我们得到了一条错误消息，说未经授权，所以这就是关于使用的全部内容

2221
04:04:13,080 --> 04:04:18,180
elixir中的语法，就是这样了，感谢观看本视频，我们下一个视频再见

2222
04:04:18,180 --> 04:04:25,380
大家好，欢迎来到我们整个系列的最后一部分，现在这个最后的部分或者最后的章节是

2223
04:04:25,380 --> 04:04:31,560
关于在elixir中构建一个统计库的所有内容，现在不要担心统计这个词

2224
04:04:31,560 --> 04:04:36,660
统计学没有什么大不了的，只要你知道基本的数学，比如加法

2225
04:04:36,660 --> 04:04:41,760
减法、除法等等，你会完全没问题的，不用担心。

2226
04:04:41,760 --> 04:04:47,380
现在我也想讨论一些关于函数式编程的事情。

2227
04:04:47,380 --> 04:04:52,820
我第一个问题是，你对函数式编程有困难吗？

2228
04:04:52,820 --> 04:04:56,740
如果你的答案是肯定的，那么不用担心，你走在正确的道路上。

2229
04:04:57,560 --> 04:05:04,560
现在我想说的是，我们的大脑太习惯面向对象的编程范式了。

2230
04:05:04,560 --> 04:05:10,160
或者命令式编程范式，这需要一些时间才能理解。

2231
04:05:10,160 --> 04:05:16,920
数据不变性和递归，所以不要担心，你需要的只是更多的实践。

2232
04:05:16,920 --> 04:05:23,980
而创建另一个项目的意图是为了给你更多的练习，对吧，所以不要担心。

2233
04:05:23,980 --> 04:05:29,360
不用担心，这将是一个非常好的项目，我会向你展示我们如何稍微

2234
04:05:29,940 --> 04:05:35,580
优化我们的代码，如何创建一个不同的公共API，我们如何

2235
04:05:35,580 --> 04:05:42,680
将我们的内部实现与公共API分开等等。总的来说，这将会

2236
04:05:42,680 --> 04:05:48,120
这将是一个非常好的项目，所以跟着我，我会在下一个视频中见到你，到那时

2237
04:05:48,120 --> 04:05:54,300
再见，让我们开始我们的统计项目，但在此之前，我想让你见见

2238
04:05:54,300 --> 04:06:02,620
我的朋友路易斯，他住在多伦多，拥有一家糖果店，他将帮助我们

2239
04:06:02,620 --> 04:06:09,120
了解更多关于统计学的知识，我们想要学习的第一个主题叫做中央

2240
04:06:09,120 --> 04:06:15,500
趋势，中央趋势就像是一个大章节，但不要担心，我会让它变得非常简单易懂

2241
04:06:15,500 --> 04:06:21,820
我们想要学习的第一件事是如何计算平均数，平均数其实没什么

2242
04:06:21,820 --> 04:06:27,720
只是一个华丽词汇代表平均数，所以让我们试着更深入地学习这些概念

2243
04:06:28,260 --> 04:06:35,800
现在路易斯住在多伦多，他想要统计多伦多的汽车数量，所以这个

2244
04:06:35,800 --> 04:06:42,700
这种数据被称为人口数据，这种数据被称为人口，因为

2245
04:06:42,700 --> 04:06:51,440
我们的数据范围只限于多伦多，对吧？我们只想要统计多伦多的汽车数量

2246
04:06:51,440 --> 04:07:00,300
在多伦多，所以这个车辆数量将是一个有限的数字，我们的数据范围或数据范围

2247
04:07:00,300 --> 04:07:08,880
仅限于多伦多，这就是为什么这种数据被称为您的人口数据，请现在让

2248
04:07:08,880 --> 04:07:16,920
让我们看看接下来会发生什么，接下来路易斯想要计算多伦多的汽车数量，但是

2249
04:07:16,920 --> 04:07:23,840
这次数据不同，路易斯想要计算多伦多的汽车数量

2250
04:07:23,840 --> 04:07:30,660
加拿大所有汽车，所以这一次发生的是多伦多的汽车数量

2251
04:07:30,660 --> 04:07:39,100
变为样本数据，现在这个数据变成样本数据的原因是我们正在采用一个小样本

2252
04:07:39,100 --> 04:07:46,480
从加拿大所有汽车的更大数据集中选择多伦多的一个子集

2253
04:07:46,920 --> 04:07:53,300
所以加拿大所有汽车是你的人口，而且我们正在从中选择一个小样本

2254
04:07:53,300 --> 04:08:00,620
只是在多伦多，这就是为什么这种数据变成你的样本数据，所以让我们来看一下

2255
04:08:00,620 --> 04:08:08,380
例如，路易斯想要计算他那里的人们的平均身高的另一个例子

2256
04:08:08,380 --> 04:08:15,600
房子，例如，如果有四个人住在他的房子里，那个数据就成为了

2257
04:08:15,600 --> 04:08:22,260
人口数据，现在在这种情况下发生的是人数是有限的

2258
04:08:22,260 --> 04:08:30,400
路易斯的房子，这就是为什么数据是你的人口数据，我们正在尝试计算

2259
04:08:30,400 --> 04:08:36,780
平均身高，这就是为什么我们只需计算这种类型的人口均值

2260
04:08:36,780 --> 04:08:45,340
数据接下来是路易斯想要计算多伦多人的平均身高

2261
04:08:45,340 --> 04:08:52,820
加拿大的人，现在在这种情况下发生的是所有加拿大人都是这个数据

2262
04:08:52,820 --> 04:08:59,900
是你的人口数据，我们的目标是只针对那些留在这里的人

2263
04:08:59,900 --> 04:09:08,980
多伦多，所以这个数据是你的样本数据，这就是为什么这个平均值将成为你的样本均值

2264
04:09:08,980 --> 04:09:17,780
对了，现在让我们再看一个例子，路易斯在多伦多有一家糖果店，路易斯

2265
04:09:17,780 --> 04:09:24,400
想要计算三小时内售出的糖果平均数量，现在需要什么样的数据

2266
04:09:24,400 --> 04:09:31,440
这个是人口数据还是样本数据的问题，答案是这是人口数据。

2267
04:09:31,440 --> 04:09:39,060
因为我们的范围仅限于三个小时，所以这是人口数据。

2268
04:09:39,060 --> 04:09:46,120
我们将计算人口平均数，所以举个例子，这些是

2269
04:09:46,120 --> 04:09:52,680
不同种类的糖果，在第一小时，路易斯卖了10个糖果

2270
04:09:52,680 --> 04:10:00,680
第二小时，路易斯卖了20个糖果，第三小时卖了30个糖果，让我们看看如何

2271
04:10:00,680 --> 04:10:07,560
计算这种数据的平均值，我们只需把所有的糖果加在一起

2272
04:10:07,560 --> 04:10:12,940
这就是我们在这里做的，然后我们只需除以三，我们就得到

2273
04:10:12,940 --> 04:10:21,480
答案是每小时20个糖果，这意味着路易斯平均每小时能卖出20个糖果

2274
04:10:21,480 --> 04:10:29,440
在前三个小时，现在让我们再看一个例子，这次路易斯想要

2275
04:10:29,440 --> 04:10:37,220
计算在整个一天中前三个小时的平均售出糖果数，这种情况下

2276
04:10:37,220 --> 04:10:44,060
整个一天就是你的总体数据，而我们只限制在前三个小时

2277
04:10:44,060 --> 04:10:51,520
从整个一天中选择，这就是我们的样本数据，也就是说我们需要计算

2278
04:10:51,520 --> 04:10:58,180
样本均值，这些是路易斯在整整八个小时内卖出的不同糖果

2279
04:10:58,180 --> 04:11:04,240
一天中的小时数，所以第一个小时他卖出了10颗糖果，第二个小时卖出了20颗糖果

2280
04:11:04,240 --> 04:11:12,080
第三个小时卖出了30颗糖果，如此类推，让我们看看如何计算这种情况下的均值

2281
04:11:12,080 --> 04:11:18,860
前三个小时都保持不变，我们有相同的数字，所以第一个小时卖出10颗糖果

2282
04:11:18,860 --> 04:11:24,660
第二个小时卖出20颗糖果，下一个小时卖出30颗，所以我们有10加20加30

2283
04:11:24,660 --> 04:11:30,760
我们计算的小时数是三，所以这里有三

2284
04:11:30,760 --> 04:11:37,460
再次计算结果是20，这意味着在整个一天中的前三个小时，路易斯

2285
04:11:37,460 --> 04:11:44,480
每小时能卖出20颗糖果，所以你可以看到均值的公式保持不变

2286
04:11:44,480 --> 04:11:50,660
那么区别是什么，区别在于视角，样本数据是不同的，

2287
04:11:50,660 --> 04:11:56,080
人口数据是不同的，所以请记住这个视角，让我们看看如何

2288
04:11:56,080 --> 04:12:02,360
您可以在下一个视频中编写这个人口和样本均值，让我们开始吧

2289
04:12:02,360 --> 04:12:09,080
我们的统计项目，让我打开终端，让我们创建一个新的混合项目

2290
04:12:09,620 --> 04:12:15,320
让我进入我的函数式编程与elixir的文件夹，然后让我进入

2291
04:12:15,320 --> 04:12:21,800
我的代码文件夹，就在这里，我想创建一个新的项目，所以我可以说混合

2292
04:12:22,860 --> 04:12:30,480
统计，让我在一个新窗口中打开文件夹，这将是我们的新

2293
04:12:30,480 --> 04:12:36,320
统计项目，让我们看看如何实现我们的人口和样本均值

2294
04:12:36,320 --> 04:12:42,180
功能，所以首先要在lib文件夹里创建一个新文件夹

2295
04:12:42,180 --> 04:12:50,680
让我把这个文件夹叫做中心趋势，现在在这个文件夹里让我们创建另一个文件

2296
04:12:50,680 --> 04:12:56,940
让我创建一个文件，这将用于计算我们的人口和样本均值

2297
04:12:56,940 --> 04:13:04,600
让我收起边栏，首先让我们定义一个模块，这将是统计模块。

2298
04:13:04,600 --> 04:13:11,980
中央趋势·均值，首先让我们看看如何计算总体均值。

2299
04:13:12,180 --> 04:13:18,280
计算总体均值的公式非常简单，我们只需要取...

2300
04:13:18,280 --> 04:13:25,520
总和，然后我们需要将该总和除以计数。在统计学中，这个总和也被称为...

2301
04:13:25,520 --> 04:13:32,400
作为σ，那么让我们先来看看如何计算总体均值，然后我们定义一个函数...

2302
04:13:32,400 --> 04:13:39,740
命名为population mean，这个函数接受一个数字列表作为参数，所以我们可以将参数称为...

2303
04:13:39,740 --> 04:13:45,680
numbers，然后让我们看看如何为这个函数定义函数体，但在我们定义之前...

2304
04:13:45,680 --> 04:13:52,440
在这里我们需要进行很多验证，我们需要进行的第一个验证是...

2305
04:13:52,440 --> 04:13:59,520
需要检查这个numbers是否实际上是一个列表，所以我们要使用一个守卫...

2306
04:13:59,520 --> 04:14:05,280
所以让我们查看官方文档，看看我们能否找到合适的守卫。

2307
04:14:05,280 --> 04:14:12,460
在内核模块中，我们有一个用于保护的部分，所以让我们检查一下能否找到

2308
04:14:12,460 --> 04:14:19,860
列表的保护器是否存在，所以如果我往下滚动一点，我们就有一个保护器，这个保护器是

2309
04:14:19,860 --> 04:14:26,720
就在这里是列表，所以让我们看看我们如何在我们的函数中使用这个保护器，所以这里我们

2310
04:14:26,720 --> 04:14:34,080
可以说我们希望有一个保护器，它说是列表，让我们传递变量 numbers

2311
04:14:34,080 --> 04:14:40,500
基本上我们想做的就是只有在 numbers 是一个列表时才运行这个函数

2312
04:14:40,500 --> 04:14:47,200
现在我们已经验证了这个 numbers 是一个列表，但是如果这个 numbers 不是一个列表呢？

2313
04:14:47,200 --> 04:14:53,320
或者如果 numbers 是一个空列表，那么让我们在顶部定义一个更多的函数重载

2314
04:14:53,320 --> 04:15:00,660
所以在这里我们可以定义我们想要定义相同的函数 population mean，如果我们的情况是

2315
04:15:00,660 --> 04:15:07,500
空列表，那么此时返回一个空列表，现在我们可以返回一个空列表

2316
04:15:07,500 --> 04:15:13,460
或者我们也可以返回一些错误，例如，如果你想返回某种类型的

2317
04:15:13,460 --> 04:15:19,260
发生错误，我们可以返回一个元组，并且可以说这是一个错误，我们可以

2318
04:15:19,260 --> 04:15:25,740
还可以返回一个消息，说数据无效，所以你可以选择是否返回

2319
04:15:25,740 --> 04:15:30,860
返回一个空列表，或者可以返回一个错误元组，这只是供您参考

2320
04:15:30,860 --> 04:15:36,900
现在让我们看看如何定义我们总体均值的实际体。在这里，我们需要

2321
04:15:36,900 --> 04:15:43,420
首先，我们需要找出总和或Sigma，然后我们需要除以

2322
04:15:43,420 --> 04:15:49,720
计数，但在我们进行所有这些操作之前，我们需要进行一次额外的验证。到目前为止，我们所拥有的是

2323
04:15:50,440 --> 04:15:58,720
这些数字只是一个列表，但我们还需要验证这是否是一个数字列表。所以让我们

2324
04:15:58,720 --> 04:16:04,700
看看我们如何验证这个。因此让我们创建一个流程，这里我们可以说首先

2325
04:16:04,700 --> 04:16:10,720
我希望你拿这些数字，然后将这些数字放入一个函数中

2326
04:16:10,720 --> 04:16:17,400
我们可以称之为验证我们的数字列表的函数。所以我们还没有定义这个函数，但是让我们

2327
04:16:17,400 --> 04:16:22,560
在这里定义它，所以让我复制这个，并让我们在这里定义一个函数。

2328
04:16:22,560 --> 04:16:28,760
在这里验证我们的数字列表，接受我们的数字列表，让我们看看我们如何定义。

2329
04:16:28,760 --> 04:16:34,560
对于这个函数的主体，让我们返回一个元组，第一个条件将是。

2330
04:16:34,560 --> 04:16:41,880
要么是true，要么是false，第二个条件将是数字，所以如果这个列表不是一个列表的话。

2331
04:16:41,880 --> 04:16:48,420
我们将返回false，但如果这是一个有效的数字列表，那么我们将发送。

2332
04:16:48,420 --> 04:16:54,320
在这里返回一个true，所以让我们看看我们如何做这个事情，不幸的是，它非常简单。

2333
04:16:54,320 --> 04:17:01,960
所以在这里让我们使用内置的枚举模块，我想使用all函数，现在这个all函数需要。

2334
04:17:01,960 --> 04:17:08,400
两个参数，第一个将是我们的枚举，所以让我们传递我们数字的枚举，这个也。

2335
04:17:08,400 --> 04:17:14,340
接受一个函数，所以让我们在这里定义一个函数，现在每次迭代发生的情况是。

2336
04:17:14,340 --> 04:17:20,340
我们将从我们的数字列表中接收一个元素，我们只需检查是否。

2337
04:17:20,340 --> 04:17:27,640
元素是数字还是其他类型，我们可以使用一个内建函数叫做 is_number，让我们

2338
04:17:27,640 --> 04:17:33,520
将元素传递给这个函数，这样我们就定义了一个函数来验证所有的数字

2339
04:17:33,520 --> 04:17:40,360
让我们为这个函数写入类型说明，这样我们可以说规格为

2340
04:17:40,360 --> 04:17:47,600
验证数字列表，所以这个函数接收一个数字列表，并返回一个元组

2341
04:17:47,600 --> 04:17:54,400
第一个元素将是我们的布尔值，第二个元素是我们的数字列表，让我们回到

2342
04:17:54,400 --> 04:17:59,960
我们的均值函数，现在我们已经完成了所有的验证，现在这个函数

2343
04:17:59,960 --> 04:18:06,900
返回一个元组，所以我们可以简单地取出那个元组，并将输出

2344
04:18:06,900 --> 04:18:13,600
传递给另一个函数，让我们将这个新函数称为计算均值，所以我们有了

2345
04:18:13,600 --> 04:18:19,540
还没有定义这个函数，但是让我们在这里定义它，所以我们可以说定义

2346
04:18:19,540 --> 04:18:26,260
计算均值，让我们写下 do 和 end 代码块，现在这个计算的函数

2347
04:18:26,260 --> 04:18:33,860
总体均值接收一个元组，第一个是我们的条件，第二个是我们的数字列表

2348
04:18:33,860 --> 04:18:40,660
数字，现在这个条件可以是真的或者是假的，所以假设我们有一个真的条件

2349
04:18:40,660 --> 04:18:46,700
那么我们可以在这里进行模式匹配，但如果它是假的，我们可以再创建一个

2350
04:18:46,700 --> 04:18:52,400
另一个子句，所以让我复制粘贴这个，所以在这里我可以说，如果参数

2351
04:18:52,400 --> 04:18:58,020
是假的，我们就不必对数字做任何操作，所以让我用下划线替换数字

2352
04:18:58,020 --> 04:19:04,800
如果第一个参数是假的，那就意味着验证失败了，所以我们可以再次

2353
04:19:04,800 --> 04:19:10,760
发送相同的元组错误，所以让我复制这个，然后粘贴在这里，现在让

2354
04:19:10,760 --> 04:19:22,380
我们来看看如何计算总体均值，如果第一个参数是真的，那么这里

2355
04:19:22,380 --> 04:19:29,500
我们可以通过使用内置函数来计算总和，所以我们可以说 enum 命令总和下一个

2356
04:19:29,500 --> 04:19:35,720
我们只需要用总和除以计数，所以为此让我们再定义一个函数

2357
04:19:35,720 --> 04:19:41,360
让我们把这个函数称为mean，所以这个函数将接收两个参数，第一个

2358
04:19:41,360 --> 04:19:46,880
参数是用于sigma，它来自这个，第二个参数是用于

2359
04:19:46,880 --> 04:19:52,680
计数，我们可以在这里传递第二个参数，所以我们可以说enum dot count，让

2360
04:19:52,680 --> 04:19:58,540
我们传递数字列表，现在让我们在这里创建这个函数，所以我们可以说定义

2361
04:19:58,540 --> 04:20:04,680
mean函数的第一个参数是sigma，第二个参数是计数，对于这个

2362
04:20:04,680 --> 04:20:10,900
实现非常简单，我们只需要将sigma除以计数，就这样

2363
04:20:10,900 --> 04:20:16,560
我们已经实现了总体均值，但我们可以做很多改进，正如你所见，我们有

2364
04:20:16,560 --> 04:20:23,040
一些重复，我们这里也有一些错误的tuple，顶部也一样，让我也放一些

2365
04:20:23,040 --> 04:20:29,380
分隔线，为了方便我们，这将是一个独立的事情和计算

2366
04:20:29,380 --> 04:20:35,060
总体均值将成为一个单独的部分，这也是一个，所以现在让

2367
04:20:35,060 --> 04:20:41,260
我们回到顶部，看看如何改进我们的代码，所以现在首先我们有这个

2368
04:20:41,800 --> 04:20:48,700
两次，所以让我们为错误创建一个单独的模块，让我打开我的侧边栏，进入目录

2369
04:20:48,700 --> 04:20:56,220
在lib目录下，让我创建一个名为errors的新模块，并将该模块定义为stats dot
errors

2370
04:20:56,220 --> 04:21:02,940
让我们在这里定义一个函数，我们可以说定义无效的数据类型，我们只是想

2371
04:21:02,940 --> 04:21:09,840
返回元组，让我返回mean文件，让我只是复制这一行

2372
04:21:09,840 --> 04:21:16,020
回到我们的errors文件，让我粘贴在这里，现在让我们回到这个文件

2373
04:21:16,020 --> 04:21:22,020
让我折叠我的侧边栏，现在我们可以在顶部创建一个别名，这样我们可以说

2374
04:21:22,020 --> 04:21:30,020
让我们为stats dot errors创建一个别名，我们可以用errors替换这一行

2375
04:21:30,020 --> 04:21:36,000
点无效的数据类型，我们可以在这里做同样的事情，让我删除这一行

2376
04:21:36,820 --> 04:21:43,840
errors dot invalid data type，现在我想做一件事，我想删除这个函数

2377
04:21:43,840 --> 04:21:49,300
将它验证为另一个模块，因为我知道我们将需要这个。

2378
04:21:49,300 --> 04:21:56,060
为了未来的实现，我们还需要一个验证函数，所以在lib中让我们创建一个文件。

2379
04:21:56,060 --> 04:22:03,180
再次为验证器定义模块，模块名必须是stats.validators。

2380
04:22:03,180 --> 04:22:09,600
让我们回到这个文件，我只想把所有的东西都删掉，所以让我把它拿出来，我们去...

2381
04:22:09,600 --> 04:22:15,820
我们的验证器文件，让我把它粘贴在这里，这个我们可以做一个小的...

2382
04:22:15,820 --> 04:22:21,120
由于我们将此文件放在另一个模块中，所以我们可以进行一个小的验证。

2383
04:22:21,120 --> 04:22:28,580
同样也需要验证，所以让我们在这里定义一个保护条件，当我们的数字是列表且如果...

2384
04:22:28,580 --> 04:22:33,800
如果这个验证失败，那么让我们在这里创建一个更多的子句，所以在这里我们可以简单地...

2385
04:22:33,800 --> 04:22:40,200
忽略这个参数，我们可以简单地返回一个错误，所以让我再次为它创建一个别名...

2386
04:22:40,200 --> 04:22:47,060
在这里创建一个错误，所以让我们为我们的stats.errors创建一个别名，并返回一个错误。

2387
04:22:47,060 --> 04:22:53,200
就在这里，我们可以说错误是无效的数据类型，现在对此进行规范。

2388
04:22:53,200 --> 04:23:00,020
即将改变，这个无效数据类型的函数返回一个元组，让我们定义一个。

2389
04:23:00,020 --> 04:23:05,980
对于这个也要规定，让我们去错误这里，我们可以说规范是。

2390
04:23:05,980 --> 04:23:12,300
对于我们的无效数据类型函数，所以这个函数不接受任何参数，只是简单地。

2391
04:23:12,300 --> 04:23:19,340
返回一个原子，并且下一个参数的类型是字符串，所以让我复制所有这些。

2392
04:23:19,340 --> 04:23:26,160
让我们回到我们的验证文件，现在发生的情况是如果这个数字是一个。

2393
04:23:26,160 --> 04:23:32,820
数字列表，我们返回一个元组，但是如果验证失败，我们只需返回一个。

2394
04:23:32,820 --> 04:23:38,980
错误和错误的格式是我们有一个原子，我们还有一条消息，接下来的。

2395
04:23:38,980 --> 04:23:44,240
问题是，由于我们将这个函数放在一个不同的模块中，让我们回到我们的模块。

2396
04:23:44,240 --> 04:23:49,860
mean，并且让我们在顶部创建一个别名，所以我们可以说我们想要再别名一个。

2397
04:23:49,860 --> 04:23:56,580
从同一个模块中导入errors和validators，这样我们就可以创建一个别名。

2398
04:23:56,580 --> 04:24:02,440
从同一个模块中导入errors和validators，这样我们就可以创建一个别名。

2399
04:24:02,440 --> 04:24:07,760
同一行上，让我来告诉你如何操作，我们只需要将其包裹在花括号中。

2400
04:24:07,760 --> 04:24:13,600
我们也要为validators创建一个别名，在这一行上。

2401
04:24:14,360 --> 04:24:21,620
这个函数在validators模块中，所以我们可以写validators.validate(numbers_list)。

2402
04:24:21,620 --> 04:24:29,520
删除这些行，让我打开终端，我们可以进入ix，让我们为其创建一个别名。

2403
04:24:29,520 --> 04:24:37,220
stats.central_tendency.mean，让我整理一下，然后我们来调用我们的总体均值。

2404
04:24:37,220 --> 04:24:45,760
我们可以说是总体均值，让我们传入10、20和30，按预期我们会得到答案。

2405
04:24:45,760 --> 04:24:52,000
得到20，现在让我们传入一个空列表，看看发生了什么，所以在这种情况下，我们得到了一个错误。

2406
04:24:52,000 --> 04:24:58,220
错误显示无效的数据类型，请看看如果我们传入其他参数会发生什么。

2407
04:24:58,220 --> 04:25:04,300
例如，如果我们传递a、b和c，那么在这种情况下我们会得到一个错误，提示没有函数

2408
04:25:04,300 --> 04:25:09,940
这是因为我们没有为这个函数定义一个捕获所有情况的子句

2409
04:25:09,940 --> 04:25:15,340
总体均值，所以让我们在这里定义一个子句，我们可以说定义

2410
04:25:15,340 --> 04:25:21,800
总体均值，而在这种情况下我们只想忽略参数并返回

2411
04:25:21,800 --> 04:25:30,100
返回我们的错误.无效的数据类型，让我打开终端，让我们重新编译我们的模块

2412
04:25:30,100 --> 04:25:36,460
让我清理一切，让我们再试一次相同的语句，这一次我们得到了一个很好的

2413
04:25:36,460 --> 04:25:42,920
错误，说错误的无效数据类型，这就是我们可以创建总体均值的方式，但我们还没有完成

2414
04:25:42,920 --> 04:25:49,200
还没有完成，我们还需要实现样本均值，但幸运的是样本均值和

2415
04:25:49,200 --> 04:25:55,420
总体均值是相同的，所以让我们非常快速地实现我们的样本均值，让我拿出来

2416
04:25:55,420 --> 04:26:01,340
我不需要这些注释，让我将分隔线粘贴在顶部，现在在这里让

2417
04:26:01,340 --> 04:26:06,260
再次复制这个分隔线，并为样本均值创建一个更多的函数，对吗？

2418
04:26:06,260 --> 04:26:11,540
在这里，我们可以说我们想要为样本均值定义一个函数，现在这个

2419
04:26:11,540 --> 04:26:18,440
函数接受一个数字列表，我们只需调用我们的总体均值并传入我们的

2420
04:26:18,440 --> 04:26:24,120
数字列表，就这样我们现在有了样本均值和总体均值的函数

2421
04:26:24,120 --> 04:26:29,380
让我们也为这个函数定义规范，所以我们可以说

2422
04:26:29,380 --> 04:26:35,760
总体均值的规范，这个函数接收一个数字列表，这个

2423
04:26:35,760 --> 04:26:42,080
函数将返回一个数字，或者它将返回一个错误，现在

2424
04:26:42,080 --> 04:26:48,720
我们的错误是这样的，第一个元素是原子，第二个元素是类型

2425
04:26:48,720 --> 04:26:55,520
让我也将这个规范复制给我们的样本均值，让我将它粘贴在这里，让

2426
04:26:55,520 --> 04:27:02,420
我将名称从总体更改为样本，接下来我们可以对我们的一些改进做更多的工作

2427
04:27:02,420 --> 04:27:08,220
现在代码里，如果你看到这个计算总体均值的函数和这个均值的函数，那么

2428
04:27:08,220 --> 04:27:14,040
这些函数只是我们的私有函数，所以让我们将它们声明为私有函数，这样就变成了

2429
04:27:14,040 --> 04:27:20,480
我们的p的定义也变成了我们的私有函数，对于我们的mean也是一样的情况

2430
04:27:20,480 --> 04:27:25,580
好的，这也变成了我们的私有函数，现在让我打开终端，让我们试试

2431
04:27:25,580 --> 04:27:31,320
重新编译一次，让我清理一下所有东西，然后让我们尝试调用相同的

2432
04:27:31,320 --> 04:27:39,060
函数再试一次，让我们传入10、20和30的列表，这是用于总体均值的

2433
04:27:39,060 --> 04:27:45,120
我们也让我们尝试一下样本均值，让我用样本均值来替代这个

2434
04:27:45,120 --> 04:27:50,480
我们得到了相同的答案，现在的情况是每次我们都要创建一个

2435
04:27:50,480 --> 04:27:56,980
但是我们可以做的是将我们的公共API和私有API分开

2436
04:27:56,980 --> 04:28:04,660
所以如果我打开我的侧边栏，我们有一个stats.ex的模块，正如你所看到的，这个文件不是

2437
04:28:04,660 --> 04:28:11,440
我们现在要做的是将这个stats文件作为我们的公共API，所以不要做任何事情。

2438
04:28:11,440 --> 04:28:18,000
我的意思是最终用户只需引用这个单个文件就可以使用所有功能。

2439
04:28:18,000 --> 04:28:23,000
让我来向你展示我们如何做到这一点，让我把所有这些东西拿出来，这些都不是必需的。

2440
04:28:23,000 --> 04:28:28,380
让我折叠侧边栏，我们在这里定义一个用于人口平均值的函数。

2441
04:28:28,380 --> 04:28:34,160
现在这个函数接收我们的数字列表，从这里我们可以简单地调用我们的函数。

2442
04:28:34,160 --> 04:28:41,620
所以我们可以说我们想为我们的stats.dot.central.tendency.mean创建一个别名。

2443
04:28:41,620 --> 04:28:48,300
对于这个函数，我们可以简单地将它委派给mean.dot.population.mean，并让我们传递

2444
04:28:48,300 --> 04:28:54,680
数字参数，所以现在我们大大简化了我们的API，现在让我打开终端

2445
04:28:54,680 --> 04:29:01,160
让我们重新编译stats模型，让我清理一切，现在我们可以做的就是简单地

2446
04:29:01,160 --> 04:29:09,440
stats.dot.population.mean，让我们传递参数10、20和30，然后我们得到了

2447
04:29:09,440 --> 04:29:16,300
正确答案，现在让我们回到我们的代码，我们可以对这个做一个小小的改进。

2448
04:29:16,300 --> 04:29:21,820
现在，我们可以使用一个叫做“def delegate”的东西，而不仅仅是调用这个函数。

2449
04:29:21,820 --> 04:29:27,360
首先让我给你展示一下，然后我可以解释给你听，在这里我们可以使用一个叫做“def
delegate”的新关键字。

2450
04:29:28,160 --> 04:29:34,440
“delegate”的第一个参数是我们函数的名称，所以我们函数的名称是“population”。

2451
04:29:34,440 --> 04:29:40,300
mean，所以让我把它粘贴到这里，现在这个函数也接受一个参数，而这个参数是。

2452
04:29:40,300 --> 04:29:46,160
是用于我们数字列表的，现在我们想做的就是简单地将这个委托给。

2453
04:29:46,160 --> 04:29:54,100
我们的mean模型的函数，就是这样，第四行和第五行就是做这个事情的。

2454
04:29:54,100 --> 04:29:59,720
同样的事情，所以让我对这一行进行注释，这是不需要的，让我打开我的终端。

2455
04:29:59,720 --> 04:30:05,920
我们重新编译一下统计模块，让我把一切都清理干净，然后再调用同一个函数。

2456
04:30:05,920 --> 04:30:12,320
再次调用一次，正如预期的那样，这个工作得很好，让我们再创建一个“def delegate”函数。

2457
04:30:12,320 --> 04:30:18,180
样本均值，所以我们只需要将名称从总体均值改为样本均值。

2458
04:30:18,180 --> 04:30:24,260
每当我们调用stats.sample mean时，该函数将被委托给mean.sample。

2459
04:30:24,260 --> 04:30:31,200
均值，让我打开终端，让我们重新编译相同的模块，让我清理一切。

2460
04:30:31,200 --> 04:30:37,320
在这里，我可以说stats这次我想计算样本均值，让我传递

2461
04:30:37,320 --> 04:30:43,660
三、四、五、六和七的参数，这次我们得到的答案是五，那就是这样了。

2462
04:30:43,660 --> 04:30:49,240
这个视频就到这里，我会在下一个视频中见到你们，让我们开始我们的统计项目吧。

2463
04:30:49,900 --> 04:30:56,600
所以让我打开终端，让我们创建一个新的mix项目，让我进入我的文件夹

2464
04:30:56,600 --> 04:31:03,560
关于elixir的函数式编程，然后让我进入我的代码文件夹

2465
04:31:03,560 --> 04:31:12,080
这里我想创建一个新项目，所以我可以说mix new stats，让我在一个窗口里打开这个文件夹

2466
04:31:13,060 --> 04:31:19,720
所以这将是我们的新统计项目，让我们看看我们如何实施我们的

2467
04:31:19,720 --> 04:31:26,180
群体和样本均值功能，所以第一件事是在lib文件夹内，让我创建一个新文件夹。

2468
04:31:26,180 --> 04:31:34,280
创建一个新文件夹，让我把它叫做中心倾向，现在，在这个文件夹内

2469
04:31:34,280 --> 04:31:40,740
让我们创建另一个文件，让我创建一个文件，用于计算我们的总体

2470
04:31:40,740 --> 04:31:48,140
和样本均值，让我折叠侧边栏，首先，让我们定义一个模块

2471
04:31:48,140 --> 04:31:56,900
叫做stats.dot.central_tendency.dot.mean，所以首先让我们看看如何计算我们的总体

2472
04:31:56,900 --> 04:32:03,540
均值，现在计算总体均值的公式非常简单，我们只需要将

2473
04:32:03,540 --> 04:32:10,720
总和，然后将该总和除以计数，根据统计学的说法，这个总和也被称为

2474
04:32:10,720 --> 04:32:17,700
sigma，所以首先让我们看看如何计算我们的总体均值，让我们定义一个函数

2475
04:32:17,700 --> 04:32:25,020
叫做population_mean，这个函数接受一个数字列表作为参数

2476
04:32:25,020 --> 04:32:30,980
作为numbers，然后让我们看看如何为这个函数定义主体，但在我们定义之前

2477
04:32:30,980 --> 04:32:36,940
这里我们需要做很多验证，我们需要做的第一个验证是

2478
04:32:36,940 --> 04:32:43,820
我们需要检查这个数字是否实际上是一个列表，为此我们将使用

2479
04:32:43,820 --> 04:32:50,280
一个守卫，所以让我们去官方文档，看看我们能否找到正确的

2480
04:32:50,280 --> 04:32:56,920
守卫或者不是，在内核模块中，我们有一个守卫的部分，所以让我们检查一下

2481
04:32:56,920 --> 04:33:03,780
我们能否找到用于列表的守卫，如果我往下滚动一点，这里有一个守卫

2482
04:33:03,780 --> 04:33:10,260
这个守卫就在这里，是列表，所以让我们看看如何在我们的函数中使用这个守卫

2483
04:33:10,820 --> 04:33:18,060
所以在这里，我们可以说我们想要一个守卫，说它是一个列表，让我们传递

2484
04:33:18,060 --> 04:33:24,360
变量的数字，所以基本上我们想要做的是只有当

2485
04:33:24,360 --> 04:33:30,300
这个数字是一个列表，现在我们已经验证了这个数字是一个列表，但是会发生什么

2486
04:33:30,300 --> 04:33:36,560
如果这个数字不是一个列表，或者数字是一个空列表的情况下，那么让我们定义一个

2487
04:33:36,560 --> 04:33:43,260
在顶部进行更多的函数重载，这样我们可以定义我们想要定义的相同函数。

2488
04:33:43,260 --> 04:33:50,340
总体均值，如果我们得到一个空列表，那么就返回一个空列表。

2489
04:33:50,340 --> 04:33:57,080
现在我们可以返回一个空列表，或者也可以返回某种错误，例如

2490
04:33:57,080 --> 04:34:02,300
如果你想返回某种错误，那么我们可以返回一个元组，并且可以说

2491
04:34:02,300 --> 04:34:08,360
这将是一个错误，我们还可以返回一条消息，说明数据无效。

2492
04:34:08,360 --> 04:34:14,480
所以这取决于你，如果你愿意，你可以返回一个空列表，或者你可以返回一个错误的元组。

2493
04:34:14,480 --> 04:34:20,000
这只是供你参考，现在让我们看看如何为我们的实际主体定义。

2494
04:34:20,000 --> 04:34:26,120
总体均值，所以这里我们需要做两件事，首先我们需要找出总和或sigma

2495
04:34:26,120 --> 04:34:32,200
然后我们必须除以计数，但在我们做所有这些之前，我们需要做

2496
04:34:32,200 --> 04:34:38,760
另一个验证，到目前为止，我们验证的是这些数字只是一个列表。

2497
04:34:38,760 --> 04:34:45,920
但我们还需要验证这是否是一个数字列表，让我们看看如何验证

2498
04:34:45,920 --> 04:34:51,880
首先，让我们创建一个流水线，让我们说首先我想让你取出这些数字

2499
04:34:51,880 --> 04:34:57,920
然后，我希望你将这些数字传入一个函数中，并且我们可以称呼这个函数为

2500
04:34:57,920 --> 04:35:04,340
验证我们的数字列表，我们还没有定义这个函数，但是让我们在这里定义它

2501
04:35:04,340 --> 04:35:09,600
所以让我复制这个，让我们在这里定义一个函数，验证我们的数字

2502
04:35:09,600 --> 04:35:15,220
这个函数接受我们的数字列表，让我们看看如何定义它的主体部分

2503
04:35:15,220 --> 04:35:21,400
现在，对于这个函数，让我们返回一个元组，第一个条件可以是真或假

2504
04:35:21,400 --> 04:35:27,860
第二个条件是数字，如果这个列表不是一个数字列表的话

2505
04:35:27,860 --> 04:35:34,680
我们将返回假，但是如果这是一个有效的数字列表，我们将返回真

2506
04:35:34,680 --> 04:35:40,680
就在这里，让我们看看我们如何做这件事，不幸的是它非常简单，所以在这里让我们

2507
04:35:40,680 --> 04:35:47,580
我们使用内置的枚举模块，我想使用all函数，这个函数需要两个参数。

2508
04:35:47,580 --> 04:35:54,520
第一个参数是我们的枚举类型，所以让我们传递我们的数字枚举，这个函数还需要一个参数。

2509
04:35:54,520 --> 04:36:00,540
所以让我们在这里定义一个函数，每次迭代时会发生什么。

2510
04:36:00,540 --> 04:36:06,060
我们将从数字列表中接收一个元素，我们只需要检查该元素是否为数字。

2511
04:36:06,060 --> 04:36:13,500
判断该元素是否为数字，我们可以使用一个名为is number的内置函数，让我们将该元素传递给它。

2512
04:36:13,500 --> 04:36:19,080
将该元素传递给它，这样我们就定义了一个函数来验证我们的所有数字。

2513
04:36:19,080 --> 04:36:25,660
让我们还为这个函数编写类型规范，所以在这里我们可以说这个函数的规范是

2514
04:36:25,660 --> 04:36:32,880
验证数字列表，所以它接收一个数字列表，并返回一个元组。

2515
04:36:32,880 --> 04:36:39,700
第一个元素是一个布尔值，第二个元素是我们的数字列表，让我们回到

2516
04:36:39,700 --> 04:36:45,780
总体均值的函数，现在我们已经完成了所有的验证，现在这个函数返回的是

2517
04:36:45,780 --> 04:36:52,880
返回一个元组，我们可以做的是简单地获取那个元组并将输出连接到另一个函数。

2518
04:36:52,880 --> 04:36:59,360
另一个函数，我们可以称之为计算人口平均数的新函数，所以我们还没有。

2519
04:36:59,360 --> 04:37:05,600
定义了这个函数，但是让我们在这里定义它，我们可以说定义计算函数。

2520
04:37:05,600 --> 04:37:12,180
平均值，让我们现在编写do和end块，现在这个计算人口的函数。

2521
04:37:12,180 --> 04:37:19,680
平均值接收一个元组，第一个是我们的条件，第二个是我们的数字列表。

2522
04:37:19,680 --> 04:37:26,360
现在这个条件可以是真也可以是假，所以假设我们有一个真条件，那么

2523
04:37:26,360 --> 04:37:32,000
我们可以在这里进行模式匹配，但是如果为假，我们可以创建yet。

2524
04:37:32,580 --> 04:37:38,500
所以让我只是复制粘贴这个，所以在这里我可以说如果参数为假的话

2525
04:37:38,500 --> 04:37:43,320
我们不需要对数字做任何处理，所以让我用下划线替换数字

2526
04:37:43,320 --> 04:37:50,100
如果第一个参数为假，那意味着验证失败，所以在这里我们可以再次做

2527
04:37:50,100 --> 04:37:56,060
发送相同的元组错误，所以让我复制这个，然后粘贴到这里，现在，让我

2528
04:37:56,060 --> 04:38:02,300
我们来看看如果第一个参数是真的，我们如何计算总体平均数，现在这里

2529
04:38:02,300 --> 04:38:07,720
公式非常简单，首先我们要取出数字，然后我们要计算总和

2530
04:38:07,720 --> 04:38:14,820
我们可以通过使用内置函数来计算总和，所以我们可以说枚举点和下一个

2531
04:38:14,820 --> 04:38:21,080
我们只需将总和除以计数即可，所以为此让我们定义一个更多的函数，并且

2532
04:38:21,080 --> 04:38:26,660
将该函数称为均值，所以这个函数将接收两个参数，第一个

2533
04:38:26,660 --> 04:38:32,180
参数将用于来自此处的sigma，第二个参数将用于

2534
04:38:32,180 --> 04:38:37,960
计数，我们可以将第二个参数传递到这里，所以我们可以说枚举点计数，让

2535
04:38:37,960 --> 04:38:43,840
我们传递数字列表，现在让我们创建这个函数，所以我们可以说定义

2536
04:38:43,840 --> 04:38:49,980
均值的第一个参数是sigma，第二个参数是计数，以及对于这个

2537
04:38:49,980 --> 04:38:56,400
实现非常简单，我们只需要将sigma与计数相除，就是这样我们

2538
04:38:56,400 --> 04:39:01,880
实现了总体均值，但我们还可以进行很多改进，所以你可以看到我们有

2539
04:39:01,880 --> 04:39:08,300
一些重复，我们这里有一个错误的元组，以及在顶部也有，让我也放一些

2540
04:39:08,300 --> 04:39:14,660
分隔线以方便我们，所以这将是一个独立的事物和计算

2541
04:39:14,660 --> 04:39:20,840
总体均值将成为一个独立的部分，还有一个独立的部分，所以现在让我们去

2542
04:39:20,840 --> 04:39:26,780
顶部，让我们看看如何改进我们的代码，现在第一件事是我们有这个错误

2543
04:39:26,780 --> 04:39:33,660
元组两次，所以让我们为错误创建一个单独的模块，让我打开我的侧边栏，在里面

2544
04:39:33,660 --> 04:39:39,440
lib目录，让我创建一个名为errors的新模块，让我们定义这个模块

2545
04:39:39,440 --> 04:39:46,900
as stats.dot.errors，让我们在这里定义一个函数，这样我们就可以定义无效的数据类型

2546
04:39:46,900 --> 04:39:53,560
我们只想返回这个元组，所以让我回到均值文件，让我只是

2547
04:39:53,560 --> 04:40:00,200
复制这一行，让我们回到我们的错误文件，然后让我在这里粘贴它，现在我们可以

2548
04:40:00,200 --> 04:40:05,890
回到这个文件，让我折叠我的侧边栏，现在我们可以做的是创建一个别名

2549
04:40:06,490 --> 04:40:14,210
我们可以说，让我们为我们的stats dot errors创建一个别名，并且我们可以替换这一行

2550
04:40:14,210 --> 04:40:20,430
用errors dot invalid data
type替换，并且我们可以在这里做同样的事情，所以让我拿出来

2551
04:40:20,430 --> 04:40:27,270
这一行，我们可以说errors dot invalid data type，现在我想再做一件事

2552
04:40:27,270 --> 04:40:33,270
将这个验证函数取出到另一个模块中，这是因为我知道

2553
04:40:33,270 --> 04:40:39,470
我们将来也需要这个验证函数，所以在lib中

2554
04:40:39,470 --> 04:40:46,550
我们再创建一个文件给validators，让我们定义模块，模块名必须是

2555
04:40:46,550 --> 04:40:53,250
是stats dot validators，让我们回到这个文件，我只是想把所有东西都删掉，所以让

2556
04:40:53,250 --> 04:40:59,810
我把它拿出来，让我们去我们的validators文件，然后让我在这里粘贴，现在针对这个

2557
04:40:59,810 --> 04:41:05,130
我们可以进行一次轻微的验证，因为我们已经将这个文件放入了另一个模块中，所以在这里

2558
04:41:05,130 --> 04:41:12,250
我们也可以进行一次小的验证，所以让我们在这里定义一个守卫，这样当我们的列表为空时

2559
04:41:12,250 --> 04:41:17,710
如果这个验证失败了，那么让我们在这里创建一个额外的子句

2560
04:41:17,710 --> 04:41:24,270
所以在这里我们可以忽略这个参数，然后返回一个错误，所以让我再次

2561
04:41:24,270 --> 04:41:30,470
在这里为这个错误创建一个别名，让我们为我们的 stats.dot.errors 创建一个别名

2562
04:41:30,470 --> 04:41:36,750
然后让我们在这里返回一个错误，所以在这里我们可以说 errors.dot.invalid data
type

2563
04:41:36,750 --> 04:41:42,610
现在这个函数的规范将会改变，所以这个 invalid data type 的函数

2564
04:41:42,610 --> 04:41:48,390
这个函数返回一个元组，让我们也为它定义一个规范，所以让我们去 errors

2565
04:41:48,390 --> 04:41:54,950
在这里我们可以说这个 invalid data type 函数的规范，所以这个函数

2566
04:41:54,950 --> 04:42:01,730
不接受任何参数，只是返回一个原子，而下一个参数的类型是

2567
04:42:01,730 --> 04:42:08,710
字符串的话，让我复制所有这些东西，让我们回到我们的验证器文件，那么现在怎么样？

2568
04:42:08,710 --> 04:42:15,130
发生的是，如果这个数字是一个数字列表，我们发送回一个元组，但是如果

2569
04:42:15,130 --> 04:42:21,070
验证失败，那么我们只需发送一个错误，并且该错误的格式是我们有一个

2570
04:42:21,070 --> 04:42:26,490
原子，我们还有一条消息，接下来的事情是，由于我们在一个

2571
04:42:26,490 --> 04:42:32,830
不同的模块，让我们回到我们的平均模块，并在顶部创建一个别名，所以在这里

2572
04:42:32,830 --> 04:42:38,570
我们可以说我们想给另一个模块起一个别名，所以我们可以说我们想给统计模块起一个别名

2573
04:42:38,570 --> 04:42:44,670
点验证器，现在我们正在做的是从相同的地方导入错误和验证器

2574
04:42:44,670 --> 04:42:50,450
统计模块，所以我们可以在同一行上创建一个别名，让我告诉你怎么做，我们只需要

2575
04:42:50,450 --> 04:42:56,110
将其包裹在我们的花括号中，我们可以说我们也想为其创建一个别名

2576
04:42:56,110 --> 04:43:02,850
同样，现在在这里，在第10行，这个函数在我们的模块中

2577
04:43:02,850 --> 04:43:09,170
验证器，所以验证器点验证数字列表让我删除这些行，让我打开

2578
04:43:09,890 --> 04:43:18,030
我们可以进入我们的 ix，让我们为 stats 点 central tendency 点 mean
创建一个别名

2579
04:43:18,030 --> 04:43:24,710
让我清理一切，然后让我们调用我们的总体平均值，这样我们就可以说总体平均值

2580
04:43:24,710 --> 04:43:33,670
让我们传递 10 20 和 30，预期我们得到的答案是 20，现在让我们传递一个空的

2581
04:43:33,670 --> 04:43:38,770
列表，看看发生了什么，在这种情况下，我们得到了一个错误，错误信息为

2582
04:43:38,770 --> 04:43:44,830
无效的数据类型，现在看看如果我们传递一些其他的参数会发生什么，例如，如果我们传递

2583
04:43:44,830 --> 04:43:51,370
a b 和 c，所以在这种情况下，我们得到了一个错误，错误信息为没有匹配的函数子句，这是因为

2584
04:43:51,370 --> 04:43:56,730
因为我们没有为这个总体平均值函数定义一个捕获所有子句，所以让我们

2585
04:43:56,730 --> 04:44:03,170
在这里定义一个子句，所以在这里我们可以说定义总体平均值，在这种情况下

2586
04:44:03,170 --> 04:44:10,530
只是希望忽略该参数，并希望返回我们的错误，错误信息为无效数据

2587
04:44:10,530 --> 04:44:16,930
打开终端机让我重新编译我们的mean模组，让我先清除一下

2588
04:44:16,930 --> 04:44:22,490
让一切归零，让我们再试一次相同的语句，这样这次我们会得到一个很好的错误提示

2589
04:44:22,490 --> 04:44:28,970
那个错误，无效的数据类型，这就是我们如何创建样本均值，但我们还没完成

2590
04:44:28,970 --> 04:44:34,950
我们还需要实现样本均值，但幸运的是样本均值和母体均值的公式是相同的

2591
04:44:34,950 --> 04:44:41,290
平均值是相同的，所以让我们非常快速地实现我们的样本均值，让我把所有的都拿出来

2592
04:44:41,290 --> 04:44:47,190
注释我不需要注释，让我在顶部贴上分隔线，现在让我再次

2593
04:44:47,190 --> 04:44:52,030
复制这个分隔线，让我们在这里创建一个样本均值的额外函数

2594
04:44:52,030 --> 04:44:57,230
所以在这里我们可以说我们想要为我们的样本均值定义一个函数，现在这个函数

2595
04:44:57,230 --> 04:45:04,050
接受一个数字列表，我们只需要调用我们的母体均值并传递我们的列表

2596
04:45:04,050 --> 04:45:09,770
的数字，这就是了，现在我们有了样本均值和母体均值的函数

2597
04:45:09,770 --> 04:45:15,330
让我们也为这个函数定义规格，这样我们可以说规格是

2598
04:45:15,330 --> 04:45:27,210
对于我们的总体均值，这个函数现在接收一个数字列表，这个函数将会

2599
04:45:27,210 --> 04:45:34,310
错误是这样的，第一个元素是原子，第二个元素是字符串类型的

2600
04:45:34,310 --> 04:45:40,810
让我也为样本均值复制这个规格，让我把它粘贴到这里，然后

2601
04:45:40,810 --> 04:45:47,730
我把名称从总体改为样本，接下来我们还可以做一些更改来改进我们的

2602
04:45:47,730 --> 04:45:53,370
现在如果你看到这个计算总体均值的函数和这个均值函数

2603
04:45:53,370 --> 04:45:59,330
这些函数只是我们的私有函数，所以让我们把它们声明为私有的，这样它就变成了

2604
04:45:59,330 --> 04:46:05,770
我们的p定义，这也变成了我们的私有函数，对于我们的均值也是同样的情况

2605
04:46:05,770 --> 04:46:11,670
好吧，这也变成了我们的私有函数，现在让我打开终端，让我们尝试重新编译一下

2606
04:46:11,670 --> 04:46:17,570
这一次让我清除一切，让我们尝试调用相同的函数一次

2607
04:46:17,570 --> 04:46:25,470
让我们再花一些时间来传递10、20和30的列表，这是用于总体均值的，我们试试看。

2608
04:46:25,470 --> 04:46:31,610
对于样本均值也是一样，所以让我用样本均值来替换，然后我们得到

2609
04:46:31,610 --> 04:46:37,410
相同的答案。现在的情况是，每次我们都必须创建一个别名，但是相反的是，

2610
04:46:37,410 --> 04:46:44,930
我们可以将我们的公共API与私有API分开，所以如果我打开边栏，我们有

2611
04:46:44,930 --> 04:46:51,970
stats.ex模块，正如你所见，这个文件什么都没做，所以我们想要做的是

2612
04:46:51,970 --> 04:46:59,230
我们希望将这个stats文件作为我们的公共API，所以我的意思是最终用户可以

2613
04:46:59,230 --> 04:47:05,230
只需引用这个单独的文件来使用所有功能，让我来演示一下我们如何做到这一点

2614
04:47:05,230 --> 04:47:10,750
让我把这些东西都拿出来，这些都不需要的，让我折叠边栏，然后让我们

2615
04:47:10,750 --> 04:47:16,270
一个用于总体均值的函数就在这里，这个函数接收我们的列表

2616
04:47:16,270 --> 04:47:21,470
然后我们可以从这里简单地调用我们的总体均值函数，所以我们可以说

2617
04:47:21,470 --> 04:47:28,310
我们想为我们的stats.dot.central tendency.mean函数创建一个别名。

2618
04:47:28,310 --> 04:47:35,250
我们可以简单地委托给mean.dot.population mean，让我们传递一个数字的参数。

2619
04:47:35,250 --> 04:47:41,410
我们已经大大简化了我们的API，现在让我打开终端，重新编译一下。

2620
04:47:41,410 --> 04:47:48,090
统计模块，让我清理一下，现在我们可以简单地调用stats.dot。

2621
04:47:48,090 --> 04:47:55,590
population mean，并让我们传递参数10、20和30，我们会得到正确的答案。

2622
04:47:55,590 --> 04:48:02,510
现在让我们回到我们的代码中，我们可以对这个做一个小小的改进，现在不是。

2623
04:48:02,510 --> 04:48:08,570
调用这个函数，我们可以使用一个叫做def delegate的东西，所以首先让我展示一下。

2624
04:48:08,570 --> 04:48:14,150
你，然后我可以解释给你听，所以在这里我们可以使用一个叫做def delegate的新关键字。

2625
04:48:14,150 --> 04:48:20,110
第一个参数是我们的函数的名字，所以我们的函数的名字是population mean。

2626
04:48:20,110 --> 04:48:25,590
所以让我把它粘贴到这里，现在这个函数还接受一个参数，这个参数。

2627
04:48:25,590 --> 04:48:31,430
这是我们数字列表的一部分，现在我们要做的就是将它委托给我们的模块。

2628
04:48:31,430 --> 04:48:38,850
将这个函数委托给我们的平均值模块，就是这样，第四行和第五行做的就是这个。

2629
04:48:38,850 --> 04:48:44,710
完全一样，所以让我对这一行进行注释，这是不必要的，让我打开我的终端。

2630
04:48:44,710 --> 04:48:50,830
让我们重新编译统计模块，让我把一切清理干净，然后让我调用同样的函数。

2631
04:48:50,830 --> 04:48:57,630
再试一次，正如预期的那样，这个工作得很好，让我们再创建一个def委托。

2632
04:48:58,250 --> 04:49:04,210
所以在这里，我们只需要把名称从总体均值改为样本均值，这样每当我们...

2633
04:49:04,210 --> 04:49:10,850
调用stats.dot样本均值时，该函数将委托给mean.dot样本均值，让我打开。

2634
04:49:10,850 --> 04:49:17,570
我的终端，让我们重新编译相同的模块，让我清理一切，这样我可以说...

2635
04:49:17,570 --> 04:49:23,830
这次我想计算样本均值，让我传入3、4、...

2636
04:49:23,830 --> 04:49:29,490
5、6和7，这次我们得到的答案是5，好了，这个视频到此结束。

2637
04:49:29,490 --> 04:49:34,470
而且我会在下一个中抓住你，现在让我们继续下一部分，看看如何

2638
04:49:34,470 --> 04:49:41,050
我们可以计算一些被称为中位数的东西，现在我所做的是在幕后

2639
04:49:41,050 --> 04:49:48,050
我创建了一个名为中位数的新文件，并且为此定义了模型

2640
04:49:48,530 --> 04:49:56,010
简单来说，我添加了很多文档，让我们看看中位数的确切含义

2641
04:49:56,010 --> 04:50:02,550
让我们来看看这个场景，假设路易斯在卖糖果

2642
04:50:02,550 --> 04:50:10,950
连续九个小时，这些是每个小时的糖果销量，第一个小时

2643
04:50:10,950 --> 04:50:17,530
路易斯在第一小时卖出了10颗糖果，第二小时卖出了40颗糖果，第三小时卖出了

2644
04:50:17,530 --> 04:50:25,190
以此类推，这些是路易斯在连续九个小时内每个小时卖出的糖果数量

2645
04:50:25,190 --> 04:50:31,670
在他的工作时间内，让我们看看中位数的确切含义，中位数什么都不是，它只是

2646
04:50:31,670 --> 04:50:38,890
一个中心值，或者说它只是将测量结果分为两个相等部分的值

2647
04:50:39,370 --> 04:50:45,730
所以我们想要达到的目标是找到一个能够将我们的测量结果分成两部分的值

2648
04:50:45,730 --> 04:50:52,530
前50%和后50%，计算中位数也非常容易，所以这是

2649
04:50:52,530 --> 04:50:59,290
一个非常简单的计算中位数的算法，我们算法的第一步是

2650
04:50:59,290 --> 04:51:05,710
对我们的列表进行排序，所以在这里我们可以看到我们有一个按糖果销售额排序的列表

2651
04:51:05,710 --> 04:51:13,010
前九个小时，我们算法的第二部分是需要计算元素的数量

2652
04:51:13,010 --> 04:51:20,350
在我们的列表中，现在有两种情况，第一种是如果我们的计数是奇数，第二种是

2653
04:51:20,350 --> 04:51:29,090
如果计数是偶数，那么如果计数是奇数，事情就非常简单，我们只需要

2654
04:51:29,090 --> 04:51:36,650
取中间的值，这个值就成为我们的中位数，所以例如在这个例子中，50就是

2655
04:51:36,650 --> 04:51:44,090
我们左边有四个值，右边也有四个值，所以50就成为我们的

2656
04:51:44,090 --> 04:51:51,830
中位数，下一个情况是如果计数是偶数，那么我们要做的是

2657
04:51:51,830 --> 04:51:59,710
我们从中心取两个值，所以在这种情况下，40和50是两个值，现在请看一下。

2658
04:51:59,710 --> 04:52:06,010
这个列表只包含八个值，我从这个列表中取出了最后一个值90。

2659
04:52:06,010 --> 04:52:12,990
现在，由于这是一个偶数列表，我们只需从中心取两个值，所以我们有40和50。

2660
04:52:12,990 --> 04:52:18,530
作为中心，正如你所看到的，左边有三个值，右边也有三个值。

2661
04:52:18,530 --> 04:52:25,150
然后我们简单地对它们取平均值，所以40加50除以2，我们得到的答案是。

2662
04:52:25,150 --> 04:52:33,170
45，45成为你的中位数，这就是我们将要实现的算法。

2663
04:52:33,170 --> 04:52:38,230
计算中位数，让我们看看如何将所有这些内容转化为代码。

2664
04:52:38,230 --> 04:52:44,810
让我回到顶部，在这里我们可以看到我定义了一个名为stats点的模块。

2665
04:52:44,810 --> 04:52:51,610
中央趋势点中位数，现在让我们开始吧，让我们定义第一个。

2666
04:52:51,610 --> 04:52:57,810
函数，让我们将函数称为中位数，这个函数将接受一个列表。

2667
04:52:57,810 --> 04:53:03,930
所以我们可以将参数称为数字列表，让我们也在这里使用守卫

2668
04:53:03,930 --> 04:53:10,510
所以我们可以说当它是一个列表时，让我们传递我们的数字列表的参数

2669
04:53:11,070 --> 04:53:16,730
所以这是一个场景，下一个场景可能是我们在这里没有得到一个合适的列表

2670
04:53:16,730 --> 04:53:23,490
所以为了处理这种情况，让我们定义一个更多的版本，所以我们可以说中位数我们只想

2671
04:53:24,050 --> 04:53:31,110
输入，我们只想抛出一个错误，但首先我们需要创建一个别名，所以非常简单

2672
04:53:31,110 --> 04:53:41,390
对我们来说很容易使用这些模块，所以让我为我们的stats.dot.errors创建一个别名，这里我们可以

2673
04:53:41,390 --> 04:53:49,410
说我们只想返回我们的errors.dot.invalid data type，现在让我们回到这个

2674
04:53:49,410 --> 04:53:56,010
函数，让我们看看如何实现这个，所以第一件事是我们需要验证我们的

2675
04:53:56,010 --> 04:54:02,970
数字列表，所以再让我在顶部创建一个别名，这里我可以说我们想要

2676
04:54:02,970 --> 04:54:10,270
创建另一个别名，这次是为了stats.dot.our.validators，现在让我们继续执行

2677
04:54:10,270 --> 04:54:16,610
在这里，我们可以简单地使用我们的数字列表，然后

2678
04:54:16,610 --> 04:54:24,650
将数字列表传递到我们的validators dot validate numbers
list函数中，然后在验证完成后

2679
04:54:24,650 --> 04:54:31,130
我们可以将我们的数字列表传递给另一个名为calculate的函数

2680
04:54:31,130 --> 04:54:38,190
中位数，现在我们还没有这个函数，但我们很快会创建它

2681
04:54:38,190 --> 04:54:45,870
定义calculate median函数的代码行在这里，让我稍微滚动一下

2682
04:54:45,870 --> 04:54:51,990
以便一切都能看到，现在让我们看看这个函数将接收到什么

2683
04:54:51,990 --> 04:54:58,290
函数validate numbers list的输出将被传递到calculate函数中

2684
04:54:58,290 --> 04:55:05,330
中位数，正如您所见，这个函数要么返回一个布尔值和我们的数字列表，要么

2685
04:55:05,330 --> 04:55:15,370
返回项目以及错误消息，因此让我们在各种情况下进行匹配

2686
04:55:15,370 --> 04:55:15,830
看看我们可以用这个函数做什么，比如说我们想创建一个错误，最

2687
04:55:15,830 --> 04:55:23,470
最简单的方法就是处理错误，这样如果我们获得这样的输入，就会得到一个错误和

2688
04:55:23,470 --> 04:55:31,090
第二个参数是一条消息，这时我们可以简单地返回错误和元组

2689
04:55:31,090 --> 04:55:37,590
不对消息做任何处理，或者我们可以简单地使用错误模块，所以你可以

2690
04:55:37,590 --> 04:55:45,350
这样做，或者我们可以简单地调用错误点无效数据类型，现在让我们看看我们还能做什么

2691
04:55:45,350 --> 04:55:52,850
这个函数，现在验证数字列表的函数也可以给我们一个元组，其中第一个

2692
04:55:52,850 --> 04:55:59,290
参数是一个布尔值，第二个参数是数字列表，所以让我们在模式匹配上

2693
04:55:59,290 --> 04:56:04,750
这种情况，让我们看看我们如何处理这个，让我定义另一个函数

2694
04:56:04,750 --> 04:56:10,410
还有一件事，我们可以简单地将此函数标记为私有函数，因为这个函数

2695
04:56:10,410 --> 04:56:14,810
将成为我们的辅助函数，我们不想在外部公开功能

2696
04:56:15,470 --> 04:56:20,950
所以我只是将此函数标记为私有函数，现在让我们再进行一次模式匹配

2697
04:56:20,950 --> 04:56:28,010
就在这里，如果第一个参数为假，那么我们可以简单地忽略第二个参数。

2698
04:56:28,010 --> 04:56:33,850
忽略第二个参数，我们不需要第二个参数，所以在这种情况下也是如此。

2699
04:56:33,850 --> 04:56:40,570
验证失败，让我们再次返回错误，我们可以说错误.无效。

2700
04:56:40,570 --> 04:56:46,570
数据类型，现在让我们也定义第三种情况，所以让我们再次定义私有函数。

2701
04:56:47,690 --> 04:56:54,010
计算中位数，这次它接收一个元组，其中第一个参数是真。

2702
04:56:54,010 --> 04:57:01,210
第二个参数是我们的数字列表，让我们看看如何定义它的主体部分。

2703
04:57:01,210 --> 04:57:07,590
计算中位数函数，让我们稍微上升一点，看看我们的算法。

2704
04:57:07,590 --> 04:57:15,230
所以对于算法，我们需要做两件事，我们需要进行排序，还需要进行计数。

2705
04:57:15,230 --> 04:57:20,470
让我们在这个函数中实现这些步骤，就在这里计算中位数，所以在这里我们可以。

2706
04:57:20,470 --> 04:57:27,210
我们可以做的是，我们可以使用内置模块来获取数字列表并对其进行排序。

2707
04:57:27,210 --> 04:57:35,770
枚举，所以我们可以说枚举排序，现在我们有了一个排序好的元素列表，现在第二个

2708
04:57:35,770 --> 04:57:42,670
我们需要计算元素的数量是偶数还是奇数，根据这个来决定

2709
04:57:42,670 --> 04:57:48,570
我们必须处理两种不同的情况，所以第一种情况是如何计算

2710
04:57:48,570 --> 04:57:55,270
当计数为奇数时计算中位数，第二种情况是当计数为偶数时计算中位数

2711
04:57:55,270 --> 04:58:02,310
当长度为偶数时，我们需要创建另一个辅助函数，所以我们可以

2712
04:58:02,310 --> 04:58:09,730
做的是我们可以将enum dot sort的输出作为参数传递给另一个函数

2713
04:58:09,730 --> 04:58:16,010
名称为get median的函数，现在我们还没有这个函数，但是我们很快就会创建它，现在这个

2714
04:58:16,010 --> 04:58:21,870
get median函数将接收三个不同的参数，第一个参数是

2715
04:58:22,510 --> 04:58:28,890
排序好的列表，第二个参数将是一个布尔值，所以我们将检查数字是否是

2716
04:58:28,890 --> 04:58:35,690
奇数还是偶数，第三个参数将是计数本身，所以让我们传递参数给

2717
04:58:35,690 --> 04:58:41,730
这个函数现在第二个参数将是一个布尔值，我们可以检查

2718
04:58:41,730 --> 04:58:48,750
计数是奇数还是偶数，可以使用另一个名为整数的内置模块来调用

2719
04:58:48,750 --> 04:58:56,310
整数的内置模块，我们可以在这里使用内置的is even函数，并让我们传递

2720
04:58:56,310 --> 04:59:03,470
现在为了计算计数，我们可以说数字列表，然后我们可以管道传输

2721
04:59:03,470 --> 04:59:10,810
这个传递到另一个名为枚举点计数的函数中，get函数的下一个参数

2722
04:59:10,810 --> 04:59:16,830
中位数将是计数本身，所以在这里我们可以说数字列表

2723
04:59:16,830 --> 04:59:24,310
然后我们可以将输出管道传输到枚举点计数，现在你可以看到我们有一点点

2724
04:59:24,310 --> 04:59:31,090
重复，所以我们可以把这个从这里拿出来，让我创建一个变量

2725
04:59:31,090 --> 04:59:39,670
称为计数，让我把它放在这里，我们可以简单地用变量替换它

2726
04:59:39,670 --> 04:59:46,810
计数，这也会被计数的变量替换，现在要做的最后一件事就是我们只需要

2727
04:59:46,810 --> 04:59:54,130
需要定义获取中位数的函数，让我在这里使用分隔符，让我

2728
04:59:54,130 --> 05:00:01,330
创建获取中位数的函数，现在这个函数接收三个参数，第一个

2729
05:00:01,330 --> 05:00:07,850
参数是我们的数字列表，第二个参数实际上是一个布尔值

2730
05:00:07,850 --> 05:00:13,690
所以现在让我先写成布尔值，第三个参数将是计数，现在让我们看一下

2731
05:00:13,690 --> 05:00:19,410
现在我们可以用这个函数做什么，对于这个函数，我们再次有两种情况，所以如果

2732
05:00:19,410 --> 05:00:26,230
我们回到算法，第一种情况是奇数，第二种情况是偶数，所以我们

2733
05:00:26,230 --> 05:00:32,750
可以做的是我们可以在这里简单地使用模式匹配，所以这个整数点甚至会

2734
05:00:32,750 --> 05:00:39,890
给我们一个布尔值，要么是true要么是false，所以我们在这里可以做的是让我们进行模式匹配

2735
05:00:39,890 --> 05:00:48,250
那么这意味着这个列表不是偶数，也就是说这个列表将是奇数，而且由于这个列表

2736
05:00:48,250 --> 05:00:54,590
将是奇数，我们只需取中间的元素并将其返回即可

2737
05:00:54,590 --> 05:01:01,430
幸运的是，这很容易，我们将使用内置的enum模块，然后

2738
05:01:01,430 --> 05:01:07,590
有一个内置函数叫做at，这个函数接受两个不同的参数，第一个是

2739
05:01:07,590 --> 05:01:14,730
将是我们的数字列表，第二个参数将是索引，所以对于

2740
05:01:14,730 --> 05:01:21,530
索引，我们可以简单地取出计数，然后将计数除以二，现在

2741
05:01:21,530 --> 05:01:29,190
这里有一个小问题，将计数除以二实际上会返回一个浮点数

2742
05:01:29,190 --> 05:01:36,790
而索引值不能是浮点数，所以假设这个值返回一个整数，如4.5

2743
05:01:36,790 --> 05:01:43,610
那么在这种情况下，我们没有任何值，或者说我们没有任何叫做4.5的索引

2744
05:01:43,610 --> 05:01:50,270
所以我们需要做的是进行整数除法，而不是浮点除法

2745
05:01:50,270 --> 05:01:56,330
所以为了确保我们得到一个整数，我们可以使用内置函数

2746
05:01:56,330 --> 05:02:02,930
除法，所以第一个参数将是计数，第二个参数将是

2747
05:02:02,930 --> 05:02:10,130
现在这个函数必须是私有的，所以让我将它定义为def和p，这样

2748
05:02:10,130 --> 05:02:17,190
这是列表奇数的第一种情况，第二种情况是列表是偶数时发生的情况

2749
05:02:17,190 --> 05:02:24,950
所以让我将所有这些都复制过来，然后粘贴到这里，现在是第二种情况

2750
05:02:24,950 --> 05:02:31,770
情况是列表是偶数，所以我们在这里得到一个true，让我们看看我们应该做什么

2751
05:02:31,770 --> 05:02:38,270
在这种情况下应该做什么，所以如果你回到算法，我们必须取两个值

2752
05:02:38,270 --> 05:02:45,430
从中心取值，然后我们只需将它们除以二并返回值

2753
05:02:45,430 --> 05:02:51,330
现在让我们在这里做这些事情，我们可以创建两个变量

2754
05:02:51,330 --> 05:02:59,110
保存从中心取得的值，我们可以说第一个变量是a，让我复制这个

2755
05:02:59,110 --> 05:03:06,450
从这里开始就是这个函数，现在在这种情况下，我们必须取一个先前的值，所以如果我回去

2756
05:03:06,450 --> 05:03:13,150
我们要取这个值，也就是在这里，所以我们可以说计数

2757
05:03:13,670 --> 05:03:20,630
减去一个，然后我再复制粘贴给下一个值，我们不需要减去一个

2758
05:03:21,170 --> 05:03:28,610
让我们把那个变量称为b，现在我们有了来自中心的两个值，我们只需要

2759
05:03:28,610 --> 05:03:37,690
加上b，然后我们只需要将它们除以二，就这样，现在我保存后

2760
05:03:37,690 --> 05:03:43,450
我的文件中，我们可以看到我们在这里得到了一个小错误，那么这是在说什么呢？

2761
05:03:43,450 --> 05:03:50,410
在调用宏之前，你必须要求整数，所以发生的情况是，Elixir实际上是

2762
05:03:50,410 --> 05:03:58,410
使用宏，所以宏是一种生成另一段代码的代码，但现在我们不需要

2763
05:03:58,410 --> 05:04:04,350
去关注细节，我们只需要按照这个错误信息告诉我们的去做，所以如果

2764
05:04:04,350 --> 05:04:11,850
你只需要查看消息，它是在说我们只需要要求整数，所以我们就按照这个要求去做

2765
05:04:11,850 --> 05:04:19,130
同样的事情，让我回到顶部，在这里我可以说我想要要求整数模块

2766
05:04:19,130 --> 05:04:26,730
整数，就这样，现在错误应该消失了，是的，现在所有的错误都解决了

2767
05:04:26,730 --> 05:04:34,390
最后一件事是让我们进入我们的公共API，让我们进入lib文件夹，在lib文件夹下面让我们进入

2768
05:04:34,390 --> 05:04:41,330
stats模块，让我们在这里创建一个def代理，同时让我们使用

2769
05:04:41,330 --> 05:04:48,570
def代理的宏，我们可以说我们想定义中值函数，现在这个函数

2770
05:04:48,570 --> 05:04:55,970
接受我们数字的列表，我们只想将这个函数委托给模块

2771
05:04:55,970 --> 05:05:01,850
中值，但在此之前，让我们在顶部创建一个别名，这样我们可以导入

2772
05:05:01,850 --> 05:05:08,490
在同一行上导入不同的模块，所以我们可以说我也想在这里导入中值

2773
05:05:08,890 --> 05:05:15,530
现在在第九行我们只是想将执行委托给中值模块

2774
05:05:15,530 --> 05:05:23,370
现在让我打开终端，让我进入ix，并让我清理一切

2775
05:05:23,370 --> 05:05:30,970
所以在这里让我们尝试调用那个函数，所以我们可以说stats中的中值，让我们创建一个列表

2776
05:05:30,970 --> 05:05:37,890
就在这里，让我传递这些值，这样我们就可以看到我们得到的值是50

2777
05:05:37,890 --> 05:05:44,450
现在我所做的是这是我们奇数的列表，接下来让我再传递一个列表

2778
05:05:44,450 --> 05:05:52,070
有偶数，所以让我把90拿出来，我不需要90，而且在这种情况下我们得到的是

2779
05:05:52,070 --> 05:05:58,130
值是45，就是这样，这个视频到此为止，我会在下一个视频中见到你们

2780
05:05:58,670 --> 05:06:04,490
大家好，欢迎来到这个系列的最后一个视频，所以最后一个视频是关于学习的

2781
05:06:04,490 --> 05:06:10,470
有一种被称为众数的东西，那么众数到底是什么，让我来尝试解释一下

2782
05:06:10,470 --> 05:06:14,710
但在此之前，我所做的是在幕后创建了这个文件

2783
05:06:14,710 --> 05:06:22,930
在集中趋势中的mode.ex，现在让我们看看如何找到我们元素的众数

2784
05:06:22,930 --> 05:06:31,590
那么，我们所说的众数到底是什么，众数基本上是最常重复的元素

2785
05:06:31,590 --> 05:06:39,110
例如，如果我们有这个数值数组，那么这些数值的众数将是这些数值

2786
05:06:39,110 --> 05:06:44,930
重复次数最多的值，现在在这个例子中，重复次数最多的值是四和八

2787
05:06:44,930 --> 05:06:51,470
这就是为什么这个模式是四和八，现在你一定在想模式有什么用

2788
05:06:51,470 --> 05:06:57,530
所以让我试着帮你解释一下为什么模式非常重要，现在假设这些值实际上

2789
05:06:57,530 --> 05:07:04,990
代表路易斯正在销售的糖果的产品ID，例如一个可能是

2790
05:07:04,990 --> 05:07:11,890
红色糖果的产品ID，二可以是黄色糖果的产品ID，三可以是

2791
05:07:11,890 --> 05:07:19,130
绿色糖果的产品ID，通过找到模式，我们可以了解路易斯能够销售哪些糖果

2792
05:07:19,130 --> 05:07:26,310
最多的，所以在这个例子中，我们可以说ID为四的糖果和ID为八的糖果

2793
05:07:26,310 --> 05:07:32,290
是店里最受欢迎的糖果，让我们看看如何找到

2794
05:07:32,290 --> 05:07:38,770
更多，我在这里给出了步骤，基本上是一个三步过程，第一步是我们

2795
05:07:38,770 --> 05:07:45,450
需要找到发生的次数或频率，然后我们需要找到最大值

2796
05:07:45,450 --> 05:07:51,950
发生次数，最后我们需要将具有最大发生次数的元素进行分组

2797
05:07:51,950 --> 05:07:57,290
这次，不直接编写代码，让我来演示一下在ix中如何找到解决方案。

2798
05:07:57,290 --> 05:08:04,330
找到这个问题的解决方案，让我复制一下，然后打开我的终端。

2799
05:08:04,330 --> 05:08:12,370
让我进入我的ix，并清理屏幕。现在，如果我们参考一下步骤，第一步是...

2800
05:08:12,370 --> 05:08:18,790
我们必须找到出现次数或频率，所以让我把值粘贴过来。

2801
05:08:18,790 --> 05:08:25,390
在这里，我们可以通过使用内置函数来找出频率，所以我们可以将这些值连接起来。

2802
05:08:25,390 --> 05:08:33,890
到enum dot frequencies，就是这样，现在我们有了所有的值及其频率。

2803
05:08:33,890 --> 05:08:40,070
好吧，我想要做的是将这个简单地保存在一个叫作的变量中。

2804
05:08:40,070 --> 05:08:47,450
ranked map，现在我们有了一个有序映射，下一步是找到最大的次数。

2805
05:08:47,450 --> 05:08:54,550
出现次数，让我们看看如何做到这一点，让我清理一下屏幕，现在我们有了排名映射。

2806
05:08:55,190 --> 05:09:01,430
为了找出最大的次数，我们可以使用排名映射。

2807
05:09:01,430 --> 05:09:08,530
从这个地图上，我们只需要取出值，所以我们可以说map.values，让我们看看它是什么样子

2808
05:09:08,530 --> 05:09:15,510
看起来就像这样，这些只是值，下一步，我们只需要找到最大值

2809
05:09:15,510 --> 05:09:23,090
从这个地图中，我们可以将它传递给另一个名为enum的函数

2810
05:09:23,090 --> 05:09:30,810
max，就是它了，重复次数最多的值是三次，如果我们参考一下

2811
05:09:30,810 --> 05:09:36,610
我们的地图，我们可以看到四重复三次，八也重复三次

2812
05:09:37,450 --> 05:09:43,770
现在有一个小问题，如果元素没有重复出现，那么就无法找到众数

2813
05:09:43,770 --> 05:09:50,190
在这种情况下，我们无法找到众数，但是如果我们有重复出现的元素

2814
05:09:50,190 --> 05:09:57,550
只要重复一次，那么我们就可以找到一个有效的众数，所以现在让我做一件事，让我复制这个

2815
05:09:57,550 --> 05:10:04,890
并将其保存到另一个名为max的变量中，让我清理所有这些东西

2816
05:10:04,890 --> 05:10:11,710
所以现在我们有了排名地图，我们也有了最大计数，下一步，我们只需要

2817
05:10:11,710 --> 05:10:18,930
对这个排名地图进行筛选，找出最大出现次数的元素。在这种情况下，我们看到数字4出现了四次。

2818
05:10:18,930 --> 05:10:24,650
数字4重复了三次，数字8也重复了三次，所以我们只需将它们筛选出来。

2819
05:10:24,650 --> 05:10:31,030
我们该如何做呢？我们可以取出排名地图，然后使用...

2820
05:10:31,030 --> 05:10:38,790
函数名为map.filter，它接受两个参数，第一个是地图（map），还有...

2821
05:10:38,790 --> 05:10:44,770
第二个参数是匿名函数，现在我们来编写一个函数，对于每个...

2822
05:10:44,770 --> 05:10:51,950
在每次迭代中，这个函数将接收到来自地图的键和值对，然后...

2823
05:10:51,950 --> 05:10:58,570
在每次迭代中，我们只需筛选出值等于最大值的元素。

2824
05:10:58,570 --> 05:11:05,710
现在我们有了一个经过筛选的地图，下一步我们只需取出键即可。

2825
05:11:05,710 --> 05:11:12,530
那么我们看看如何实现这一点，我们可以采用相同的表达式，然后...

2826
05:11:12,530 --> 05:11:19,730
我们只需从地图中取出键，就完成了。我们得到了最终答案，我们继续进行吧。

2827
05:11:19,730 --> 05:11:25,130
回到代码编辑器，让我们看看如何在这里完成所有这些事情。

2828
05:11:25,130 --> 05:11:30,390
例如，我不会进行所有的验证和错误报告，因为我想你应该知道。

2829
05:11:30,390 --> 05:11:36,270
如何完成所有这些事情，让我们直接进入并看看如何编写这些函数。

2830
05:11:36,270 --> 05:11:43,350
那么让我来处理所有这些事情，我们在这里定义一个函数，我们可以说

2831
05:11:43,350 --> 05:11:49,590
我们想要定义一个名为mode的函数，这个函数接收一个参数，它是

2832
05:11:49,590 --> 05:11:57,290
数字列表，所以我可以在这里添加一个保护，这是我的数字列表，如果你

2833
05:11:57,290 --> 05:12:01,710
如果你愿意，你可以进行所有额外的验证，但对于这个视频，我不会进行验证。

2834
05:12:01,710 --> 05:12:08,670
所以第一步是找到频率，让我创建一个名为ranked map的变量

2835
05:12:08,670 --> 05:12:15,390
在这里，我们可以简单地取出这些数字，并将这些数字传递给enum。

2836
05:12:16,850 --> 05:12:23,790
接下来，我们可以尝试找到最大出现次数，所以为此我们可以这样做。

2837
05:12:23,790 --> 05:12:31,490
我们可以做的是，我们可以获取排名映射，然后将此函数传递给map.values，这样我们现在就有了所有的值

2838
05:12:31,490 --> 05:12:37,270
我们现在拥有了所有的值，接下来让我们找出最大的出现次数，这样我们就能

2839
05:12:37,270 --> 05:12:44,830
将其传递给另一个函数enum.max，这样我们就有了排名映射，还有

2840
05:12:44,830 --> 05:12:50,950
最大的出现次数，现在我们只需要过滤掉我们的

2841
05:12:50,950 --> 05:12:58,390
排名映射，为此让我们创建一个辅助函数，所以在这里让我们将其传递给另一个

2842
05:12:58,390 --> 05:13:04,530
名为mode func的函数，现在这个函数将接受两个参数

2843
05:13:04,530 --> 05:13:10,450
第一个参数是最大的出现次数，第二个参数是

2844
05:13:10,450 --> 05:13:18,370
排名映射本身，所以让我定义一个私有函数mode of func，现在这个函数接受

2845
05:13:18,370 --> 05:13:24,390
两个参数，第一个参数是最大的出现次数，第二个参数是

2846
05:13:24,390 --> 05:13:31,170
我们排名的映射，现在我们需要注意另一个条件，那就是

2847
05:13:31,170 --> 05:13:38,330
只有当出现次数超过一次时，我们才能找到更多的内容，所以对于这个函数定义

2848
05:13:38,330 --> 05:13:45,090
让我们在这里进行模式匹配，这样我们就可以看到，如果最大数量的

2849
05:13:45,090 --> 05:13:51,190
出现次数为一，那么我们只需要忽略排名映射，因为我们无法找到

2850
05:13:51,190 --> 05:13:57,570
众数，我们只需要返回nil，但是如果出现次数超过

2851
05:13:57,570 --> 05:14:04,190
一次，为了处理这种情况，让我们在这里定义一个额外的函数重载，这样我们就能

2852
05:14:04,190 --> 05:14:11,010
说出func的众数，并且第一个参数是最大值，第二个参数是我们的

2853
05:14:11,010 --> 05:14:18,010
排名映射，所以让我们拿出排名映射，然后我们只需要过滤掉，这样我们就可以说

2854
05:14:18,010 --> 05:14:23,890
map.过滤器，这里让我们定义匿名函数，这样我们就可以说函数

2855
05:14:23,890 --> 05:14:31,210
现在对于每次迭代，它将接收键和值，我们需要做的是

2856
05:14:31,210 --> 05:14:38,770
我们只需要在值等于最大值时将其过滤掉，最后我们只需要

2857
05:14:38,770 --> 05:14:47,250
必须从这个中取出键，这样我们就可以说map.keys，现在要做的最后一件事是让

2858
05:14:47,250 --> 05:14:54,510
让我们转到我们的stats.ex，并在这里创建一个def代理，这样我们就可以说def

2859
05:14:54,510 --> 05:15:02,370
代理，让我们为mode创建一个函数，这也接受我们的数字列表，我们只需

2860
05:15:02,370 --> 05:15:08,770
想将这个委派给模块mode，但首先让我们在这里导入它，这样我们就可以

2861
05:15:08,770 --> 05:15:15,930
说我们还想导入mode，这个我们只想委派给mode，现在让我折叠

2862
05:15:15,930 --> 05:15:23,090
我的侧边栏，让我打开终端，现在让我们重新编译一次，让我清空

2863
05:15:23,090 --> 05:15:29,810
所有的东西，这样现在我们就可以调用stats.mode，并让我在这里传递值

2864
05:15:30,330 --> 05:15:36,910
正如预期的那样，我们得到的答案是四和八，好，这就是我们这个的结束

2865
05:15:36,910 --> 05:15:42,950
当然，在我说出我的最后话之前，我想向你展示一些东西，现在，如果

2866
05:15:42,950 --> 05:15:48,730
你参考我的github存储库中的代码，这是一个现在在我的官方github里的

2867
05:15:48,730 --> 05:15:55,250
我所做的是，在存储库中实现了两个更多的功能，它们位于文件夹下面。

2868
05:15:55,250 --> 05:16:02,730
第一个是关于变异性的，第二个是关于标准差的。

2869
05:16:02,730 --> 05:16:08,770
因为我认为它们与数学建模和统计有关，所以我不打算在本教程系列中涵盖这些部分。

2870
05:16:08,770 --> 05:16:15,230
这部分涉及到你的数学建模和统计，而这门课程旨在为您提供一个公正的

2871
05:16:15,230 --> 05:16:20,970
有关Elixir函数式编程的概念，但我将它们保留作为参考，您可以参考它们。

2872
05:16:20,970 --> 05:16:27,710
您可以看到我如何为统计建模方差和标准差，这就是

2873
05:16:27,710 --> 05:16:33,410
我就是这些了，下次见。嗨，我希望您在学习函数式编程时真的很开心。

2874
05:16:33,410 --> 05:16:38,070
与我一起学习编程，现在这门课程旨在教您所有基础

2875
05:16:38,070 --> 05:16:44,450
函数式编程语言的概念，但Elixir还有更多要学习的，接下来的事情

2876
05:16:44,450 --> 05:16:50,130
您将想要学习的是关于并发和OTP框架的一切，之后您可以

2877
05:16:50,130 --> 05:16:54,410
学习并发框架，然后你可以继续学习令人惊叹的凤凰框架。

2878
05:16:54,410 --> 05:16:59,870
还有框架。现在回到这门课程，如果你觉得函数式编程有些困难，

2879
05:16:59,870 --> 05:17:06,230
这不是你的错，需要一些时间、耐心和练习，才能够。

2880
05:17:06,230 --> 05:17:11,570
掌握了函数式编程语言之后，

2881
05:17:11,570 --> 05:17:16,690
相信我，你再也不会回到面向对象编程或者

2882
05:17:16,690 --> 05:17:23,070
命令式编程范式。所以让我总结一下这门课程，也让我总结一下这个视频。

2883
05:17:23,730 --> 05:17:29,270
请在评论中告诉我你对这门课程的看法，你也可以与我联系。

2884
05:17:29,270 --> 05:17:35,130
我的网站是octalium.com，你也可以在Twitter上关注我，我的用户名是@octalium。

2885
05:17:35,130 --> 05:17:40,150
如果你慷慨的话，你可以给我买杯咖啡，网址是buymeocoffee.com。

2886
05:17:41,210 --> 05:17:46,290
octalium，如果你想学习更多的概念，请告诉我。

2887
05:17:46,290 --> 05:17:52,050
想学习 OTP 框架，Phoenix 框架，或者如果你想学习数学的话

2888
05:17:52,050 --> 05:17:56,760
或者从我这里学习统计建模或者其他你想学的主题

2889
05:17:57,390 --> 05:18:01,270
这就是我要说的了，下次见，再见

