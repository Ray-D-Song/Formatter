1
00:00:00,000 --> 00:00:06,600
欢迎来到这个完整的Elixir课程。这门课程由Octolium创建，涵盖了Elixir的基础知识
Welcome to this complete Elixir course. This course, created by Octolium, covers the fundamentals of

2
00:00:06,600 --> 00:00:12,440
以及函数式编程，包括递归、模式匹配和Actor模型。
Elixir and functional programming, including recursion, pattern matching, and the actor model.

3
00:00:12,920 --> 00:00:18,880
该课程还涵盖了数据类型、流程控制以及混合项目等高级主题。
The course also covers data types, flow control, and advanced topics such as mixed projects and

4
00:00:18,880 --> 00:00:24,000
列表操作。完成本课程后，您将能够构建自己的Elixir应用程序。
list operations. By the end of this course, you'll be able to build your own Elixir applications

5
00:00:24,000 --> 00:00:28,640
并自信地在您的项目中应用函数式编程概念。
and confidently apply functional programming concepts in your projects.

6
00:00:28,640 --> 00:00:33,000
嗨，欢迎来到这门课程，关于Elixir的函数式编程。
Hi and welcome to this course, Functional Programming with Elixir.

7
00:00:33,640 --> 00:00:38,280
现在这门课程着重于学习函数式编程的基础知识
Now this course is all about learning the fundamentals of functional programming

8
00:00:38,800 --> 00:00:44,140
我们将通过使用Elixir编程语言来学习这些基础知识。
and we are going to learn these fundamentals by using the Elixir programming language.

9
00:00:44,400 --> 00:00:49,280
现在这门课程适合那些具有一定编程基础的人，
Now this course is for someone who has some basic knowledge of programming,

10
00:00:49,380 --> 00:00:54,420
但你不需要是专家。也许你懂一点JavaScript，
but you don't need to be an expert. Maybe you know a little bit of JavaScript,

11
00:00:54,420 --> 00:01:01,660
Python、Java或C++都可以。不重要的是，你需要有一些编程经验。
Python, Java, or C++. It doesn't matter, but you do need to have some kind of programming experience.

12
00:01:01,740 --> 00:01:06,940
现在让我们来介绍一下这个教程系列中涉及的所有主题。
Now let us go through all of the topics that we will be covering inside this tutorial series.

13
00:01:07,540 --> 00:01:12,440
那么首先，正如你所看到的，我们将学习所有基本的基础知识
So the first thing, as you can see that we are going to learn all of the basic fundamentals of

14
00:01:12,440 --> 00:01:17,760
函数式编程。之后，我们还将学习Elixir的所有基础知识。
functional programming. And after that, we are also going to learn all of the basics of Elixir.

15
00:01:18,100 --> 00:01:22,260
你可以看到我们也将涵盖Elixir的所有类型系统。
You can see that we are going to cover all of the type system of Elixir as well.

16
00:01:22,260 --> 00:01:28,640
然后我们将学习如何使用mix创建项目。所以这是基础教程项目，
Then we will see how to create projects by using mix. So this is the basic tutorial project that

17
00:01:28,640 --> 00:01:35,100
我们将要创建。而作为最后的巅峰项目，我们将创建一个真实的
we are going to create. And as a last capstone project, we are going to create an actual

18
00:01:35,100 --> 00:01:39,800
统计库。好了，这就是本视频的内容。我希望你对学习更多感到兴奋
statistics library. Well, that's it for this video. I hope you are excited to learn more

19
00:01:39,800 --> 00:01:44,600
关于函数式编程和Elixir的一般知识，我会在下一个视频中和你见面。
about functional programming and Elixir in general, and I will catch you in the next video.

20
00:01:45,720 --> 00:01:51,220
那么Elixir到底是什么？现在，Elixir是一种函数式编程语言。
So what exactly is Elixir? Now Elixir is a functional programming language.

21
00:01:51,860 --> 00:01:58,320
现在，为什么我要谈论Elixir呢？嗯，让我通过问你一个问题来回答。
Now, why am I talking about Elixir? Well, let me answer this by asking you a question.

22
00:01:59,040 --> 00:02:06,080
你上一次使用WhatsApp或Discord是什么时候？嗯，这两个应用程序，
When was the last time you used WhatsApp or Discord? Well, both of these applications,

23
00:02:06,440 --> 00:02:12,920
它们在同一个虚拟机上运行。现在准确地说，Discord是由Elixir驱动的，
they run on the same virtual machine. Now to be precise, Discord is powered by Elixir,

24
00:02:13,280 --> 00:02:19,400
WhatsApp则由Erlang驱动。你一定在想Erlang和Elixir有什么关系，
and WhatsApp is powered by Erlang. You must be thinking what Erlang has to do with Elixir.

25
00:02:19,400 --> 00:02:26,720
嗯，Erlang也是一种函数式编程语言，而Elixir是在Erlang的基础上构建的。
Well, Erlang is also a functional programming language, and Elixir is built on top of Erlang.

26
00:02:27,580 --> 00:02:32,560
这两种语言都是编译的，它们在Erlang虚拟机上运行，
And both of these languages, they are compiled and they run on the Erlang virtual machine,

27
00:02:32,680 --> 00:02:39,540
也被称为Beam。你可以将其想象成类似于Java虚拟机。
which is also called as the Beam. You can imagine this to be similar to your Java virtual machine.

28
00:02:40,240 --> 00:02:46,980
你有很多语言，比如Java、Kotlin、Clojure和Scala。所有这些语言，
You have so many languages such as Java, Kotlin, Clojure, and Scala. All of these languages,

29
00:02:46,980 --> 00:02:53,940
它们都编译并在Java虚拟机上运行。Elixir也是如此。
they compile and they run on the Java virtual machine. The same thing happens with Elixir.

30
00:02:54,180 --> 00:03:00,260
Elixir被编译后在Beam虚拟机上运行。现在你一定在想，
Elixir gets compiled, and it runs on the Beam virtual machine. Now you must be thinking,

31
00:03:00,340 --> 00:03:07,540
这些东西为什么重要？Elixir有什么了不起的地方？嗯，首先，它是一种函数式语言。
why is all of these things important? What's so great about Elixir? Well, first, it is functional.

32
00:03:07,740 --> 00:03:15,580
其次，它默认支持不可变性。为什么不可变性如此重要呢？嗯，那是因为，
Second, it supports immutability by default. Why is immutability so very important? Well,

33
00:03:15,580 --> 00:03:22,740
因此，我们可以具有巨大的可扩展性。你一定想知道为什么。因为既然所有的
because of that, we can have immense scalability. You must be wondering why. Because since all of

34
00:03:22,740 --> 00:03:28,160
数据类型是不可变的，这意味着线程或其他对象没有机会
the data types is immutable, that means there is no chances for the threads or some other objects

35
00:03:28,160 --> 00:03:33,860
或者其他函数意外更改值。因此状态被保留，
or maybe some other functions to accidentally change the values. So the state is preserved,

36
00:03:33,940 --> 00:03:40,060
这就是系统变得更具可伸缩性的原因。Elixir最强大的地方
and that's why the systems becomes much more scalable. And the most powerful thing about Elixir

37
00:03:40,060 --> 00:03:46,580
是它支持容错。假设一个节点崩溃或任何一个我们的角色或
is that it supports fault tolerance. Suppose if a node goes down or any of our actors or

38
00:03:46,580 --> 00:03:52,000
处理器崩溃，那么它们可以自动恢复，可以恢复到其自己的
processors goes down, then automatically they can be revived and they can be revived with its own

39
00:03:52,000 --> 00:03:59,660
状态。这就是为什么你可以通过使用
state. So that's why you can create immensely distributed and fault-tolerant systems by using

40
00:03:59,660 --> 00:04:05,500
Elixir来创建非常分布式和容错系统。所以如果你有兴趣学习Elixir，那么请继续关注，我会在下一个
Elixir. So if you're interested in learning Elixir, then stay tuned and I will meet you in the next

41
00:04:05,500 --> 00:04:12,420
视频中见。再见。现在我们对Elixir有了更多的了解，但让我们试着理解我们
video. Bye. So now we know a little bit more about Elixir, but let us try and understand what do we

42
00:04:12,420 --> 00:04:19,860
通过函数式编程我们的意思。简单来说，它只是意味着我们的整个程序是由
mean by functional programming. In simple terms, it simply means that our entire program is composed

43
00:04:19,860 --> 00:04:28,020
不同的功能。所以想象一下，这个 f of x 就是一种函数。让我来强调一下
of different functions. So just imagine that this f of x is a kind of a function. So let me highlight

44
00:04:28,020 --> 00:04:33,920
背景。所以这个绿色的东西。所以这是一个非常简单的函数。现在这个函数，
the background. So this the green thing. So this is a very simple function. Now this function,

45
00:04:33,920 --> 00:04:41,360
它接收一个输入。假设输入是 x。现在这个函数将会转换这个数据
it gets an input. Suppose that input is an x. Now this function is going to transform that data

46
00:04:41,360 --> 00:04:48,660
从 x，这个数据将会转换成为一个叫做 y 的东西。所以这就是你的
from x and that data would be transformed to something called as a y. So this is what your

47
00:04:48,660 --> 00:04:55,060
函数要做的事情。你的函数总是接受某种参数。它会
function is going to do. Your function will always accept some kind of an argument. It will

48
00:04:55,060 --> 00:05:01,160
转换这个数据，然后它总是会返回某种数据。现在这看起来可能非常
transform that data and it will always give you back some kind of data. Now this may look very

49
00:05:01,160 --> 00:05:08,260
简单，但它并不简单。创建纯函数背后有很多事情。
simple, but it's not so simple. There are a lot of things that go behind creating your pure functions.

50
00:05:08,720 --> 00:05:14,700
所以让我们试着理解什么使函数式编程如此独特。首先显然是
So let us try and understand what makes functional programming so unique. The first thing is obviously

51
00:05:14,700 --> 00:05:21,660
在函数式编程中，我们没有任何类或对象。接下来的一个是所有
we don't have any classes or objects inside functional programming. The next one is all of

52
00:05:21,660 --> 00:05:27,500
数据类型是不可变的。所以就像在整个程序中使用常量一样。
the data type is immutable. So it's just like working with constants throughout your program.

53
00:05:27,500 --> 00:05:32,800
现在你一定在想为什么我们需要不可变的数据类型或常量呢？
Now you must be wondering why do we need immutable data types or constants?

54
00:05:33,900 --> 00:05:40,840
答案是因为数据是不可变的，这意味着状态保持不变。
The answer is since the data is not mutable, that means the state remains the same.

55
00:05:41,320 --> 00:05:48,560
而且如果状态保持不变，那意味着数据可以被复制和分发得更加容易。
And if the state remains the same, that means the data can be copied and it can be distributed much

56
00:05:48,560 --> 00:05:55,820
而且由于这些数据可以被分发，这意味着我们可以创建非常可扩展的系统。
more easily. And since this data can be distributed, that means we can create immensely scalable

57
00:05:55,820 --> 00:06:02,380
通过使用函数式编程，我们可以创建这样的系统。现在这就带我到下一个观点，我觉得这个观点可能会让我们有点震惊，
systems by using functional programming. Now this brings me to the next point and I think that this

58
00:06:02,380 --> 00:06:09,820
那就是我们没有任何for循环。现在由于
point is going to shock a couple of us and that means we don't have any for loops. Now since the

59
00:06:09,820 --> 00:06:16,560
数据是不可变的，所以我们没有for循环。试着想象一下你通常的for循环。
data is immutable, that's why we don't have for loops. Just try and imagine your typical for loop.

60
00:06:17,260 --> 00:06:25,400
假设你有一个变量i等于零，i小于长度并且i加加。现在
Suppose you have your variable of i equal to zero, i which is less than length and i plus plus. Now

61
00:06:25,400 --> 00:06:32,460
每次迭代都会增加变量i。这意味着数据
what's happening is for each iteration, your variable of i is increasing. That means the data

62
00:06:32,460 --> 00:06:40,240
在不断变异，但我们不能这样做，因为我们有不可变的数据类型。你必须
is constantly mutating, but we can't have that because we have immutable data types. You must

63
00:06:40,240 --> 00:06:46,340
那么有什么意义呢？我们如何在Elixir中进行迭代？但函数式编程
be thinking then what's the point? How can we have iterations in elixir? But functional programming

64
00:06:46,340 --> 00:06:54,280
Elixir有一种更好的循环方式，那就是使用递归。而我将要
and elixir has a much better way of doing loops and that is by using recursion. And I'm going to

65
00:06:54,280 --> 00:07:01,600
在下一个视频中详细讲解递归。那么递归是什么意思，为什么
talk more about recursion right in the next video. So what do you mean by recursion and why is

66
00:07:01,600 --> 00:07:09,840
递归如此重要？让我们逐个解答这些问题。首先我们来看看什么
recursion so important? Let us try to answer these questions one by one. First let us see what do you

67
00:07:09,840 --> 00:07:17,680
递归是什么意思。简单来说，当您一次又一次地执行相同的任务时，可以说
mean by recursion. In simple terms, whenever you perform the same task again and again, you can say

68
00:07:17,680 --> 00:07:24,080
您正在执行递归。这意味着您可以看到我们有一个任务和这个任务
that you are performing a recursion. That means you can see that we have one task and this task

69
00:07:24,080 --> 00:07:32,460
一次又一次地调用自身。因此，您可以说我们处于递归状态。现在，如果
is calling itself again and again. So you can say that we are in a state of recursion. Now if

70
00:07:32,460 --> 00:07:40,240
递归如此简单，那么递归有什么了不起的？让我试着解释一下
recursion is so simple, then what's the big deal with recursion? Let me try and explain this by

71
00:07:40,240 --> 00:07:47,120
带您穿越时光之旅。您一定听说过世界七大奇迹。
taking you through a journey in time. You must have heard about the seven wonders of the world.

72
00:07:47,120 --> 00:07:53,980
您有泰姬陵，您有中国长城，您有马丘比丘等等。
You have the Taj Mahal, you have the Great Wall of China, you have the Machu Picchu and so on.

73
00:07:54,400 --> 00:08:00,900
但是如果你问我们每个人，你认为世界的奇迹是什么？答案会有所不同。
But if you ask each one of us what do you consider as the wonder of the world? The answer is going

74
00:08:00,900 --> 00:08:07,880
会有所不同。让我们看看接下来会发生什么。所以他们是一些最聪明的家伙之一。
to vary. Let us see what's going to happen next. So these are some of the most smartest guys on the

75
00:08:07,880 --> 00:08:15,100
星球上。所以他们是沃伦·巴菲特和伟大的查理·芒格。如果你问这些人，你会得到什么回答？
planet. So they are Warren Buffett and the great Charlie Munger. If you ask these guys what do you

76
00:08:15,100 --> 00:08:20,100
他们认为世界奇迹之一？那么最有可能的答案会是
think is one of the wonders of the world? Then most possibly the answer would be

77
00:08:20,100 --> 00:08:26,660
复利。现在让我们看看接下来会发生什么。还有一个非常聪明的家伙
compounding. Now let us see what's going to happen next. So there is one more really smart guy

78
00:08:27,260 --> 00:08:33,660
正如你所想象的，这就是伟大的艾萨克·牛顿。如果你问牛顿
and as you can imagine, this is the great Isaac Newton. If you ask Newton what would be one of

79
00:08:33,660 --> 00:08:40,540
世界上最伟大的奇迹，最有可能他会说是重力。所以要点就是
the greatest wonders of the world, most probably he's going to say that it's gravity. So the point

80
00:08:40,540 --> 00:08:48,000
我试图表达的是我们的感知因人而异。现在如果你问
that I'm trying to make is our perception changes from person to person. Now what happens if you

81
00:08:48,000 --> 00:08:55,680
这个家伙，也就是我，我对世界上最伟大的奇迹有什么看法？而且就像你所想的
ask this guy, that's me, what do I think about one of the greatest wonders of the world? And as you

82
00:08:55,680 --> 00:09:03,720
你可以猜到我的答案会是递归。嗯，那并不完全正确。如果你想要一个非常诚实的答案
can guess my answer would be recursion. Well that's not exactly true. If you want a very honest answer

83
00:09:04,480 --> 00:09:12,720
那么我认为递归加突变，也就是递归突变是世界上最伟大的之一
then I think that recursion plus mutation, that means recursive mutation is one of the greatest

84
00:09:12,720 --> 00:09:19,660
这个世界上最伟大的奇迹。听起来很混乱，是吗？别担心，现在是解释的时候了。
wonders of this world. Sounds confusing, is it? Don't worry, now it's time for some explanation.

85
00:09:20,580 --> 00:09:27,580
只要考虑我们人类。我们所有人都有习惯，对吧？而且我们倾向于有相同的
Just consider us human beings. All of us have habits, right? And we tend to have the same

86
00:09:27,580 --> 00:09:34,780
在很长一段时间里。那么你能说我们的思维处于递归状态吗？
over a long period of time. So can you say that our mind is in a state of recursion

87
00:09:34,780 --> 00:09:41,640
因为我们每天都在重复同样的习惯。你可能会说我们的习惯可以
because we keep on repeating the same habit each and every day. You may argue that our habits can

88
00:09:41,640 --> 00:09:49,480
也会改变。嗯是的，它们可以改变，这就是我所指的突变。但试着考虑一下
also change. Well yes, they can change and that's what I mean by mutation. But just try and consider

89
00:09:49,480 --> 00:09:56,880
你的习惯不会在一夜之间发生剧变。你的习惯可能会在很长一段时间里改变
your habits don't change drastically overnight. Your habits may change over a long period of time

90
00:09:56,880 --> 00:10:03,640
所以你也可以说你的习惯变化是由于发生的小突变
so you can also say that your change in habit is because of small mutations that take place

91
00:10:03,640 --> 00:10:10,780
每天都发生。所以也许你可以说我们所有人都处于递归突变的状态。
each and every day. So maybe you can say that all of us are in a state of recursive mutation.

92
00:10:11,920 --> 00:10:18,700
让我们试着变得更大一些。让我们试着思考地球本身。现在地球
Let's try and go a little larger. Let us try and think about the earth itself. Now the earth

93
00:10:18,700 --> 00:10:25,640
需要大约24小时才能回到完全相同的位置。那么你能说地球也是
takes around 24 hours to come to the exact same point. So can you say that earth is also

94
00:10:25,640 --> 00:10:32,700
在递归的状态中. 让我们尝试延展一下这种想法. 地区一直围着
in a state of recursion? Let us try and expand a little bit further. Now the earth revolves around

95
00:10:32,700 --> 00:10:38,800
太阳公转. 12 个月一圈
the sun in an orbit. Now this, as you know, it takes around 12 months time. But what happens

96
00:10:38,800 --> 00:10:45,240
不过每四年我们会得到一个闰年, 也就表示一年多了一天. 你可以说
in every four years we have a leap year. That means we have a day extra. So can you say that

97
00:10:45,240 --> 00:10:52,200
地球处于递归变化中. 现在我们试着将概念拓展出太阳系.
even the earth is in the state of recursive mutation? Now let us try and go even beyond

98
00:10:52,200 --> 00:11:00,280
你一定听说过整个宇宙在不停地膨胀
our solar system. You must have also heard that the entire universe is in the state of expansion.

99
00:11:01,540 --> 00:11:09,060
在 136 亿年前, 宇宙中什么都没有. 宇宙大爆炸发生后地球
Just go back 13.6 billion years ago when there was nothing. The big bang happened and the earth,

100
00:11:09,320 --> 00:11:18,900
星星, 太阳和整个星系才出现, 这是怎么发送的? (这段有些莫名奇妙)
stars, sun and entire galaxies came into existence and we are still expanding. How can this happen?

101
00:11:18,900 --> 00:11:26,980
我可以用一个递归方法来解释这一切.
Well I can explain this by using a function which is written recursively. So this is our function.

102
00:11:27,520 --> 00:11:32,400
现在我们不需要了解所有知识, 你可以将问题留
For now you don't have to understand all of these things. You will understand these things

103
00:11:32,400 --> 00:11:38,140
在未来，当你对elixir有了更多了解的时候。现在让我们试试看怎么样
in the future when you learn a little bit more about elixir. Right now let us try and see how

104
00:11:38,140 --> 00:11:46,520
宇宙可以从无中膨胀。所以如果我说宇宙，现在是大爆炸的时候了
the universe can expand from nothing. So if I say universe and now this is the time for the big bang

105
00:11:47,160 --> 00:11:54,080
大爆炸是一个不带参数的函数。现在让我们看看会发生什么。
and big bang is a function which takes no argument. Now let us see what's going to happen.

106
00:11:54,460 --> 00:12:00,980
好的，大爆炸发生了。在那之后，你可以看到宇宙的大小是零，一，
Okay so the big bang happened. After that you can see that the size of universe is zero, one,

107
00:12:01,180 --> 00:12:07,740
二，三，四，而且大小不断扩大。现在让我停下来，否则
two, three, four and the size is constantly expanding. Now let me stop this otherwise

108
00:12:07,740 --> 00:12:13,700
这将无限进行下去。那么到底发生了什么？你可以看到我有一个函数
this will go for infinity. So what exactly happened? You can see that I have a function

109
00:12:13,700 --> 00:12:21,240
称为expand，在最后该函数再次调用自身，但这次我们
called as expand and at the last the function is calling itself again but this time we are

110
00:12:21,240 --> 00:12:27,160
只是改变状态。我写了状态加一，但想象一下这不是加一。
just mutating the state. I have written state plus one but imagine that this is not plus one.

111
00:12:27,620 --> 00:12:32,580
我们正在引发某种变异，这就是这个符号的意义所在。
We are causing some kind of mutation and that is what this is supposed to symbolize.

112
00:12:33,980 --> 00:12:40,620
现在这就将我带到了最后一个观点。所以你可以想象宇宙的本质是什么。
Now this brings me to the last point. So as you can imagine the very nature of the universe is

113
00:12:40,620 --> 00:12:47,460
递归。这意味着我们为编程而学习的所有数学也是递归的。
recursive. That means all of the mathematics that we study for programming that too is recursive

114
00:12:47,460 --> 00:12:54,960
在本质上，这种递归的概念对于函数式编程来说是自然而然的。所以现在我们
in nature and this concept of recursion comes naturally to functional programming. So now we

115
00:12:54,960 --> 00:13:02,480
明白了，我们必须经历一段非常漫长的旅程才能理解什么是递归，以及其中的关键点。
get it we had to take a really long journey in order to understand what is recursion and what's

116
00:13:02,480 --> 00:13:09,480
它有什么重要性。现在让我们看看如何安装Elixir。所以你可以去
the big deal with it. Now let's see how to install elixir. So what you can do is you can just go to

117
00:13:09,480 --> 00:13:16,380
前往elixirlang.org这个网站，然后点击安装，如果你使用的是
this website which is elixirlang.org and you can simply click on install and if you're using

118
00:13:16,380 --> 00:13:22,480
Windows系统，你可以点击Windows。然后你可以从这里下载安装程序，按照指示
windows you can click on windows. So from here you can download the installer and as the instruction

119
00:13:22,480 --> 00:13:28,780
上面已经说过，你只需要点击下一步，然后一直点击完成，如果你使用的是Mac系统
already says you have to simply click on next next and finally finish and if you are on a mac

120
00:13:28,780 --> 00:13:35,780
你可以简单地使用brew来安装Elixir。所以如果你使用的是Mac系统，你可以打开终端
you can simply use brew to install elixir. So if you are on a mac you can open up a terminal and

121
00:13:35,780 --> 00:13:43,000
输入brew install elixir，一旦你安装好Elixir，我希望你只需
type brew install an elixir and once you have installed elixir what I want you to do is just

122
00:13:43,000 --> 00:13:49,020
打开一个终端，或者如果你使用的是Windows系统，只需打开PowerShell，然后你就可以简单地
open up a terminal or if you're using windows just open up the power shell and here you can simply

123
00:13:49,020 --> 00:13:56,660
键入 elixir 和连字符 v。所以正如你所看到的，我目前正在运行 elixir
1.14.1，如果你正在观看这个视频，你可能有其他版本，但不用担心，所有的版本也一样。
type elixir and hyphen v. So as you can see I'm currently running elixir 1.14.1 and if you're

124
00:13:56,660 --> 00:14:05,020
如果你将来看这个视频，你可能有其他版本，但不用担心，所有的版本都一样。
watching this video in the future you may have some other version but don't worry all of the

125
00:14:05,020 --> 00:14:11,280
版本也都一样。对于这个视频的下一个步骤是让我们打开我们的 Visual Studio
Code，并且让我们。
versions as well. The next thing for this video is let us open up our visual studio code and let us

126
00:14:11,700 --> 00:14:18,800
为这个设置 elixir 插件。所以只需打开你的扩展，我希望你只需。
set up the elixir plugin for this one. So just open up your extensions and I want you to just

127
00:14:18,800 --> 00:14:27,680
搜索 elixir。所以这个扩展是为了 elixir ls，所以你可以在这里看到，目前它有。
search for elixir. So this extension which is for elixir ls so here you can see and currently it has

128
00:14:27,680 --> 00:14:34,400
有着 33.9 万次下载，所以只需安装这个插件，这是你真正需要开始工作的。
like 339,000 downloads so just install this plugin and this is what you really need to start working

129
00:14:34,400 --> 00:14:41,460
在 VS Code 中使用 elixir。当你第一次在 VS Code 中打开任何 elixir
文件时，你将会。
with elixir inside vs code. The first time you open up any elixir file inside vs code you will

130
00:14:41,460 --> 00:14:47,820
在右下角的某个位置会弹出一个小窗口，该窗口会显示。
get a small pop-up right where somewhere in the bottom right corner and that pop-up will be saying

131
00:14:47,820 --> 00:14:55,140
elixir 正在构建 plt，所以就让它发生吧，这需要一些时间，但让它。
that elixir is building the plt so just let it happen it's going to take some time but let it

132
00:14:55,140 --> 00:15:02,420
运行，当 elixir plt 构建完成后，你就可以在 VS Code 中开始使用你的 elixir
文件了。
run and after the elixir plt is built you can start working with your elixir files inside vs code.

133
00:15:03,340 --> 00:15:08,440
既然我们已经安装了elixir，现在是时候开始学习更多关于elixir的知识了
Now that we have elixir installed it's time to start learning more about elixir

134
00:15:08,440 --> 00:15:15,460
但是在学习之前，我们需要先开始“反学习”，因为很多概念在面向对象的世界中是不存在的
but first before learning we need to start unlearning because a lot of concepts from

135
00:15:15,460 --> 00:15:21,920
面向对象的世界在函数式编程的世界中是不存在的，这就引出了我想谈的一个非常重要的观点
the object-oriented world does not exist in the functional world. So that brings me to the very

136
00:15:21,920 --> 00:15:30,440
首先，如果我说a等于1，然后问你对此有什么看法，你可能会回答
first statement if I say a is equal to one and if I ask you what do you think of it most probably

137
00:15:30,440 --> 00:15:37,380
你可能会说a是一个变量，而1是被赋值给变量a的值
you'll say that a is a variable and the value of one is being assigned to the variable of a well

138
00:15:37,380 --> 00:15:44,180
你是对的，但这并不是在函数式编程的世界中发生的事情。如果我带你回到
you are right but that's not what is happening inside the functional world. If I take you back

139
00:15:44,180 --> 00:15:49,640
回到你上高中的日子，想象一下你正在上最基础的代数课
to your high school days and just imagine that you are taking your very basic algebra classes

140
00:15:50,360 --> 00:15:57,520
在那节课上，我们学到的是a等于1，这意味着a是你的左手边，1是你的右手边
in that class what we learned was a is equal to one that means a is your left hand side and one

141
00:15:57,520 --> 00:16:05,260
它是你的右手边。所以数学试图表达的是你的左手边等于
is your right hand side. So what maths is trying to say is your left hand side is equal to

142
00:16:05,260 --> 00:16:13,220
你的右手边。你的基础代数并没有说1被赋值给了a这个概念
your right hand side your basic algebra does not say that one is being assigned to a that concept

143
00:16:13,220 --> 00:16:21,220
不存在。现在如果我们说左边等于右边，那就意味着
does not exist. Now if we say that if the left hand side is equal to the right hand side that means

144
00:16:21,220 --> 00:16:28,140
右边也应该等于左边。所以如果我说a等于一
the right hand side should also be equal to the left hand side. So if I say that a is equal to one

145
00:16:28,520 --> 00:16:35,400
这意味着甚至这个语句也应该成立，这就是elixir世界中发生的事情
that means even this statement should hold true and that is what happens in the world of elixir

146
00:16:35,400 --> 00:16:43,080
同样如此。我们很快也会演示这个。现在只要记住等于不是
as well. We will also have a demo of this shortly. Right now just keep in mind that equal to is not

147
00:16:43,080 --> 00:16:50,140
赋值运算符，这是匹配运算符，这个运算符的作用是简单地
the assignment operator this is the match operator and what this operator does is that it simply

148
00:16:50,140 --> 00:16:56,860
将你的右边匹配到你的左边，你会经常看到这种模式
matches your right hand side to your left hand side and you are going to see this pattern a lot

149
00:16:56,860 --> 00:17:03,860
在elixir中。这也被称为模式匹配，这是一个非常强大的东西
inside elixir. This is also called as pattern matching and this is a very powerful thing inside

150
00:17:03,860 --> 00:17:10,200
elixir。每当你看到这样的语句时，请记住我们只是在试图匹配
elixir. Every time you see a statement like this always remember that we are simply trying to match

151
00:17:10,200 --> 00:17:16,720
右边和左边。现在让我们打开终端进行演示。
the right hand side with the left hand side. Now for the demo let us open up our terminal.

152
00:17:17,600 --> 00:17:24,220
Elixir实际上附带了一个交互式shell或一个repel，让我们看看如何打开它
Elixir actually ships with an interactive shell or an repel so let us see how we can open it up

153
00:17:24,220 --> 00:17:33,160
并开始使用elixir。我们可以通过键入IEX进入交互式shell。您可以清除
and start using elixir. We can enter inside the interactive shell by typing IEX. You can clear

154
00:17:33,160 --> 00:17:42,200
通过键入clear清除终端。所以在这里我们可以说我的a等于一。现在如果我们说是
the terminal by typing clear. So here we can say that my a is equal to one. Now if we say that is

155
00:17:42,200 --> 00:17:50,900
一个等于我的a，我们得到的输出是true。您也可以输入one等于a
one is equal to my a and we get the output as true. You can also type as one is equal to a

156
00:17:50,900 --> 00:17:57,320
这只是简单地返回值，因为one和a都保存着相同的值one。
and this simply gives back the value because one and a both hold the same value of one.

157
00:17:58,440 --> 00:18:05,400
让我来澄清一下。让我们再试一次实验。假设我说我的名字是
Let me clear this up. Let us try with one more experiment. Suppose I say that my name is

158
00:18:07,120 --> 00:18:16,900
Octalium。所以在这种情况下，如果我说Octalium等于我的名字，那么我们应该得到
Octalium. So in this case if I say that is Octalium equal to my name then we should get

159
00:18:16,900 --> 00:18:23,460
答案是true，是的，就是这样。所以请记住，这个等于不是
the answer of true and yes that's what it is. So just keep in mind that this is equal to is not

160
00:18:23,460 --> 00:18:35,380
分配。我们只是试图将右侧的模式与左侧的模式匹配。让我们
assignment. We are simply trying to pattern match the right hand side to the left hand side. Let's

161
00:18:35,380 --> 00:18:42,660
例子。现在方括号表示这是一个列表，我将更多地介绍列表
example. Now the square brackets means that this is a list and I will be covering more about list

162
00:18:42,660 --> 00:18:49,480
以后再说吧，现在让我们顺其自然。现在我不想让你
a little later in the series but for now let us just go with the flow. For now I don't want you

163
00:18:49,480 --> 00:18:56,780
专注于语法。我希望你只专注于右边和
to concentrate on the syntax. I want you to concentrate just on the right hand side and

164
00:18:56,780 --> 00:19:03,860
左边。你能看到右边的模式和左边的模式是一样的吗？
the left hand side. Can you see that the pattern on the right is the same as the pattern on the left?

165
00:19:03,860 --> 00:19:10,160
左边有两个变量。右边有两个值。这里
We have two variables on the left hand side. We have two values on the right hand side. Here

166
00:19:10,160 --> 00:19:18,840
你可以说一个的值现在绑定到了变量a上。现在下一个变量也是
you can say that the value of one is now bound to the variable of a. Now the next variable is also

167
00:19:18,840 --> 00:19:26,260
a，而且a中的值也是1，就是这样。所以这将在内部成立
a and the value inside a is also one and that's what it is. So this is going to be true inside

168
00:19:26,960 --> 00:19:34,680
elixir。为了进行快速演示，让我打开终端，我已经在IEX中了。以防万一
elixir. For a quick demo let me open up my terminal and I'm already inside IEX. In case if

169
00:19:34,680 --> 00:19:40,860
你忘记了如何进入IEX，让我再给你演示一次。退出IEX只需要按一下
you have forgotten how to go inside IEX let me show you once again. For quitting IEX just press

170
00:19:40,860 --> 00:19:49,920
两次ctrl c，你就可以退出IEX，如果你想进入，请再输入IEX。再一次
ctrl c twice and you can quit the IEX and again if you want to go inside just type as IENX. Again

171
00:19:49,920 --> 00:20:00,300
让我澄清一下。所以这里我可以说我的列表有两个变量a和a，值分别是
let me clear it up. So here I can say that my list has two variables a and a and the values are

172
00:20:00,300 --> 00:20:08,280
1和1。所以就是这样。完全匹配。右边等于左边
one and one. So here it is. It's a perfect match. The right hand side is equal to the left hand side

173
00:20:08,280 --> 00:20:16,080
所以我们把值拿回来。如果我只是说我想看到a的值，这里它是我们得到的值
so we get the values back. If I just say I want to see the value of a and here it is we get the value

174
00:20:16,080 --> 00:20:24,980
a的值是一个。现在让我们回过头来。现在你能猜到这次会发生什么吗？
of a as one. Now let us go back. Now can you guess what is going to happen this time?

175
00:20:25,780 --> 00:20:32,160
现在这次你可以看到我们有a和a的值，右边是一个的值
Now this time you can see that we have the values of a and a and on the right we have the value of

176
00:20:32,160 --> 00:20:39,340
一个和两个。好吧，让我们去我们的IEX看看这次会发生什么。所以我们有
one and two. Well let us go to our IEX and see what's going to happen this time. So we have

177
00:20:39,340 --> 00:20:46,220
这是a和a，右边是一个和两个。让我们看看会发生什么。
this a and a and on the right we have one and two. Let us see what's going to happen.

178
00:20:46,800 --> 00:20:53,140
哦，我们得到了一个错误，如果你仔细观察，我们会得到一个错误，说没有匹配
Oh we get an error and if you watch closely we get an error saying that no match

179
00:20:53,140 --> 00:21:02,220
右边是不匹配的。原因是一个的值绑定到了
of the right hand side and yes it is not a match. The reason is the value of one is bound to the

180
00:21:02,220 --> 00:21:10,980
一个的值，再次，第二个值是a，但这次a里面的值是一个，右边是
of a and again the second value is a but this time the value inside a is one and on the right

181
00:21:10,980 --> 00:21:17,520
的值是两个。所以两个不等于一个，这就是为什么右边和左边
the value is two. So two is not equal to one and that's why the right hand side and the left hand

182
00:21:17,520 --> 00:21:26,480
不匹配，这就是为什么我们会得到一个错误。让我们回去。现在如果我们发生了什么？
side are not a match and that's why we get an error. Let us go back. Now what happens if we

183
00:21:26,480 --> 00:21:32,360
像这样吗？如果我们将第二个值从a换成一个新变量b，
something like this? If we switch the second value from a to a new variable of b,

184
00:21:33,240 --> 00:21:38,740
你能猜到会发生什么吗？好，我们回到之前，让我们看看会发生什么
can you guess what is going to happen? Well let us go back and let us see what's going to happen

185
00:21:38,740 --> 00:21:47,860
这一次。所以让我将值从a改为b，让我们看看。嗯，是的，完美匹配。
this time. So here let me change the value from a to b and let us see. Well yes it's a perfect match.

186
00:21:48,640 --> 00:21:55,940
那么这次发生了什么？1的值绑定到了变量a，2的值
So what's happening this time? The value of one is bound to the variable of a and the value of two

187
00:21:55,940 --> 00:22:03,660
绑定到了变量b。我们可以检查一下。所以如果我说a，我们得到1的值
is bound to the variable of b. We can check it out. So if I say a then we get the value of one

188
00:22:03,660 --> 00:22:12,840
而如果我说b，我们得到2的值，就是这样。要始终尝试并思考
and if I say b we get the value of two and that's what it is right over here. Always try and think

189
00:22:12,840 --> 00:22:19,920
从模式匹配的角度来看，这意味着我们始终希望右侧等于左侧
in terms of pattern matching that means we always want to have the right hand side equal to our left

190
00:22:19,920 --> 00:22:28,260
这也被称为模式匹配，正如我之前所说，这是一个非常强大的
side. So this is also called as pattern matching and as I have said earlier this is a very powerful

191
00:22:28,260 --> 00:22:34,220
在Elixir中的模式，并且我们将在整个教程中使用这种模式匹配
pattern inside elixir and we would be using this pattern matching throughout this entire tutorial

192
00:22:34,220 --> 00:22:41,740
系列。到目前为止，我们已经了解了一点关于Elixir中的模式匹配，并且我们一直在使用它。
series. Till now we have seen a little bit about pattern matching inside elixir and we have been

193
00:22:41,740 --> 00:22:48,960
使用我们的终端，但我们可以做得更好，让我向您介绍Livebook。
using our terminal but we can do a much better job and allow me to introduce to you Livebook.

194
00:22:48,960 --> 00:22:56,200
因此，Livebook实际上就像Elixir的Jupyter笔记本，但在我向您展示Livebook之前，
So Livebook is actually like the jupyter notebooks for elixir but before I can show you Livebook you

195
00:22:56,200 --> 00:23:01,140
您可能已经注意到，我有一个不同的提示符，我的终端里还有更多的颜色
must have noticed that I have a different prompt and I have a couple of more colors inside my

196
00:23:01,140 --> 00:23:08,180
这是因为我使用了更加复杂的设置，但就这样而已。
terminal and this is because I'm using a little bit more fanciest setup but that's about it.

197
00:23:08,460 --> 00:23:16,260
现在让我来看看Livebook。就是这里，您可以直接访问这个网站livebook.dev
Now let me go to Livebook. So here it is you can simply navigate to this website livebook.dev

198
00:23:16,260 --> 00:23:23,180
然后我们可以简单地在我们的机器上安装Livebook，只需点击安装
and from here we can simply install Livebook on our machine so just click on install and from

199
00:23:23,180 --> 00:23:29,220
在这里您可以选择您的Mac或Windows系统并下载安装程序，在下载完成之后
here you can choose your mac or windows and download the setup and after you have downloaded

200
00:23:29,220 --> 00:23:35,640
只需像在您的机器上安装其他程序一样安装它。现在我已经安装了Livebook，所以让我打开它
the setup just install it as you would install any other program in your machine. Now I have

201
00:23:35,640 --> 00:23:43,940
已经安装了Livebook，让我打开它。就是这样，我们可以开始
already installed Livebook so let me just open it up here it is so this is how it is. We can start

202
00:23:43,940 --> 00:23:49,640
新建一个笔记本，只需点击这里的新笔记本，就这样，我们可以开始了。
a new notebook we can simply click over here new notebook and that's it we are good to go.

203
00:23:50,220 --> 00:23:57,960
让我们试试在终端中写入的相同代码，所以这里我可以说的是我的a逗号a
Let us try the same code that we wrote inside our terminal so here I can say is my a comma a

204
00:23:57,960 --> 00:24:07,220
等于我的1逗号1，你可以点击这里进行评估，现在我们有输出了，对吧
equal to my 1 comma 1 and simply you can click over here evaluate and now we have the output right

205
00:24:08,020 --> 00:24:17,620
让我们尝试一些其他的例子，所以这里我可以说如果我的a等于1，那么我的
let us try with some other examples so here I can say if my a is equal to 1 then is my

206
00:24:17,620 --> 00:24:24,620
等于1，让我们尝试在这个单元格中进行评估，是的，我们得到了输出。
1 equal to a and let us try to evaluate in this cell and yes we get the output.

207
00:24:26,620 --> 00:24:32,540
现在，为了参考，我还包括了一些笔记本，你可以
Now what I have done just for a reference I have also included a couple of notebooks and you can

208
00:24:32,540 --> 00:24:38,780
在这里找到所有这些，所以这是整个教程系列的github存储库
find all of those right over here so this is the github repo for this entire tutorial series

209
00:24:38,780 --> 00:24:47,940
这是octalium斜杠oop，就在这里，你可以去octalium和斜杠functional
which is octalium slash oops it's right over here you can go to octalium and slash functional

210
00:24:47,940 --> 00:24:53,580
使用elixir编程，在笔记本中你可以看到我有几个笔记本
programming with elixir and inside notebooks you can see that I have a couple of notebooks

211
00:24:53,580 --> 00:24:59,500
现在，在将来我可能会再添加几个笔记本，但在录制时
now in the future I may add a couple of more notebooks to this one but at the time of recording

212
00:24:59,500 --> 00:25:05,000
我们有三个，所以让我们看看如何在我们的livebook中打开这些笔记本
we have three of those so let us see how we can open these notebooks inside our livebook

213
00:25:05,000 --> 00:25:11,200
所以让我回到我的livebook，让我只需点击左边的这个图标
so let me go back to my livebook and let me just click on this icon on the left

214
00:25:11,820 --> 00:25:16,300
这里我只需要选择我的路径，所以我要进入我的 github
and here I simply have to choose my path so I have to go inside my github

215
00:25:17,700 --> 00:25:23,940
使用 elixir notebooks 进行 octalium 函数式编程，让我选择第一个
octalium functional programming with elixir notebooks and let me choose the first one

216
00:25:23,940 --> 00:25:29,900
然后让我简单地点击打开，所以这是你可以在里面找到的第一个 livebook
and let me simply click on open so this is the first livebook that you can find inside

217
00:25:29,900 --> 00:25:34,280
这个仓库，正如你所看到的，我已经包含了一些
the repository and as you can see I have included a couple of

218
00:25:34,280 --> 00:25:39,800
文本，还有一些代码块供你参考，这就是我们试图做的事情
text and also a couple of code blocks for your reference so this is what we were trying to do

219
00:25:39,800 --> 00:25:47,140
上次，如果你看到这里，我创建了一些更多的例子，所以如果我的名字是
last time and if you see right over here I have created some more examples so if my name is

220
00:25:47,140 --> 00:25:54,200
等于 octalium，那么我的 octalium 也应该等于 name，以此类推，所以你可以做的是
equal to octalium then my octalium should also be equal to name and so on so what you can do

221
00:25:54,200 --> 00:26:00,180
也许你可以尝试创建更多的笔记本，然后尝试打开这些笔记本
maybe you can try to create a couple of more notebooks and you can try to open up the notebooks

222
00:26:00,180 --> 00:26:05,840
这些笔记本包含在仓库中，我会在下一个视频中告诉你，到目前为止我们一直在
which are included inside the repo and I will catch you in the next video till now we have been

223
00:26:05,840 --> 00:26:10,440
试图更多地了解模式匹配，让我们在这个视频中继续做同样的事情
trying to learn more about pattern matching and let us continue with the same thing in this video

224
00:26:10,440 --> 00:26:17,760
现在让我们回到终端，让我进入 IEX，我可以通过简单的方式来做到这一点
as well now let us go back to our terminal and let me go inside IEX so I can do that by simply

225
00:26:17,760 --> 00:26:24,940
现在再次输入IEX，请让我提醒您，我的提示符看起来不同，这是因为我自定义了设置
typing IEX now again please let me remind you that my prompt is looking different and that is

226
00:26:24,940 --> 00:26:30,500
因为我自定义了设置，我只想让提示符与我的标志相同
because I have customized the settings I just wanted to have the prompt to be same as my logo

227
00:26:30,500 --> 00:26:37,320
这就是我简单地更改了它，但就是这样，现在让我清理终端，然后让
that's why I simply changed it but that's about it now let me clear up the terminal and here let

228
00:26:37,320 --> 00:26:43,240
让我们尝试更多地了解模式匹配，所以让我们再创建相同的列表
us try to learn a little bit more about pattern matching so again let us create the same list

229
00:26:43,240 --> 00:26:50,120
对于右侧，让我们说我们想与一个和二进行匹配，正如您所知，我们将得到一个匹配错误
a and a and for the right hand side let us say that we want to match with one and two and as

230
00:26:50,120 --> 00:26:56,120
您知道我们将得到一个匹配错误，这就是我们得到的，所以让我再试一次
you know we are going to get a match error and this is what we are getting so again let me try

231
00:26:56,120 --> 00:27:03,060
并刷新我们的记忆，发生了什么，所以正在发生的是变量a的值是
and refresh our memory what's happening so what's happening is the value or the variable of a is

232
00:27:03,060 --> 00:27:09,940
绑定到值为一的值，并且在下一次发生的事情是这里我们有一个a
bound to the value of one and on the next time what's happening is here we have a

233
00:27:09,940 --> 00:27:16,860
但我们正在尝试将值为二的值与a进行匹配，正如您所知，a绑定到一，这就是为什么
but we are trying to match the value of two with a and as you know a is bound to one that's why

234
00:27:16,860 --> 00:27:21,900
我们得到了匹配错误，现在让我们花几分钟来试着理解
we are getting match error now let's take a couple of minutes and let us try to understand

235
00:27:21,900 --> 00:27:28,760
为什么会发生这种情况？因为Elixir中的所有数据类型都是不可变的。
why this is happening this is happening because all of the data types inside elixir are immutable

236
00:27:29,320 --> 00:27:35,660
这意味着我们不能在Elixir中随机分配新值给现有变量。
that means if we can't randomly assign new values to an existing variable inside elixir

237
00:27:35,660 --> 00:27:41,000
现在你一定在想为什么Elixir中的所有类型都必须是不可变的。
now you must be thinking that why does all of the types inside elixir has to be immutable

238
00:27:41,520 --> 00:27:47,500
简而言之，这是为了可扩展性，我们将在下一个视频中详细讨论这一点。
the short answer is because for scalability and we will come to this point in the next video but

239
00:27:47,500 --> 00:27:53,160
现在让我们试着了解一下背后发生了什么，现在让我来解释一下。
for now let us try to understand what's happening behind the scenes now let me try to clear up the

240
00:27:53,160 --> 00:27:59,580
再来一次屏幕，这次让我们假设我们要的是a，并且我们希望它在右边。
screen one more time and this time let us say that we want our a and we want on the right to be

241
00:27:59,580 --> 00:28:05,980
所以这次发生的是我们在这里有一个匹配运算符，其值为。
one so this time what's happening is we have a match operator right over here and the value of

242
00:28:05,980 --> 00:28:13,880
将1绑定到变量a上，但是这里有一个小问题，如果我说a等于2
one is bound to the variable of a but here comes a small caveat so if i say a is equal to two

243
00:28:13,880 --> 00:28:20,860
所以这次我们没有错误，但是我刚才说过在Elixir中我们的数据类型是不可变的。
so this time we don't have an error but i just said that our data types are immutable inside elixir

244
00:28:20,860 --> 00:28:27,500
所以发生了什么，当我们在匹配运算符的左边有一个变量时，
so what's happening so whenever we have a variable on the left hand side of our match operator

245
00:28:27,500 --> 00:28:34,240
那时候，Elixir认为我们想将新值绑定到左边的变量上，这就是为什么
at that time elixir thinks that we want to bound the new value to the variable on the left that's

246
00:28:34,240 --> 00:28:40,100
为什么我们有了新值而不是a，它是两个，但是如果你不想要这种行为，那么我们可以
why we have the new value instead of a which is two but if you don't want this behavior then we

247
00:28:40,100 --> 00:28:46,860
可以使用一个pin操作符，我们可以说pin操作符，a等于三，这次
can use a pin operator so we can say the pin operator and a is equal to three so this time

248
00:28:46,860 --> 00:28:53,020
正如你所看到的，我们得到了一个匹配错误，匹配错误表示右侧没有匹配
as you can see we get a match error and the match error is saying that no match of right hand side

249
00:28:53,020 --> 00:28:59,320
值为三，这是因为我们有两的值，而左边
value of three and this is because instead of a we have the value of two and on the left hand side

250
00:28:59,320 --> 00:29:05,060
我们试图匹配一个值为三的值，这就是为什么我们得到了匹配错误，现在如果我们试图做
we are trying to match a value of three that's why we get the match error now if we try to do

251
00:29:05,060 --> 00:29:11,300
这件事情的另一种方式，如果我们说三等于a，那么这次我们又得到了一个
this thing the other way around and if we say that three is equal to a so again this time we get an

252
00:29:11,300 --> 00:29:18,640
没有匹配，右侧的值是两，所以是的，正如你在这里看到的一样，这个值
no match and the right hand side value is two so yes as you can see right over here the value

253
00:29:18,640 --> 00:29:24,960
与a绑定的值是两，这就是为什么三不等于两，我们得到了一个匹配错误
which is bound to a is two and that's why three is not equal to two and we get a match error

254
00:29:24,960 --> 00:29:32,240
在第四行，我们可以把新的值两重新绑定到我们的变量a上，只是因为
and on line number four we could rebound the new value of two to our variable of a just because

255
00:29:32,240 --> 00:29:37,180
这个变量暂时在匹配运算符的左边，你现在不必担心
this variable is on the left hand side of the match operator for now you don't have to worry

256
00:29:37,180 --> 00:29:41,920
随着我们的进展和解决更多的例子，你就不必太担心这些事情了
too much about these things as we progress and as we solve a couple of more examples

257
00:29:41,920 --> 00:29:47,800
所有这些事情现在都会很容易明白，现在来到下一个问题，为什么我们需要
all of these things will get cleared very easily now coming to the next point why do we need

258
00:29:47,800 --> 00:29:54,720
在Elixir中的可逆性，我的简短答案是可扩展性，让我试着解释一下为什么
invertibility inside elixir and my short answer was scalability so let me try to explain why

259
00:29:54,720 --> 00:30:02,580
可逆性有助于可扩展性，因为我们的数据不可逆，这意味着数据可以轻松地
invertibility helps in scalability since our data is not invertible that means the data can be easily

260
00:30:02,580 --> 00:30:08,720
在各个进程之间传递，并且如果另一个资源、另一个线程或者
across various processes and we don't have to worry if another resource another thread or

261
00:30:08,720 --> 00:30:14,260
另一个进程正在改变或尝试改变我们的数据，当我们理解代码在Elixir中的执行方式以及演员模型时，这个问题就会变得清楚起来
another process is changing or trying to mutate our data this thing will get clear when we

262
00:30:14,260 --> 00:30:20,960
理解代码在Elixir中的执行方式以及演员模型，这就是我们接下来要做的
understand how code is executed inside elixir and when we understand the actor model and that's what

263
00:30:20,960 --> 00:30:26,640
我们将在下一个视频中尝试理解Elixir内部的所有代码
we are going to do right in the next video let us try to understand how all of the code inside elixir

264
00:30:26,640 --> 00:30:34,480
现在所有的代码都在一个被称为演员的东西中执行，因此你可以
gets executed now all of the code gets executed in something which is called as an actor so you can

265
00:30:34,480 --> 00:30:42,360
想象你的角色就像这个盒子，现在这是一个孤立的盒子，发生的事情是
imagine your actor to be something like this box now this is an isolated box and what happens is

266
00:30:42,360 --> 00:30:49,560
这个盒子或者这个角色接收到某种消息，这些消息可能是数据，它们
this box or this actor receives some kind of messages now these messages could be data it

267
00:30:49,560 --> 00:30:56,000
可能是如何处理这些数据的指令等等。在接收到这些消息之后，你的角色
could be instructions of what to do with the data and so on after receiving these messages your actor

268
00:30:56,000 --> 00:31:03,060
会处理你的消息，并简单地返回某种响应，所以
is going to process your messages and it is simply going to give you back some kind of a response so

269
00:31:03,060 --> 00:31:10,200
简单来说，你可以想象角色就像一个孤立的竞争单位，它得到一些东西，它
in simple terms you can imagine actor to be like an isolated competition unit it gets something it

270
00:31:10,200 --> 00:31:16,000
处理一些东西，然后返回一些东西。现在发生的是这些角色在内部运行
processes something and it gives back something now what happens is this actors they run inside

271
00:31:16,000 --> 00:31:22,340
一些被称为进程的东西，而且我们在某个给定的时间可以有数百万个
something which is called as processes and at a given time we can have millions and millions of

272
00:31:22,340 --> 00:31:29,980
进程，这就是数据不可变性出现的地方，我们可以有数百万个副本
processes this is where the data immutability comes into picture we can have millions of copies of

273
00:31:29,980 --> 00:31:36,640
我们的数据，它们可以分布在各个部门，不仅仅是在我们的本地机器上，我们可以
our data and they can be distributed across various sectors not only on our local machine but we can

274
00:31:36,640 --> 00:31:43,220
拥有一个全球范围的不同服务器集群，我们可以将负载水平分布在各个部分
have a global cluster of different servers and we can distribute our load horizontally across the

275
00:31:43,220 --> 00:31:49,640
全球，所以这些进程不是你的操作系统进程，你可以把它们想象成
globe so these processes are not your operating system processes you can imagine them to be like

276
00:31:49,640 --> 00:31:55,500
虚拟线程，所以让我们一步一步地理解这些进程
virtual threads so let's try to understand these processes one step at a time we just

277
00:31:55,500 --> 00:32:02,540
看到了演员模型和这些演员，它们在你的进程内运行，对于每个进程，我们都有
saw the actor model and these actors they run inside your processes for each process we have

278
00:32:02,540 --> 00:32:07,460
一个单独的ID，称为PID，我将在此视频中很快向您展示PID
a separate id which is called as pid and i will show you the pid shortly in this video

279
00:32:08,060 --> 00:32:15,400
下一部分是我们可以通过消息传递在这些进程之间进行通信，就像我们刚刚说的那样
the next part is we can communicate between these processes by message passing and as we just said

280
00:32:15,400 --> 00:32:21,640
由于我们的数据是不可变的，我们可以创建多个副本，并且这些副本可以发送
since our data is immutable we can create multiple copies and these copies can be sent

281
00:32:21,640 --> 00:32:28,400
发送到不同的进程中，由于每个演员都有自己的数据副本，我们不必担心
to different processes and since each actor gets its own copy of data we don't have to worry if

282
00:32:28,400 --> 00:32:35,380
另一个演员正在改变状态，一切都在隔离中运行，下一部分是每个进程
another actor is changing the state everything runs in isolation the next part is each process

283
00:32:35,380 --> 00:32:41,600
有自己的堆栈和堆分配，所以如果我们来自编译型编程语言，比如
has its own stack and heap allocation so if we come from a compiled programming language such as

284
00:32:41,600 --> 00:32:48,980
C++，我们有不同的内存分配模型，您可以在堆栈内分配内存或者
C++ we have different memory allocation models you can allocate your memory inside the stack or

285
00:32:48,980 --> 00:32:56,960
在堆上，对于Elixir来说，每个进程都有自己的栈和堆分配，因此这样垃圾收集非常快
on the heap and in case of elixir each process gets its own stack and heap allocation so this

286
00:32:56,960 --> 00:33:02,480
垃圾收集非常快，我们只需要为单个进程进行垃圾收集
way the garbage collection is very fast we have to just garbage collect for a single process

287
00:33:02,480 --> 00:33:09,200
同时我们的应用程序仍然保持响应，接下来让我们再多了解一些
and our application remains responsive at the same time next let us have a little bit more

288
00:33:09,200 --> 00:33:16,700
关于我们的actor的一些细节，每个actor都有自己的邮箱，所以您传递给一个actor的每个消息都会
details about our actors every actor has its own mailbox so every message that you pass to an

289
00:33:16,700 --> 00:33:22,800
独立的进程，这些消息被收集在这个邮箱里，然后它们被执行
independent process they are collected inside this mailbox and after that they are executed

290
00:33:22,800 --> 00:33:31,200
按照顺序执行，并且执行顺序是先进先出，接下来这些进程
in a sequential order and the order of execution is first in and first out next these processes

291
00:33:31,200 --> 00:33:37,780
非常便宜地创建，它们只需要不到3KB的内存，所以您可以看到它非常便宜
are very cheap to create they require less than three kb of memory so you can see it's very cheap

292
00:33:37,780 --> 00:33:44,540
我们可以同时创建数百万个进程，最后要记住的是我们总是
and we can spawn millions of processes at a given time and the last part to remember is we always

293
00:33:44,540 --> 00:33:51,100
通过消息传递进行通信，现在让我们回到我们的终端，让我们检查一下我们的
communicate with message passing now let us go back to our terminal and let us check our

294
00:33:51,100 --> 00:33:57,980
那边的PID，PID代表您的进程ID，所以首先让我们进入我们的IEX
PID over there so PID stands for your process ID so the first thing is let us go inside our IEX

295
00:33:57,980 --> 00:34:05,540
让我现在解释清楚，这个IEX也是在一个独立的进程中运行的，我们可以检查
let me clear up everything now this IEX is also running inside a separate process and we can check

296
00:34:05,540 --> 00:34:12,400
使用内置函数self可以获取进程ID，现在关于elixir的下一件事是
process ID by using the built-in function called as self now the next thing about elixir is the

297
00:34:12,400 --> 00:34:18,760
括号不是必需的，self是一个函数，你可以写括号，也可以不写
parentheses are not mandatory self is a function you can write the parentheses or you can leave

298
00:34:18,760 --> 00:34:24,860
但是现在的一般约定是，当你在代码中编写代码时
them out but these days the general convention is whenever you are writing code inside the code

299
00:34:24,860 --> 00:34:31,220
编辑器中我们更喜欢括号，但在终端上你可以自行决定，我会不写括号
editor at that time we prefer parentheses but on the terminal it's all up to you I'm going to leave

300
00:34:31,220 --> 00:34:37,680
不写括号，这样我们就可以得到输出，所以我们的IEX正在运行的当前进程ID
them out and here we get the output so the current process ID in which our IEX is running

301
00:34:37,680 --> 00:34:46,640
就在这里，这是地址0.107.0，所以就这些，下次见
is right over here and this is the address 0.107.0 so that's it for this one and I will catch you in

302
00:34:46,640 --> 00:34:53,740
在下一个视频中，我想现在我们已经了解了足够的elixir，现在是时候编写非常重要的
the next video I think now we know enough of elixir and now it's time to write the all important

303
00:34:53,740 --> 00:35:01,200
hello world程序，让我们开始吧，让我打开我的终端，然后让我创建
hello world program so let us get started let me open up my terminal and here let me create

304
00:35:01,200 --> 00:35:07,780
一个名为functional programming with
elixir的文件夹，现在让我进入这个文件夹
a folder by the name of functional programming with elixir now let me go inside of this folder

305
00:35:08,480 --> 00:35:15,740
然后让我再创建一个脚本目录，让我进入我的脚本目录
and here let me create one more directory for scripts let me go inside my scripts directory

306
00:35:15,740 --> 00:35:25,040
然后让我再创建一个名为hello.exs的文件，现在Elixir有两个文件扩展名
and here let me create one more file by the name of hello.exs now elixir has two file extensions

307
00:35:25,040 --> 00:35:31,480
这个. s你可以在这里看到，这意味着我们要创建一个脚本文件
this dot s that you can see right over here this means that we want to create a script file

308
00:35:31,480 --> 00:35:38,680
每当我们想要创建一个编译文件的时候，我们只需要写成. ex，我们会看到
and whenever we want to create a compiled file that time we simply write as dot ex we will see

309
00:35:38,680 --> 00:35:46,160
当我们使用mix工具创建我们的第一个项目时，我们会更多地了解. ex扩展名，但现在
more about the dot ex extension when we create our first project by using the mix tool but right now

310
00:35:46,160 --> 00:35:53,560
请记住，每当我们想要创建一个脚本时，我们只需要添加一个s，现在有了
just keep in mind that whenever we want to create a script at that time we simply add a s now there

311
00:35:53,560 --> 00:36:00,400
有很多时候你需要额外的文件，例如你需要一个文件来填充你的数据库
are a lot of times when you need extra files for example you need a file to just seed your database

312
00:36:01,080 --> 00:36:07,140
或者如果你只想要一个用于测试的文件，这些文件不是用于生产的
or if you want a file just for testing these files are not meant to go into production they

313
00:36:07,140 --> 00:36:12,980
只是为了你的开发，现在让我继续创建这个文件，让我们打开它
are just meant for your development now let me go ahead and create this file and let us open up

314
00:36:12,980 --> 00:36:19,920
在我们的代码编辑器中打开此文件，现在我的代码编辑器抱怨没有找到mix文件，所以
this file inside our code editor now my code editor is complaining that no mix file found so

315
00:36:19,920 --> 00:36:24,760
现在先忽略这个，当我们使用mix创建一个项目时，它会消失
right now just ignore this and when we create a project by using mix it will go away

316
00:36:24,760 --> 00:36:30,220
让我收起边栏，那么你要记住的第一件事是
let me collapse my sidebar so the first thing that you should keep in mind that all of the

317
00:36:30,220 --> 00:36:37,560
在Elixir中，代码保留在模块内部，所以让我们创建一个模块
code inside elixir stays inside its modules so let's create a module and for creating module

318
00:36:37,560 --> 00:36:44,820
我们只需要声明我们要定义一个模块，然后给它命名为hello
we simply have to say that we want to define a module and let us name the module as hello

319
00:36:44,820 --> 00:36:52,540
接下来，在Elixir中我们没有花括号，而是有do和end代码块
and next for elixir we don't have curly brackets instead we have the do and end blocks so what we

320
00:36:52,540 --> 00:36:59,360
到目前为止，我们只是简单地定义了一个模块，所有的代码都将放在这个模块内部
have done till now is we have simply defined a module and all of the code will go inside this

321
00:36:59,360 --> 00:37:06,880
按照一般惯例，模块名和文件名应该相同，但这不是必须的
module as a general convention the module name and the file name should be same it's not required

322
00:37:06,880 --> 00:37:12,800
但是根据社区惯例，它们应该是相等的，比如让我打开我的边栏
but just as in community convention they should be equal for example let me open up my sidebar

323
00:37:12,800 --> 00:37:18,520
在这里你可以看到我们把文件命名为hello，同时也把模块命名为hello
here you can see that we have named the file as hello and we have also named the module as hello

324
00:37:18,520 --> 00:37:25,800
让我收起我的边栏，在这个模块内部我们来创建我们的第一个函数
let me collapse my sidebar and inside of this module let us create our first function and

325
00:37:25,800 --> 00:37:32,260
你可以使用关键字def来创建函数，让我们将函数称为
you can create functions by using the keyword called as def and let us call our function as

326
00:37:32,260 --> 00:37:42,780
world，这个函数不接受任何参数，所以你可以保留空括号或者
world now this function will not accept anything so you can keep your blank parentheses or you

327
00:37:42,780 --> 00:37:50,080
不接受任何参数，然后我们需要创建do和end块，在这里我们可以
does not accept any parameter then again we need to create our do and end blocks and here we can

328
00:37:50,080 --> 00:37:57,640
说一下，从我们的输入输出，我们只是想把一些东西放到输出上，这里我们只是
say that from our input output we simply want to put something to our output and here we simply

329
00:37:57,640 --> 00:38:04,220
想要显示“Hello Elixir”的消息，现在总是使用双引号来定义你的
want to display the message of hello elixir now always use the double quotes for defining your

330
00:38:04,220 --> 00:38:09,780
字符串，单引号是用来表示字符的，但是现在我们想要一个字符串，所以
strings single quotes are meant for characters but right now since we want a string that's why

331
00:38:09,780 --> 00:38:16,700
我们使用了双引号，现在让我们保存这个程序并且看看我们如何运行这个程序
we have put double quotes now let us save this program and let us see how we can run this program

332
00:38:16,700 --> 00:38:24,100
让我调整一下屏幕，我们可以用几种不同的方式来运行这个文件，让我们先看一下
let me adjust the screen we can run this file in a couple of different ways so let us see the first

333
00:38:24,100 --> 00:38:29,680
方法，在这里我们可以简单地说“嘿，Elixir，我只想让你运行一个叫做
method here we can simply say that hey elixir i simply want you to run the file which is called

334
00:38:29,680 --> 00:38:39,660
的文件”，你会看到Elixir实际上运行了我们的文件，但是我们没有任何输出，我们
as hello.exe and you can see that elixir actually ran our file but we don't have any output and we

335
00:38:39,660 --> 00:38:45,740
没有输出是因为我们还没有调用world函数，所以让我们现在调用一下吧。
don't have an output because we have not called the function of world so let us do that right over

336
00:38:45,740 --> 00:38:52,440
让我把终端稍微放下一点，我们可以在这里说
here let me take my terminal slightly down and here what we can do is here we can say that from

337
00:38:52,440 --> 00:38:59,540
我们的hello模块想要调用world函数，我们先保存文件，然后去
our module of hello i want to call the function of world let us save the file and now let us go to

338
00:38:59,540 --> 00:39:06,540
我们的终端，再试一次相同的命令，这次我们会得到输出
our terminal and let us try to run the same command one more time and this time we get the output of

339
00:39:06,540 --> 00:39:14,240
hello elixir，所以你可以在想要运行脚本文件的时候使用这个方法，但是elixir实际上是
hello elixir so you can use this method whenever we want to run a script file but elixir is actually

340
00:39:14,240 --> 00:39:20,580
一种编译语言，所以让我们看看如何实际编译这个文件，再次请保持
a compiled language so let us see how we can actually compile this file now again please keep

341
00:39:20,580 --> 00:39:26,420
记住，每当我们想要有一个编译文件的时候，文件扩展名应该是
this in mind that whenever we want to have a compiled file that time the file extension should

342
00:39:26,420 --> 00:39:33,940
是.ex，但是现在让我来展示一下我们如何编译和运行这个脚本，让我清理一下
be .ex but right now let me show you how we can compile and run this script so let me clear up

343
00:39:33,940 --> 00:39:40,500
我的终端，这里我们可以不写elixir，可以写elixir编译器，加上一个c
my terminal and here instead of writing elixir we can say that elixir compiler by adding a c

344
00:39:40,500 --> 00:39:46,180
就在这里，这代表的是elixir编译器，所以现在elixir将会编译这个文件
right over here so this stands for elixir compiler so now elixir is actually going to compile this

345
00:39:46,180 --> 00:39:52,600
文件，然后它会为我们运行，让我打开侧边栏，你可以看到我们有一个
file and then it will run for us so let me open up the sidebar here you can see that we have a

346
00:39:52,600 --> 00:39:59,040
单个文件 hello.exe，这个文件是由我们的虚拟工作室代码创建的，现在让我们编译
single file hello.exe and this one is created by our virtual studio code now let us compile the

347
00:39:59,040 --> 00:40:05,340
文件，让我们看看会发生什么，正如你在侧边栏中看到的，elixir 实际上已经编译了
file and let us see what happens so as you can see in the sidebar elixir actually compiled and

348
00:40:05,340 --> 00:40:12,680
我们有一个新文件叫做 elixir.hello.beam，现在记住 elixir 运行在 beam
虚拟机上
we have a new file called as elixir.hello.beam now remember that elixir runs on the beam virtual

349
00:40:12,680 --> 00:40:18,700
这是我们的 elixir 代码的编译文件，但通常我们不编译和
machine and this is the compiled file for our elixir code but normally we don't compile and

350
00:40:18,700 --> 00:40:24,680
像这样运行 elixir 文件，我们将使用 mix 工具，我们将在教程中更多地了解 mix 工具
run the elixir files like this we would use the mix tool and we will learn more about the mix tool

351
00:40:24,680 --> 00:40:30,420
随着我们在教程中的进展，但现在让我们按部就班，现在让我折叠我的
as we progress in the tutorials but right now let us go with the flow now let me collapse my

352
00:40:30,420 --> 00:40:36,280
侧边栏，我们还可以在 interact2 shell 中运行此文件，让我向你展示如何
sidebar we can also run this file inside our interact2 shell so let me show you how we can

353
00:40:36,280 --> 00:40:44,420
做到这一点，让我们进入我们的 interact2 shell，让我清理一切，现在我们可以说
do that let us go inside our interact2 shell and let me clear up everything now here we can say

354
00:40:44,420 --> 00:40:53,560
我们想要编译 hello.exe 文件，就这样，现在我们收到一个警告，说
that we want to compile the file of hello.exe and that's it now we are getting a warning saying that

355
00:40:54,200 --> 00:40:59,800
模块 hello，那是因为刚刚几秒钟前我们实际上编译了这个文件。
module hello and that's because just a couple of seconds back we actually compiled this file

356
00:40:59,800 --> 00:41:06,000
而且该文件目前在我们的内存中，但是现在我们可以简单地忽略所有这些东西。
and that file is currently inside our memory but right now we can simply ignore all of these things

357
00:41:06,000 --> 00:41:12,980
接下来，你的 iex 实际上运行了该文件，这里我们可以看到我们现在有了 hello elixir
的输出。
next your iex actually ran the file and here we can see we have the output of hello elixir now

358
00:41:12,980 --> 00:41:18,700
让我再清理一次屏幕，让我们看看如何手动调用函数。
let me clear up the screen one more time and let us see how we can also manually call the function

359
00:41:18,700 --> 00:41:25,340
所以在这里我们可以说我希望你进入 hello 模块，然后从那里我希望你去。
so here we can say that i want you to go to the module of hello and from there i want you to go

360
00:41:25,340 --> 00:41:31,800
到 world 函数，现在请记住，在 elixir 中括号是可选的，而且。
to the function of world now remember that parentheses are optional inside elixir and

361
00:41:31,800 --> 00:41:38,340
由于我们的 world 函数不接受任何参数，我可以使用空括号或者。
since our function of world does not accept any parameters i can have my blank parentheses or i

362
00:41:38,340 --> 00:41:45,340
可以简单地省略它们，这里你可以看到我们有一个 hello elixir 的输出，之后。
can simply leave them out and here you can see that we have an output of hello elixir and after

363
00:41:45,340 --> 00:41:51,920
之后我们还有一个消息，说好现在好表示一种被称为的数据类型。
this we also have a message saying as okay now okay symbolizes a data type which is called as

364
00:41:51,920 --> 00:41:58,720
原子，我们将在下一个视频中学到更多关于数据类型的内容，但现在让我们继续。
atom we will learn more about the data types in the next video but right now let us go with the

365
00:41:58,720 --> 00:42:06,140
现在重新流动，让我关闭终端，这次我们让这个函数接受某种参数
flow now again let me close my terminal and this time let us make the function accept some kind of

366
00:42:06,140 --> 00:42:12,240
一个参数，所以我们可以说我们希望world函数接受一个参数，然后我们
a parameter so here we can say that we want the function of world to accept a parameter and we

367
00:42:12,240 --> 00:42:18,880
将参数命名为name，然后我们可以使用字符串插值，所以让我拿出来
name the parameter as name next we can use our string interpolation so here let me take out

368
00:42:18,880 --> 00:42:25,320
elixir，这里我们需要放置井号，然后放置花括号，在括号内部
elixir and here we need to put the hash sign and then we need to put the curly brackets and inside

369
00:42:25,320 --> 00:42:31,560
花括号中，我可以简单地使用我们的参数name，还有，让我删除这一行，这行不需要
the curly brackets i can simply use our parameter of name and also let me take out this line this

370
00:42:31,560 --> 00:42:38,840
不需要了，所以让我们打开终端，现在iex正在运行，因为我们做了改动
is not required so let us open up our terminal and we have our iex running now since we changed the

371
00:42:38,840 --> 00:42:46,040
让我们重新编译模块，我们可以通过输入r来进行，r是重新编译的意思，我们
let us recompile the module and we can do that by typing r now r stands for recompile and we

372
00:42:46,040 --> 00:42:52,020
只需要重新编译我们的hello模块，就这样，我们重新定义了这个模块
simply want to recompile our module of hello and that's it we have redefined the module

373
00:42:52,020 --> 00:42:59,820
让我清理一下，这里我们可以说hello.world，现在让我们传递一个叫做
let me clear it up and here we can say that hello dot world and now let us pass a parameter called

374
00:42:59,820 --> 00:43:06,380
octalium的参数，我们得到了hello octalium的输出，现在记住括号的使用
as octalium and we have the output of hello octalium now remember that the parentheses

375
00:43:06,380 --> 00:43:12,340
是可选项，所以我们也可以像这样写，让我去掉括号，让我
are optional so we can also write something like this let me take out the parentheses and let me

376
00:43:12,340 --> 00:43:19,040
在这里之间加上一个空格，这样我们可以看到这段代码也是有效的，我们得到了完全相同的
give a space right between over here so as we can see this code is also valid and we get the exact

377
00:43:19,040 --> 00:43:24,520
相同的输出，就是这样，这个视频就到这里了，接下来我们将看到Elixir中的不同数据类型
same output well that's it for this video and we will see the different data types in elixir

378
00:43:24,520 --> 00:43:30,560
从下一个开始，让我们尝试更多地了解Elixir中的不同数据类型
right from the next one let us try to learn more about the different data types in elixir

379
00:43:31,200 --> 00:43:37,400
我想提醒你的第一件事是，Elixir中的所有数据类型都是不可变的
the first thing which i wanted to remind you is all of the data types in elixir are immutable

380
00:43:37,400 --> 00:43:44,280
通俗地说，我想说的是Elixir中的所有数据类型都是常量
in common terms what i mean to say is all of the data types inside elixir are constants

381
00:43:44,880 --> 00:43:51,240
现在，考虑到这个概念，让我们继续前进，让我们试着学习第一个数据类型和
now with this concept in mind let us go ahead and let us try to study the first data type and the

382
00:43:51,240 --> 00:43:58,880
数据类型被称为原子，Elixir中的原子看起来像这样，我们有一个冒号符号
data type is called as an atom an atom in elixir looks something like this so we have a colon symbol

383
00:43:58,880 --> 00:44:05,740
在冒号后面，我们有原子的名称，如果名称中有一些空格
and after the colon we have the name of the atom and in case there is some space inside the name

384
00:44:05,740 --> 00:44:12,220
原子，那么我们可以像这样写一个原子，所以语法是这样的，你的原子将
of the atom then we can write an atom like this so again the syntax goes like this your atom will

385
00:44:12,220 --> 00:44:17,760
始终以冒号开头，然后是原子的名称，在这种情况下，由于我们有
always start with a colon and then we have the name of the atom and in this case since we have

386
00:44:17,760 --> 00:44:24,780
原子名称中有一个空格，我们使用双引号，在双引号内部我们有
a space inside the name of our atom we are using double quotes and inside the double quotes we have

387
00:44:24,780 --> 00:44:32,560
原子的名称，现在这只是原子的语法，但是现在让我们继续并尝试一下
the name of the atom now this was just the syntax of an atom but now let us go ahead and let us try

388
00:44:32,560 --> 00:44:39,800
理解原子的全部内容，所以让我们考虑这种情况，所以我们有一个符号或者一个
to understand what's an atom all about so let's consider this scenario so we have a symbol or a

389
00:44:39,800 --> 00:44:46,440
像这样的标志，你能告诉我这个标志象征着什么吗，这个标志是一个非常受欢迎的
logo like this can you tell me what this logo symbolizes now this logo is of a very popular

390
00:44:46,440 --> 00:44:53,760
品牌，这个品牌是耐克，所以在这种情况下发生了什么，这个符号与
brand and that brand is nike so what's happening in this case this symbol is synonymous with the

391
00:44:53,760 --> 00:45:00,880
耐克的名字，如果我向你展示这个符号或者我向你展示这个名字，这两个值都指向
name of nike if i show you the symbol or if i show you the name both of these values point to the

392
00:45:00,880 --> 00:45:07,600
完全相同的东西，所以这只是一个伪代码，这不是一个有效的elixir语法，但让我们
exact same thing so this is just a pseudo code and this is not a valid elixir syntax but let us

393
00:45:07,600 --> 00:45:13,500
了解原子的概念，所以这里发生的是我们有一个变量
understand the concept of an atom so what's happening right over here is we have a variable

394
00:45:13,500 --> 00:45:21,220
变量的名称是nike，分配给这个变量的值也是nike，所以简而言之
and the name of the variable is nike and the value assigned to this variable is also nike so in short

395
00:45:21,220 --> 00:45:29,080
值和名称是相同的，这就是原子所代表的。在一个原子中，名称
the value and the name are the same and this is what an atom represents in an atom the name

396
00:45:29,080 --> 00:45:36,340
而且值总是相同的，我们可以用原子来表示，就像这样，所以我们有一个
and the value is always same and we can represent this in terms of atom like this so we have an

397
00:45:36,340 --> 00:45:43,400
为了nike，让我们打开我们的ix，我们可以从那里开始玩，所以这是我的
atom for nike let us open up our ix and we can start playing right over there so this is my

398
00:45:43,400 --> 00:45:51,160
终端让我进入我的ix，让我清除屏幕，所以让我们为此创建相同的原子
terminal let me go inside my ix and let me clear out the screen so let us create the same atom for

399
00:45:51,160 --> 00:45:58,860
nike，所以我们可以说nike，这就是原子的全部内容。假设我们有一个非常长的名称，其中包含
nike so we can say nike this is what an atom is all about suppose we had a very long name that had

400
00:45:58,860 --> 00:46:07,580
中间有空格，所以我们可以说像这样the和nike，所以这也是一个有效的原子
spaces in between so we can say something like this the and nike so this is also a valid atom

401
00:46:08,120 --> 00:46:14,040
而且你会注意到我们的原子总是以冒号开头，现在我们可以做的是让我们去
and you will notice that our atom always starts with a colon now what we can do is let us go to

402
00:46:14,040 --> 00:46:22,140
我们的活动手册，我们可以在那里创建更多的原子示例，所以这是我们的活动手册
our live book and there we can create a couple of more examples of atom so this is our live book

403
00:46:22,140 --> 00:46:31,600
让我们创建一个新的笔记本，让我给它一个标题叫做数据类型，这一节是关于
and let us create a new notebook let me give the title as data types and this section is all about

404
00:46:31,600 --> 00:46:39,460
在Elixir中，我们的原子无处不在，原子在模式匹配中被广泛使用
our atom in elixir you will see atoms everywhere atoms are very heavily used for pattern matching

405
00:46:39,460 --> 00:46:44,640
现在假设你正在开发某种应用程序，而且你想返回一个错误消息
now suppose you are working on some kind of an application and you want to return an error

406
00:46:44,640 --> 00:46:50,820
那么我们可以简单地创建一个名为error的atom
message so that time what we can do is we can simply create an atom called as error so we can

407
00:46:50,820 --> 00:46:57,400
像这样说error，然后让我们点击评估，这样我们就创建了一个
say something like this error and let us click on evaluate so here it is we have created an

408
00:46:57,400 --> 00:47:03,080
叫作error的atom，接下来让我给你展示这种atom的一个非常实用的用法
atom which is called as error next let me show you a very practical use of this kind of an atom

409
00:47:03,080 --> 00:47:09,260
所以让我们拿同样的例子来说，假设我们正在开发一个应用程序，然后出现了一个错误
so let's take the exact same example suppose we are working on an application and we have an error

410
00:47:09,260 --> 00:47:15,720
在那种情况下，我们找不到一个文件，所以很常见的做法是返回一个元组
where we are not able to find a file so at that time it's very common to return back a tuple

411
00:47:15,720 --> 00:47:21,280
而且这个元组由这些花括号表示，稍后我会详细介绍元组
and the tuple is represented by these curly strings now i will cover tuples a little later

412
00:47:21,280 --> 00:47:26,680
但现在让我们顺其自然，元组里面我们可以说
in the series but right now let's go with the flow and inside the tuple we can say that the

413
00:47:26,680 --> 00:47:33,000
第一个元素是一个错误，所以在那个操作中出现了一些错误，然后我们可以描述这个错误
first element is an error so there is some error in that operation and then we can describe the

414
00:47:33,560 --> 00:47:41,220
所以我们可以说，例如，文件未找到，这种模式在elixir中非常常见
error so we can say for example file not found and this kind of pattern is very common inside elixir

415
00:47:41,220 --> 00:47:47,140
通常我们会有一个包含两个元素的元组或者三个元素的元组，你经常会看到
normally we will have a two element tuple or a three element tuple and regularly you will see

416
00:47:47,140 --> 00:47:53,440
我们只是在这个元组上进行模式匹配，所以我们可以在左边再次进行模式匹配
that we simply pattern match on this tuple so what we can do is on the left hand side we can again

417
00:47:53,440 --> 00:47:58,880
与这个元组进行模式匹配，让我在这里创建一个新的元组，第一个元素是
pattern match with this tuple so let me create a new tuple right over here and the first element

418
00:47:58,880 --> 00:48:05,180
是一个错误，第二个元素我们可以称为原因，现在再次发生的是
is an error the second element we can call it as a reason now again what's happening over here is

419
00:48:05,180 --> 00:48:11,180
我们只是在使用模式匹配，我希望你回到你的左手概念
we are simply using our pattern matching i want you to go back to the concept of your left hand

420
00:48:11,180 --> 00:48:18,060
左边等于右边，所以在右边我们有一个元组，在左边
side is equal to your right hand side so on the right hand side we have a tuple and on the left

421
00:48:18,060 --> 00:48:24,160
手边我们有一个元组，接下来发生的是，在右边我们有一个叫做文件的字符串
hand side we have a tuple next what is happening is on the right we have a string called as file

422
00:48:24,160 --> 00:48:30,860
不存在，而在左边，我们有一个变量哦，让我拼写正确，这必须是
not found and on the left we have a variable oh let me get the spelling right this has to be

423
00:48:30,860 --> 00:48:37,100
原因，所以发生的是，因为我们在左边有一个变量，这个值
reason so what's happening is since we have a variable on the left hand side this value of

424
00:48:37,100 --> 00:48:43,620
文件未找到将绑定到我们的原因变量，让我们点击重新评估和
file not found is being bound to our variable of the reason so let us click on reevaluate and

425
00:48:43,620 --> 00:48:49,740
让我们看看发生了什么，我们得到了我们的元组回来的错误文件找不到，让我们把这个分成
let us see what's happening and we get our tuple back error file not found let us split this into

426
00:48:49,740 --> 00:48:55,140
不同的代码块，所以让我在这里创建一个代码块，让我带走这段代码
different code blocks so let me create a code block right over here and let me take this code

427
00:48:55,140 --> 00:49:01,760
从这里拿出来，然后让我再粘贴到这里，让我点击重新评估，在这里我们也是这样
out from here and let me paste it right over here again let me click on reevaluate and here also we

428
00:49:01,760 --> 00:49:07,780
现在可以评估了，我们可以做的是，由于我们使用了模式匹配，我们可以提取出值
can evaluate now what we can do is since we are using pattern matching we can extract the value

429
00:49:07,780 --> 00:49:15,220
找不到文件，我刚才说过，找不到这个值绑定到我们的变量
of file not found and i just said that this value of file not found is bound to our variable of

430
00:49:15,780 --> 00:49:22,680
我们可以通过简单地输入我们的原因来检查值，让我们点击重新评估，在这里
and we can check out the value by simply typing our reason and let us click on reevaluate and here

431
00:49:22,680 --> 00:49:29,840
我们得到了找不到文件的值，现在这个模式在elixir中非常常见，所以让我们
we get the value back file not found now this pattern is very very common in elixir so let us

432
00:49:29,840 --> 00:49:36,320
再看一个例子，假设这次我们有一个成功的操作，例如
have a look at one more example and suppose this time we have a successful operation for example

433
00:49:36,320 --> 00:49:42,100
如果我们正在开发某种网络应用程序，并且我们收到一个状态为200的消息
if we are working on some kind of an web application and we get back a status 200 message

434
00:49:42,100 --> 00:49:49,240
那么此时我们可以对"okay"进行模式匹配，然后可以获得一条消息和
so at that time what we can do is we can pattern match on okay and then we can have a message and

435
00:49:49,240 --> 00:49:57,740
这里我们可以传递我们的“好的”，我们可以说状态200好的，然后我们可以看到我们的内容
here we can pass our okay and we can say status 200 okay and then we can see the contents of our

436
00:49:57,740 --> 00:50:04,020
现在让我们点击“评估”，正如你所看到的，我们得到了消息的值，所以再一次
message now let us click on evaluate and as you can see we get the value of message back so again

437
00:50:04,020 --> 00:50:08,800
同样的事情发生在这里，我们只需要在右边进行模式匹配
the same thing is happening over here we simply have to pattern match the right hand side along

438
00:50:08,800 --> 00:50:15,340
左边的“好的”与右边的“好的”匹配，这个字符串正在被
with the left hand side okay is matching with the okay right over here and this string is being

439
00:50:15,340 --> 00:50:20,660
绑定到我们的消息变量上，这就是我们在下一行调用的内容
bound to our variable of message and that's what we are calling on the next line right over here

440
00:50:20,660 --> 00:50:26,240
嗯，这就是关于原子的一切，下一个视频我们将从elixir内部的字符串开始
well this was all about atoms and in the next video we will start with strings inside elixir

441
00:50:26,880 --> 00:50:33,860
我们系列中的下一个数据类型将是字符串，而elixir中的字符串则是这样表示的
the next data type in our series is going to be the string and strings in elixir are represented

442
00:50:33,860 --> 00:50:40,500
由双引号表示，所以这将是elixir的一个有效字符串，我们有双引号
by double quotes so this is going to be a valid string for elixir we have the double quotes and

443
00:50:40,500 --> 00:50:46,560
在双引号内我们有字符串，现在如果你使用单引号而不是双引号
inside the double quotes we have the string now instead of the double quotes if you use a single

444
00:50:46,560 --> 00:50:53,260
那么这意味着一个字符列表，而字符列表与字符串不同
quote then that would mean a character list and a character list is different from a string inside

445
00:50:53,260 --> 00:51:00,940
现在我们来玩一下elixir，让我们进入我们的ix。
elixir now let us go and play a little bit with strings inside our ix now let us go inside our ix

446
00:51:00,940 --> 00:51:07,840
让我清理一下屏幕，就像我刚才说的，我们可以使用双引号创建一个字符串。
and let me clear up the screen and as i just said we can create a string by using our double

447
00:51:07,840 --> 00:51:14,940
所以让我写一个octalium，这将是一个有效的字符串在elixir中，现在会发生什么呢？
quotes so let me write octalium so this is going to be a valid string inside elixir now what happens

448
00:51:14,940 --> 00:51:21,780
ix还为我们提供了很多方便的函数来检查不同的数据类型。
the ix also provides us with a lot of convenience functions for checking different data types

449
00:51:21,780 --> 00:51:27,480
其中一种用于显示信息的函数被称为i，让我们调用它。
and one such function for displaying the information is called as i so let us call

450
00:51:27,480 --> 00:51:32,900
让我们传递octalium的变量，并看看我们得到了什么样的输出。
i and let us pass the variable of octalium and let us see what kind of output we are getting

451
00:51:33,660 --> 00:51:41,760
所以我们可以看到这个项是octalium，数据类型是二进制字符串，那么会发生什么呢？
so we can see that the term is octalium and the data type is a binary string so what happens

452
00:51:41,760 --> 00:51:48,360
在elixir中，你的字符串实际上是保存为一系列字节，这就是为什么它会说
inside elixir is your strings are actually saved as a collection of bytes that's why it is saying

453
00:51:48,360 --> 00:51:57,460
数据类型是二进制字符串，接下来我们的字符串大小是九个字节，接下来
that the data type is a binary string next the size of our string is nine bytes and the next

454
00:51:57,460 --> 00:52:05,240
字符串实际上是一个UTF-8编码的二进制，现在我刚才说过你的字符串被保存为一份
string is actually a utf-8 encoded binary now i just said that your strings are saved as a

455
00:52:05,240 --> 00:52:10,960
字节的集合，这是它在内存中的实际样子，正如你所见
collection of bytes and this is how it actually looks inside your memory and as you must have

456
00:52:10,960 --> 00:52:17,700
注意到它以双角括号开头，也以双角括号结尾
noticed it starts with double angle brackets and it also ends with the double angle brackets now

457
00:52:17,700 --> 00:52:24,160
在这个集合中，你可以看到每个字符的整数表示
inside of this collection you can see that we have the individual integer representation of each of

458
00:52:24,160 --> 00:52:33,400
字符串中的字符，比如整数79表示o，99表示c
characters inside our string for example the integer of 79 denotes a o 99 denotes a c and

459
00:52:33,400 --> 00:52:40,120
接下来，我们还可以看到为字符串类型实现的一些协议
so on next we can also see a couple of protocols that are implemented for the type of a string

460
00:52:40,120 --> 00:52:45,660
协议是一个稍微高级的主题，本教程不涉及协议内容
now protocols are a slightly advanced topic and will not be covering protocols in this tutorial

461
00:52:45,660 --> 00:52:51,340
但是现在让我们继续，看看我们还能用字符串做些什么，现在让我们来看一下
but for now let us go ahead and let us see what else we can do with the strings now let us have

462
00:52:51,340 --> 00:52:57,180
通过模式匹配来看看字符串的神奇之处，现在字符串只是
a look at a little bit of magic of pattern matching with our strings now strings is just

463
00:52:57,180 --> 00:53:04,220
我们的字节的一个集合，我们可以使用模式匹配来提取其中的个体
a collection of our bytes and what we can do is we can use our pattern matching to extract individual

464
00:53:04,220 --> 00:53:10,980
从字符串中提取代码点，让我清除屏幕，我们可以简单地做以下操作
code points from our string so let me clear up the screen and here what we can do is we can simply

465
00:53:10,980 --> 00:53:18,600
找到一个o来匹配八进制字符octalium，所以我们可以说我们的第一个字符应该是o，然后我们
match for an o for octalium so we can say that our first character should be o and the next one we

466
00:53:18,600 --> 00:53:26,800
收集到一个不同的变量中，叫做rest，它等于octalium，让我们看看接下来会发生什么
collect in a different variable called as rest is equal to octalium and let us see what happens next

467
00:53:26,800 --> 00:53:33,440
现在让我们看一下rest变量的内容，我们可以看到rest变量
now let us see the contents of the variable of rest and here we can see that the rest variable

468
00:53:33,440 --> 00:53:40,080
包含了o之后的所有字母，那么这一行发生了什么呢，再来看一下
contains all of the alphabets after o so what's happening on this line right over here so again

469
00:53:40,080 --> 00:53:45,880
同样的道理，你的左边应该等于你的右边，在右边
the same thing goes your left hand side should be equal to your right hand side on the right hand

470
00:53:45,880 --> 00:53:51,840
我们有一个大写字母o，这是一个模式匹配，接下来是一个字符串
we have a capital o and that is being pattern match right over here and next we have a string

471
00:53:51,840 --> 00:53:57,960
连接运算符，我们说我们要收集所有不同的代码点
concatenation operator and we are saying that we want to collect all of the different code points

472
00:53:57,960 --> 00:54:04,500
在一个叫做rest的变量中的o之后，那么从其他字符开始会发生什么
after o inside a variable called as rest so what happens all of the other characters starting from

473
00:54:04,500 --> 00:54:15,240
从c一直到m，这些字符被绑定到我们的rest变量上，这就是我们的目的
c all the way to m these characters get bound to our variable of rest and that's what we are

474
00:54:15,240 --> 00:54:21,700
例如，假设我们再次想要看一下一个叫做abc的新字符串的信息
example suppose we again want to see the information for a new string called as abc

475
00:54:21,700 --> 00:54:28,000
现在再次，括号是可选的，所以即使我去掉这个括号，代码也应该
now again the parentheses are optional so even if i take out this parenthesis still the code should

476
00:54:28,000 --> 00:54:35,080
工作了，这里我们得到了输出，我们可以看到a、b和c的原始表示是
work and here we get the output and here we can see that the raw representation of a b and c is

477
00:54:35,080 --> 00:54:42,000
就在这里，现在发生的是，97只是表示我们字符a的代码点
right over here now what's happening is 97 simply denotes the code point for our character of a

478
00:54:42,000 --> 00:54:47,880
我们可以通过使用不同的语法来检查它，所以我们可以放一个问号后面
and we can check that out by using a different syntax so we can put a question mark followed

479
00:54:47,880 --> 00:54:56,060
由a，这样我们就得到了a的代码点表示，在这里我们可以看到它是97，这就是
by a so this gives us the code point representation for a and here we can see that it's 97 and that's

480
00:54:56,060 --> 00:55:01,860
我们现在拥有的，假设我们想要查看b的代码点，那么b将会是
what we have right over here now suppose we want to see the code point for b so b is going to be

481
00:55:01,860 --> 00:55:09,500
98，对于c将是99，等等，现在我们把所有这些点记在心里，让我们继续
98 and for c it's going to be 99 and so on now with all of these points in our mind let us go

482
00:55:09,500 --> 00:55:16,780
我们的实时书，让我们再多玩一下字符串，所以在这里让我们创建
our live book and let's start playing a little bit more with our strings so here let us create

483
00:55:16,780 --> 00:55:23,380
一个新的部分，所以我想去博客上创建一个新的部分，这个部分是关于你的
a new section so i want to go on blog and create a new section and this section is all about your

484
00:55:23,380 --> 00:55:31,560
字符串，所以让我们在这里创建相同的字符串，这样我们就可以说我们想创建一个变量
strings so let us create the same string right over here so we can say we want to create a variable

485
00:55:31,560 --> 00:55:38,400
称之为name，并将其值分配给octalim，然后让我们打印出来
called as name and let us assign the value of octalim to this one next let us just print out

486
00:55:38,400 --> 00:55:44,700
name的值，让我们看看我们得到了什么输出，正如预期，我们得到了我们的字符串
value of name and let us see what output we are getting and as expected we are getting our string

487
00:55:44,700 --> 00:55:52,280
接下来我们还可以检查给定的数据是否为字符串类型，为此我们可以
back next we can also check if the given data is of the type of string or not so for that we can

488
00:55:52,280 --> 00:55:59,760
使用一个名为is_binary的内置函数，所以记住你的字符串被表示为一个
use an inbuilt function called as is binary so remember your strings are represented as a

489
00:55:59,760 --> 00:56:06,940
原始代码点的集合或字节的集合，所以我们可以使用这个is的函数
collection of your raw code points or a collection of your bytes so we can use this function of is

490
00:56:06,940 --> 00:56:13,740
二进制，并让我们传递name变量，让我们尝试计算，我们得到的答案是
binary and let us pass the variable of name and let us try to evaluate and we get the answer as

491
00:56:13,740 --> 00:56:20,780
true，所以是的，这是一个二进制表示，这意味着这是一个字符串，接下来让我们看看如何将两个字符串相加
true so yes this is a binary that means this is a string next let us see how we can add two strings

492
00:56:20,780 --> 00:56:27,440
所以让我创建一个新的代码块，让我们创建一个名为message的新变量
together so let me create a new code block and let us create a new variable called as message

493
00:56:27,440 --> 00:56:34,560
在这里我们可以创建一条消息，说hello，并且对于添加或连接，我们有
and here we can create a message saying that hello and for adding or for concatenating we have

494
00:56:34,560 --> 00:56:41,740
这个双角括号，然后让我们传递name变量，所以再次只是为了帮助你
this double angle brackets and then let us pass our variable of name so again just to help you

495
00:56:41,740 --> 00:56:47,980
记住这里有尖括号，如果你回到我们的终端，我们可以看到
remember here we have the angle brackets and if you go back to our terminal and here we can see

496
00:56:47,980 --> 00:56:53,760
这里的原始表示法也有尖括号，唯一的区别是
the raw representation here also we have the angle brackets the only difference is for the

497
00:56:53,760 --> 00:56:59,600
我们使用双尖括号进行表示，而用于字符串连接的是单个尖括号
representation we use the double angle brackets and for string concatenation we use the single

498
00:56:59,600 --> 00:57:05,180
尖括号，让我们看看这个的输出，让我们试着评估一下，这里是
angle bracket so let us see the output of this one so let us try to evaluate and here we have

499
00:57:05,180 --> 00:57:11,360
hello octalium的消息，接下来我们可以使用模式匹配，让我们试着提取值
the message of hello octalium next we can use our pattern matching and let us try to extract values

500
00:57:11,360 --> 00:57:17,140
从字符串中，所以让我们创建一个新的代码块，这里我们可以再次进行模式匹配，所以我们可以说
from the string so let's create a new code block and here again we can pattern match so we can say

501
00:57:17,140 --> 00:57:23,960
前几个字符应该是hello，然后是hello后面的剩余部分我想要收集起来
that the first couple of characters should be hello and after hello i want to collect the remaining

502
00:57:23,960 --> 00:57:30,500
放在一个名为name的新变量中，在右边我们只需要传递消息
in a new variable called as name and on the right hand side we have to simply pass the message so

503
00:57:30,500 --> 00:57:36,900
记住消息是hello octalium，所以hello和这个空格，就是
remember message is hello octalium so hello and this space right over here this is going to be

504
00:57:36,900 --> 00:57:43,080
模式匹配就在这里，octalium的名字将绑定到我们的name变量上
pattern matching right over here and the name of octalium would be bound to our variable of name

505
00:57:43,080 --> 00:57:49,080
接下来我们还可以查看变量name的内容，所以让我们把它写在这里。
next we can also check out the contents of the variable of name so let us write it over here

506
00:57:49,080 --> 00:57:55,320
让我们尝试进行评估，这里我们得到的名字是octalium，现在还有一种方式。
and let us try to evaluate and here we get the name back as octalium now there is one more way

507
00:57:55,320 --> 00:58:01,980
通过与字符串进行模式匹配，这种方法是通过对原始表示进行模式匹配。
of pattern matching with our strings and this method is by pattern matching on the raw representation

508
00:58:01,980 --> 00:58:08,000
所以让我们看看我们如何做到这一点，让我们创建一个新的代码块，现在请记住原始字符串。
so let's see how we can do that so let us create a new code block now remember that the raw string

509
00:58:08,000 --> 00:58:14,620
表示是由我们的双尖括号完成的，让我们试着进行模式匹配，所以在这里我们
representation is done by our double angle brackets and here let us try to pattern match so here we

510
00:58:14,620 --> 00:58:22,520
想要对第一个字符或第一个代码点进行模式匹配，并且让我们称之为
want to pattern match the first character or the first code point in a new variable and let us call

511
00:58:22,520 --> 00:58:29,120
将该变量称为head，接下来我们要做的就是要收集所有剩余的代码
that variable as head next what we want to do is we simply want to collect all of the remaining code

512
00:58:29,120 --> 00:58:36,240
点，并且我们可以将该变量称为rest，现在由于我们使用原始的表示
points in a new variable and we can call that variable as rest now since we are using the raw

513
00:58:36,240 --> 00:58:42,700
字符串表示，我们还需要告诉Elixir我们想要以哪种格式收集所有的
string representation we also need to tell to elixir in which format do we want to collect all

514
00:58:42,700 --> 00:58:49,640
剩余的代码点，所以在这里我们可以说rest的类型将是二进制，并且在右侧
the rest code points so here we can say that the type of rest would be binary and on the right hand

515
00:58:49,640 --> 00:58:56,840
我们只需要与名称进行模式匹配，然后看看变量中的内容
side we simply have to pattern match with name and next let us see what is inside our variable of

516
00:58:56,840 --> 00:59:03,320
头部，然后让我们尝试评估这个单元格，现在发生的是
head and let us try to evaluate this cell so what's happening right now is instead of getting a

517
00:59:03,320 --> 00:59:09,340
我们实际上得到了代码点，如果我们回到终端，我们可以看到
string back we actually get the code point back and if we refer back to our terminal as we can see

518
00:59:10,100 --> 00:59:17,460
所以这个97实际上表示的是我们的代码点a，这就是发生的事情
so this 97 actually denotes our code point of a so that's what is happening right over here

519
00:59:17,460 --> 00:59:25,540
所以在这种情况下，79实际上表示的是我们o的代码点，我们可以在一个新的代码块中检查一下
so in this case 79 actually denotes the code point for our o and we can check it out in a new

520
00:59:25,540 --> 00:59:32,660
代码块，所以让我们在这里创建一个新的代码块，在这里我们可以说我的头等于
block so let us create a new block right over here and here we can say that is my head is equal to

521
00:59:32,660 --> 00:59:38,780
o的代码点，让我们尝试评估并看看我们得到什么答案，是的
the code point of o and let us try to evaluate and see what answer we are getting so yes the

522
00:59:38,780 --> 00:59:43,980
答案是真的，所以如果你感到有点困惑，让我们回到我们的终端
answer is true so if you are feeling a little bit confused so let us go back to our terminal

523
00:59:44,700 --> 00:59:50,720
让我清除所有这些东西，让我们检查一下我们的o字符的代码点
let me clear all of these things and let us check the code point for our character of o

524
00:59:50,720 --> 00:59:57,460
我们得到了79的整数表示，这就是我们在这里检查的内容
and we get the integer representation as 79 and that's what we are checking right over here so

525
00:59:57,460 --> 01:00:03,640
头部的值是79，这是我们在这行中要检查的，而且由于字符
the value inside head is 79 and that's what we are checking in this line and since the character

526
01:00:03,640 --> 01:00:10,540
o也是79，这就是为什么这个表达式评估为真，所以你可以看到
o is also 79 that's why this expression is evaluating to a true so you can see that

527
01:00:10,540 --> 01:00:16,520
模式匹配在Elixir中非常强大，我们几乎在任何地方都使用模式匹配
pattern matching is very powerful inside elixir and we use pattern matching practically everywhere

528
01:00:16,520 --> 01:00:23,980
在Elixir内，让我们使用相同的示例，所以让我从这里复制，让我们创建一个新的
inside elixir let us take the same example so let me copy from here and let us create a new

529
01:00:23,980 --> 01:00:29,720
代码块，让我将其粘贴在这里，而不是使用这个head变量
code block and let me paste it right over here and here instead of using this variable of head

530
01:00:29,720 --> 01:00:36,960
让我们对o进行模式匹配，看看我们是否能够找到剩余的部分，让我们尝试评估一下
let us pattern match on o and let us see if we can get the rest back and let us try to evaluate

531
01:00:36,960 --> 01:00:43,320
这个表达式，我们得到了正确的答案，所以现在我们得到了从c到m的所有字符
this expression and we get the right answer back so we get all of the characters from c to m now

532
01:00:43,320 --> 01:00:49,280
并不一定非得只在单个字符上进行模式匹配，我们可以在多个字符上进行模式匹配
it's not mandatory to just pattern match on a single character we can pattern match on multiple

533
01:00:49,280 --> 01:00:56,100
所以让我复制这个，让我们创建一个新的代码块，让我将其粘贴在这里
characters so let me copy this one let us create a new code block and let me paste it over here

534
01:00:56,100 --> 01:01:02,300
这次我们可以使用两个字符，所以让我们在o和c上进行模式匹配，然后让我们检查
and this time we can use two characters so let us pattern match on o and c and next let us check

535
01:01:02,300 --> 01:01:08,920
获取剩余部分的内容，然后让我们尝试评估这个单元格，正如你所看到的，我们得到了正确的结果
the contents of rest and let us try to evaluate this cell and as you can see we get the right

536
01:01:08,920 --> 01:01:15,240
输出，所以你可以看到模式匹配在Elixir中真的非常强大，接下来你可以
output so you can see that pattern matching is really very powerful inside elixir next you can

537
01:01:15,240 --> 01:01:21,060
在与字符串进行模式匹配时，你也可以非常具体地指定数量
be also very specific while pattern matching with strings you can actually specify the number of

538
01:01:21,060 --> 01:01:26,540
你想收集的字符串，所以让我给你展示一个例子，让我们在这里创建一个
strings that you want to collect so let me show you an example right over here let us create a

539
01:01:26,540 --> 01:01:34,200
新的代码块，让我在这里复制这个东西，现在不要说o和c了，我们
new code block and let me copy this thing right over here now instead of saying o and c what we

540
01:01:34,200 --> 01:01:39,860
可以做的是我们可以说我们想要创建一个变量，叫做head，而在这个变量里面
can do is we can say that we want to create a variable called as head and inside this variable

541
01:01:39,860 --> 01:01:46,560
我们想要收集前两个二进制，所以在这里我们可以说我们想要收集二进制
we want to collect the first two binaries so here we can say that we want to collect the binary

542
01:01:47,100 --> 01:01:53,340
而且二进制的大小应该是两个字符，接下来让我们检查一下我们的输出
and the binary size should be for two characters next let us check the output of our

543
01:01:53,840 --> 01:02:00,900
head，然后让我们尝试评估一下这个，正如你所看到的，我们得到了字符o和c
head and let us try to evaluate this one and as you can see we get the characters of o and c

544
01:02:00,900 --> 01:02:06,520
回来了，好了，这就是Elixir中关于字符串的全部内容，如果你不理解这个模式，不要担心
back well this was all about strings inside elixir now don't worry if you don't get this pattern

545
01:02:06,520 --> 01:02:11,300
与二进制匹配和所有这些东西，我只是想向你展示所有不同的
matching with binaries and all of these things i just wanted to show you all of the different

546
01:02:11,300 --> 01:02:19,040
通过在elixir内部使用模式匹配，下一个数据类型是我们的字符列表或
possibilities by using pattern matching inside elixir the next data type is our char list or

547
01:02:19,040 --> 01:02:25,220
我们的字符列表，如我已经解释过的，通过使用单个字符创建
our character list and as i have already explained the character list is created by using single

548
01:02:25,220 --> 01:02:30,420
引号，所以让我们创建一个名为characters的变量，并赋值为
quotes so let us create a variable called as characters and let us assign the value of

549
01:02:30,420 --> 01:02:36,940
octalium，现在你可以看到我在这里使用单引号，我们得到了值
octalium now as you can see i'm using single quotes right over here and we get back the value

550
01:02:36,940 --> 01:02:42,820
octalium的，现在让我们做一件事，让我复制这个并让我们去我们的终端
of octalium now let us do one thing let me copy this and let us go to our terminal

551
01:02:43,340 --> 01:02:50,280
在我的ix内部，我可以检查信息，所以我可以使用i的内置函数
and inside my ix i can check for the information so i can use the inbuilt function of i

552
01:02:50,280 --> 01:02:55,520
让我把字符字符串粘贴在这里，让我们看看我们得到了什么样的输出
and let me paste the character string right over here and let us see what kind of output we are

553
01:02:55,520 --> 01:03:03,360
得到的结果，所以这次如果你看到数据类型实际上是一个列表，上一次我们在学习的时候
getting so this time if you see the data type is actually a list last time when we were studying

554
01:03:03,360 --> 01:03:11,420
关于字符串，数据类型是一个二进制字符串，但这是一个包含字符的集合内部的
about strings the data type was a binary string but this is a collection of characters inside a

555
01:03:11,420 --> 01:03:18,900
列表，如果您想查看原始表示形式，这里就是，请注意，由于这是一个
list and if you want to see the raw representation so here it is now please note that as this is a

556
01:03:18,900 --> 01:03:25,480
列表的开头和结尾都有方括号，正如您所见，每个
list we have square brackets at the start and also at the end and as you can see each of the

557
01:03:25,480 --> 01:03:32,600
字符也由其整数值表示，所以再次重申，79表示
characters are also represented by their integer values so again the same thing goes 79 represents

558
01:03:32,600 --> 01:03:42,760
'o'，其值为99，然后是'c'，其值为116，依此类推，让我们回到我们的实时书中
o then the value for c is 99 then for t it is 116 and so on so let us go back to our live book

559
01:03:43,940 --> 01:03:49,660
接下来，让我们看看如何将两个字符列表相加，所以让我添加一个新的块
next let us see how we can add two character lists together so let me add a new block

560
01:03:49,660 --> 01:03:57,700
在这里，让我创建一个新的字符字符串，让我说一声“你好”，用于添加或连接
and here let me create a new character string and let me say hello and for adding or concatenating

561
01:03:57,700 --> 01:04:03,780
两个列表在一起，我们必须使用双加号符号，让我传递字符值
two lists together we have to use the double plus symbol and let me pass the characters value

562
01:04:03,780 --> 01:04:09,740
就在这里，让我们尝试评估此单元格，然后我们将得到新的值“hello”
right over here and let us try to evaluate this cell and here we get the new value back as hello

563
01:04:09,740 --> 01:04:16,440
总结一下，对于字符串，我们使用尖括号，但由于这是一个列表
otalium just as a reminder for strings we were using the angle brackets but since this is a list

564
01:04:16,440 --> 01:04:22,620
这就是为什么我们使用双加号符号，接下来我们还可以使用内置函数来检查
that's why we are using the double plus symbol next we can also use an inbuilt function to check

565
01:04:22,620 --> 01:04:28,460
如果给定的字符确实是一个字符列表，让我再次添加一个代码块
if the given characters are indeed a character list or not so again let me add a code block

566
01:04:28,460 --> 01:04:34,720
在这里，我们可以使用内置的is_list函数，让我们把我们的字符传递进去
and here we can use the inbuilt function of is list and let us pass our characters inside of

567
01:04:34,720 --> 01:04:41,340
让我们尝试评估一下，是的，我们得到的答案是true，最后一点是我们可以
this one and let us try to evaluate so yes we get the answer as true and the last point is we can

568
01:04:41,340 --> 01:04:46,960
始终要检查代码点，所以我们可以使用问号，然后我们可以使用一个字符
always check the code point so we can use a question mark and then we can use a character

569
01:04:46,960 --> 01:04:56,580
所以a的代码点值是97，如果我们检查o，它将是79，依此类推，所以这样
so the code point value of a would be 97 and if we check for o it would be 79 and so on so this

570
01:04:56,580 --> 01:05:02,980
这就是关于字符的全部内容，接下来要看的是被称为进程的下一个类型，所以让
was all about characters the next type that we are going to see is called as the process so let

571
01:05:02,980 --> 01:05:11,040
我来整理一下，这里让我们添加一个块，我们想要添加一个进程部分，让
me take everything up and here let us add a block and we want to add a section for process and let

572
01:05:11,040 --> 01:05:16,440
让我们在这里添加一个代码块，如果你参考一下我之前的视频，这是那个视频
us add a code block right over here now if you refer to my earlier videos so this was the video

573
01:05:16,440 --> 01:05:22,880
关于进程的，我解释了所有的代码都在进程内执行，所以这些
about processes in which i explained that all of the code is executed inside processes so these

574
01:05:22,880 --> 01:05:29,500
进程也是Elixir内的一个有效类型，我们可以检查当前的进程，我们的
processes are also a valid type inside elixir and we can check the current process in which our

575
01:05:29,500 --> 01:05:36,480
现在 LiveBook 正在运行，所以我们创建一个名为 mypid 的变量，其中 pit 代表进程。
live book is running so let's create a variable called as mypid so the pit stands for the process

576
01:05:36,480 --> 01:05:44,040
我们可以使用内置的 self 函数，并且让我们在这之后检查 mypid 的输出。
id and we can use the inbuilt function of self and let us check the output of mypid after this one

577
01:05:44,040 --> 01:05:47,980
让我们看看我们得到了什么样的输出，所以我们得到的输出是
and let us see what kind of output we are getting so we get the output as

578
01:05:48,580 --> 01:05:55,540
bid 现在是 144，现在如果你回到我们的终端并且在这里让我们检查我们的 ix 进程
bid is 144 now if you go back to our terminal and here let us check the process in which our ix

579
01:05:55,540 --> 01:06:00,800
正在运行，所以让我调用 self 函数，这一次我们可以看到我们有一个不同的
is running so let me call the function of self and this time we can see that we have a different

580
01:06:00,800 --> 01:06:07,960
bid 号码，我们的 ix 进程的进程 ID 是 107，但是如果我们回到我们的
LiveBook，我们可以看到
bid number the process id for our ix is 107 but if we go back to our live book we can see that

581
01:06:08,410 --> 01:06:15,240
正在运行在进程号 144 中，现在在 Elixir 中的进程和并发是一个非常
is running inside the process number 144 now processes and concurrency in elixir is a very

582
01:06:15,240 --> 01:06:21,180
庞大的话题，它需要专门的教程，但是对于这门课程，让我们继续前进
huge topic and it requires its own dedicated tutorials but for this course let us go ahead

583
01:06:21,180 --> 01:06:26,540
让我们看看下一个类型，让我们在这里添加一个新的部分，所以我想添加一个新的
and let us see the next type let us add a new section right over here so i want to add a new

584
01:06:26,540 --> 01:06:33,380
部分，这一部分是关于我们的列表的，让我把这个东西稍微提高一点，所以这个数字
section and this section is all about our list let me take this thing a little up so the number

585
01:06:33,380 --> 01:06:39,560
关于列表，你需要明白的一件事是，Elixir中的列表实际上是链接的
thing that you need to understand about list is that the list inside elixir are actually linked

586
01:06:39,560 --> 01:06:45,480
它们并不是常规的列表，所以如果你尝试进行像索引这样的操作，它是不会生效的
list and they are not your regular list so if you try to do operations like indexing it is not going

587
01:06:45,480 --> 01:06:51,780
工作的。准确来说，Elixir中的列表实际上是单向链表，所以让我们
to work and just to be precise the list inside elixir are actually singly linked list so let

588
01:06:51,780 --> 01:06:57,100
看看我们如何在Elixir中使用列表，让我们在这里创建一个新的代码块
us see how we can work with list inside elixir let us create a new code block right over here

589
01:06:57,100 --> 01:07:02,760
然后让我们创建一个列表，这是我们的列表，对于一个列表我们可以看到我们有
and let us create a list so this is our list and for a list we can see that we have the

590
01:07:02,760 --> 01:07:09,420
在开头和结尾都有方括号，让我们尝试评估这个单元格，我们得到了列表
brackets at the beginning and at the end and let us try to evaluate this cell and we get the list

591
01:07:09,420 --> 01:07:16,220
现在再让我试试并重复一下，这个列表不是你常规的数组
back now again let me try and repeat that this list is not your regular array or not your regular

592
01:07:16,220 --> 01:07:23,080
这是一个单向链表，让我们做一个小实验，尝试对它进行索引
list this is a singly linked list let's do one small experiment and let us try indexing on this

593
01:07:23,080 --> 01:07:28,600
让我们创建一个新的代码块，假设我试图查看在
list so let us create a new code block and suppose if i try to see the element at the

594
01:07:28,600 --> 01:07:35,600
索引处的元素，现在让我们看看会发生什么，正如你所看到的，我们得到了一个错误，这个错误是因为
index now let us see what happens and as you can see we get an error and we get this error because

595
01:07:35,600 --> 01:07:41,780
这个列表实际上是一个链表，而不是你的常规列表，现在我们使用链表的原因是链表是递归的，你的常规数组或列表不是递归的，它们必须在内存中连续保存，但是如何在Elixir中使用列表呢？
this list is actually a linked list and not your regular list now the reason that we have linked

596
01:07:41,780 --> 01:07:48,720
Elixir中的列表是由于链表是递归的性质，你的常规数组或列表不是递归的
list inside elixir is because linked lists are recursive in nature your regular arrays or your

597
01:07:48,720 --> 01:07:54,380
常规列表不是递归的，它们必须在内存中连续保存，但是如何
regular list they are not recursive and they have to be saved continuous in your memory but then how

598
01:07:54,380 --> 01:08:00,440
在Elixir中使用列表有很多机制，首先显而易见的是使用
work with list inside elixir now there are a lot of mechanisms first and the obvious one is by using

599
01:08:00,440 --> 01:08:06,860
递归函数，或者我们还可以使用很多内置模块，让我给你展示一个模块
recursive functions or we can also use a lot of inbuilt modules so let me show you one module

600
01:08:06,860 --> 01:08:12,880
让我在这里添加一个代码块，让我们把一切都放在上面，现在我们可以使用这个模块
let me add a code block right over here and let us take everything up now we can use the module

601
01:08:12,880 --> 01:08:20,120
enum模块，我们可以说enum模块可以使用内置函数add，让我们传递我们的列表
of enum and we can say that enum and we can use the inbuilt function add and let's pass our list

602
01:08:20,120 --> 01:08:25,200
让我们将索引称为零，看看我们得到了什么样的输出
and let us call the index as zero and let us see what kind of output we are getting

603
01:08:25,200 --> 01:08:31,340
在这里我们可以看到我们得到的输出是a，所以我们在做什么是enum实际上是一个
and here we can see that we get the output as a so what we are doing is enum is actually an

604
01:08:31,340 --> 01:08:38,860
Elixir内置的模块，add是一个在enum模块内定义的函数，在这里
inbuilt module inside elixir and add is a function which is defined inside the enum module and here

605
01:08:38,860 --> 01:08:45,560
我们只是在为函数传递参数，让我们回到我们的ix并让我
we are simply passing the arguments for the function let us go back to our ix and let me

606
01:08:45,560 --> 01:08:51,840
清理一切，让我从顶部腾出一些空间，如果我写枚举点，如果我
clear up everything let me make some space from the top and here if i write enum dot and if i

607
01:08:51,840 --> 01:08:58,220
按下tab键，我们可以看到我们有很多内置函数用于枚举模块和
press tab here we can see that we have a lot of inbuilt functions for the enum module and the

608
01:08:58,220 --> 01:09:04,820
我们使用的函数就在这里，现在这个斜杠两个实际上表示了arity，现在arity
function that we use is right over here add now this slash two actually means the arity now arity

609
01:09:04,820 --> 01:09:10,760
什么都没有，它只是你的函数可以接受的参数的数量，在elixir中我们实际上可以
is nothing it's just the number of arguments that your function can accept in elixir we can actually

610
01:09:10,760 --> 01:09:16,960
通过使用不同的参数来定义我们的函数，所以例如你可以看到在这里我们有
our functions by using different parameters so for example you can see right over here we have

611
01:09:16,960 --> 01:09:22,580
一个称为any的函数，对于这个函数我们有两种类型，第一种类型就在这里
a function called as any and for this function we have two types the first type is right over here

612
01:09:22,580 --> 01:09:29,100
所以这个函数只接受一个参数，这就是为什么arity是一，而在这里我们有相同的
so this function takes only one argument that's why the arity is one and here we have the same

613
01:09:29,100 --> 01:09:36,200
函数any，但这次它接受两个参数，所以arity显示为两个，现在让我
function any but this time it takes two arguments so that's why the arity is shown as two now let me

614
01:09:36,200 --> 01:09:41,660
清理所有这些东西，现在让我给你展示elixir中的另一个辅助函数
clear up all of these things now let me show you one more helper function inside elixir

615
01:09:41,660 --> 01:09:47,280
而函数的名称是h，因此h代表你的助手，如果你愿意，你可以使用
and the name of the function is h so h stands for your helper again if you want you can use

616
01:09:47,280 --> 01:09:53,760
括号可以省略，我们需要指定哪个模块或哪个函数
the parentheses or you can leave them out and here we need to specify which module or which function

617
01:09:53,760 --> 01:09:59,580
我们想要帮助的是什么，帮助函数的作用就是简单地打印出文档
do we want help for so what does helper function does is it simply prints out the documentation

618
01:09:59,580 --> 01:10:05,380
对于那个模块或函数，所以我们需要指定我们要查看的是
for that module or for that function so here we need to specify that we want to see the

619
01:10:05,380 --> 01:10:10,880
枚举模块的文档，我们想要看到来自枚举的文档
documentation for the module of enum and from enum we want to see the documentation of the

620
01:10:10,880 --> 01:10:16,300
add函数的文档，这里我们得到了文档，你可以看到的第一行
function of add and here we get the documentation back the first line that you can see right over

621
01:10:16,300 --> 01:10:21,760
这里是关于你的函数定义的一切，你可以看到第一个参数是
here this is all about your function definition and you can see that the first parameter is

622
01:10:21,760 --> 01:10:28,620
实际上是一个可枚举的，第二个参数是索引，这个函数还接受一个可选的
actually a innumerable the second one is the index and this function also accepts an optional

623
01:10:28,620 --> 01:10:35,220
参数，名称为default，默认值为nil，这两个表示这个default参数是可选的
argument by the name of default and the default value for this parameter is nil these two back

624
01:10:35,220 --> 01:10:42,060
表示这个default参数是一个可选参数，在这种情况下，如果这个参数
symbolize that this argument of default is an optional argument and in case if this argument

625
01:10:42,060 --> 01:10:48,960
如果未指定，则默认值为nil。接下来，我们可以看到我们有几个示例。
is not specified then the default value would be simply nil next we can see that we have a couple

626
01:10:48,960 --> 01:10:54,960
这里有几个示例，你可以看到这个帮助函数非常有用，我提供
of examples right over here so you can see that the helper function is very useful and i offer

627
01:10:54,960 --> 01:11:04,920
使用这个函数来阅读我的终端内的文档，现在让我们回到我们的
use this function for reading the documentation inside my terminal now let us go back to our

628
01:11:05,320 --> 01:11:12,500
和我们的列表一起，让我创建一个新的代码块，现在如果你参考我们的列表，我们的列表有
and with our list so let me create a new code block now if you refer our list so our list has

629
01:11:12,500 --> 01:11:17,620
三个不同的元素，我们可以使用模式匹配来提取所有这些元素
three different elements and we can use pattern matching to extract all of these elements

630
01:11:17,620 --> 01:11:23,740
让我向你展示我们如何做到这一点，所以让我创建一些不同的变量
so let me show you how we can do that so here let me create a couple of different variables the

631
01:11:23,740 --> 01:11:29,960
第一个应该被称为第一第二第三，你可以把这些参数称为任何你想要的东西
first one should be called as first second third you can call this parameters anything that you

632
01:11:29,960 --> 01:11:35,720
在右边，我只想在列表上进行模式匹配，所以将会发生的是
and on the right i simply want to pattern match on the list so what's going to happen is the

633
01:11:35,720 --> 01:11:41,760
同样的事情，左边应该等于右边，所以首先的事情是
same old thing the left hand side should be equal to the right hand side so the first thing is since

634
01:11:41,760 --> 01:11:48,420
这是一个列表，在左边我们确实有一个列表，我们只是试图在上面进行模式匹配
this is a list on the left hand side we do have a list and we are simply trying to pattern match on

635
01:11:48,420 --> 01:11:55,440
不同的元素，所以a会绑定到我们的第一个变量，你的b会绑定到第二个变量
the different elements so this a would be bound to our variable of first for the second your b

636
01:11:55,440 --> 01:12:02,640
c会绑定到第三个变量，让我们检查一下第二个变量里面的数据，让我调用一下
be bound and c would be bound to third let us check out the data inside second so let me call

637
01:12:02,640 --> 01:12:09,320
这里是第二个变量，让我把它提取出来，同时让我们尝试评估这个单元格，我们得到的结果是
second right over here and let me take it up and also let us try to evaluate this cell and we get

638
01:12:09,320 --> 01:12:15,840
将值返回为b，现在如果你不想要所有的变量，只想要
the value back as b now what happens if you don't want all of the variables and you simply want to

639
01:12:15,840 --> 01:12:22,540
忽略其中一些，那么我们可以简单地使用下划线来忽略这些值，假设
ignore a couple of them at that time we can simply use an underscore to ignore the values so suppose

640
01:12:22,540 --> 01:12:28,960
我不想要第一个和第二个变量的值，那么我们可以这样做，这样我们就可以创建一个列表，因为
i don't want the values of first and second then we can do like this so we can create a list since

641
01:12:28,960 --> 01:12:34,780
我想忽略第一个值，我可以使用下划线，我也想忽略第二个值
i want to ignore the first value i can use an underscore i also want to ignore the second value

642
01:12:34,780 --> 01:12:40,760
所以让我再加一个下划线，接下来我想收集第三个值，所以让我创建一个
so let me put one more underscore the next i want to collect the third value so let me create a

643
01:12:40,760 --> 01:12:49,520
变量称为third，让我们将一个列表赋值过来，所以我们的列表是a、b和c，现在让我们
variable called as third and let us assign a list right over here so our list is a b and c now let

644
01:12:49,520 --> 01:12:56,440
检查一下third里面的值，让我们尝试一下评估，我们得到的值是c，那么现在是什么情况呢？
us check the value inside third and let us try to evaluate and we get the value as c back so what

645
01:12:56,440 --> 01:13:02,760
发生的是，因为我们有一个下划线，所以变量a的值被简单地忽略了，同样的事情
happened is since we have an underscore that's why the value of a is simply ignored the same thing

646
01:13:02,760 --> 01:13:10,360
b也是一样，最后c的值绑定到了我们的变量third上，让我来
happens with b as well and finally the value of c gets bound to our variable of third next let me

647
01:13:10,360 --> 01:13:16,140
给你展示一些方便处理列表的函数，首先是
show you a couple of convenience function for working with our list so the first function is

648
01:13:16,140 --> 01:13:22,220
被称为head，让我来给你展示一下我的意思，head函数只是取出第一个值
called as head so let me show you what i mean so the head function simply takes the first value

649
01:13:22,220 --> 01:13:29,120
并将其返回，所以如果我们调用head的内置函数，并将我们的列表传递给它
and returns it back so if we call the inbuilt function of head and let us pass our list to it

650
01:13:29,120 --> 01:13:35,380
让我们来尝试一下，正如你所见，我们得到了a的值，类似于head函数
and let us try to evaluate and as you can see we get the value of a back now similar to head we

651
01:13:35,380 --> 01:13:41,480
还有另一个被称为tail的函数，让我创建一个新的代码块和这个函数
also have another function which is called as tail so let me create a new code blog and the function

652
01:13:41,480 --> 01:13:47,300
被称为t和l，现在tail函数要做的就是简单地忽略掉
is called as t and l now what a tail function is going to do is it is simply going to ignore the

653
01:13:47,300 --> 01:13:52,980
head值，然后将剩下的所有值返回，让我传递变量
head value and it will return back all of the remaining values so let me pass the variable of

654
01:13:53,420 --> 01:14:00,080
给这个函数，然后让我们来尝试一下，我们得到了b和c的值
list to this one and let us try to evaluate the cell and we get back the values of b and c

655
01:14:00,080 --> 01:14:05,160
还有一种快捷方法可以做到这一点，让我向你展示一下我们如何做到这一点
there is also a shortcut method for doing this so let me show you how we can do that

656
01:14:05,720 --> 01:14:12,720
这次我们可以简单地在列表上进行模式匹配，所以让我们创建一个列表，我想要模式
this time we can simply pattern match on our list so here let us create a list and i want to pattern

657
01:14:12,720 --> 01:14:20,240
在一个名为head的新变量内匹配第一个值，然后让我使用cons
match the first value inside a new variable called as head h for head and then let me use a cons

658
01:14:20,240 --> 01:14:25,940
然后我可以说我想把所有剩下的值收集到一个新的变量中
operator and then i can say that i want to collect all of the remaining values in a new variable

659
01:14:25,940 --> 01:14:32,600
称为tail，并让我将list的值分配给它，接下来让我们检查一下里面的值
called as tail and let me assign the value of list to this one next let us check the value inside our

660
01:14:32,600 --> 01:14:39,740
head，让我们尝试评估这个单元格，正如预期的那样，我们得到了一个返回值，现在这个管道运算符是
head and let us try to evaluate the cell and as expected we get a back now this pipe operator is

661
01:14:39,740 --> 01:14:45,960
也被称为cons运算符，用于操作我们的链表，接下来让我们还检查一下里面的值
also known as cons operator for working with our linked list next let us also check the value inside

662
01:14:45,960 --> 01:14:52,000
t，所以让我创建一个新的代码块，让我调用key变量，正如你所看到的，我们只是简单地
t so let me create a new code blog and let me call the variable of key and as you can see we simply

663
01:14:52,000 --> 01:14:59,440
获得我们列表中剩下的值，下一个数据类型是元组，我们已经
get back the remaining values inside our list the next data type is the tuple and we have already

664
01:14:59,440 --> 01:15:05,680
看到了一些元组的例子，但是让我再次向你展示一下，元组是通过创建来的
seen a couple of examples of tuple but let me show you once again so the tuple is created by

665
01:15:05,680 --> 01:15:12,880
使用花括号，我们可以创建一个包含两个元素的元组，可以这样说
using the curly brackets so you can say we want to create a two element tuple and we can say that

666
01:15:12,880 --> 01:15:20,440
值应该是一和二，所以这些花括号用于创建一个元组，现在元组
the values should be one and two so these curly brackets are used for creating an tuple now tuples

667
01:15:20,440 --> 01:15:27,660
与数组非常相似，元组中的所有数据都连续保存在内部
are very similar to your arrays and all of the data inside the tuple is saved continuously inside

668
01:15:27,660 --> 01:15:34,160
内存中经常出现两个或三个元素的元组，但是如果你想要
the memory and it's very common to have two or three element kind of a tuple but if you want to

669
01:15:34,160 --> 01:15:39,940
保存大量元素，建议使用列表，现在这里也是
save a large number of elements then it is recommended to go with the list now here also

670
01:15:39,940 --> 01:15:47,080
我们可以进行简单的模式匹配，所以在左边让我们创建一个新的元组，我们可以说a和b
we can do a simple pattern match so on the left let us create one more tuple we can say a and b

671
01:15:47,080 --> 01:15:54,380
让我们检查a的值并尝试进行评估，我们得到的值是一
and let us check the value of a and let us try to evaluate and we get the value back as one this

672
01:15:54,380 --> 01:15:59,660
这次让我们创建一个三个元素的元组，所以将来无论你何时学习
time let us create a three element tuple so in the future whenever you are learning about

673
01:15:59,660 --> 01:16:05,000
使用phoenix进行web开发时，你会发现拥有三个元素非常常见
web development using phoenix that time you will see that it's very common to have three elements

674
01:16:05,000 --> 01:16:11,100
或者最多四个元素的元组，一个非常常见的模式可能是这样的，首先
or maximum four element tuple and a very common pattern would be something like this so the first

675
01:16:11,100 --> 01:16:17,720
元素将被称为消息的元组，第二个元素将是实际的消息
element would be a tuple called as message the second element would be the actual message that

676
01:16:17,720 --> 01:16:24,260
您想要发送回去的，第三个元素通常是服务器的状态，让我们
you want to send back and the third element would normally be the state of your server and let us

677
01:16:24,260 --> 01:16:31,620
右边的元组，因此第一个元素应该是回复消息，可能是一个字符串，找到了octalium
tuple on the right so first element should be reply message could be a string octalium found

678
01:16:31,620 --> 01:16:38,060
而且对于状态，我们可以传递一个octalium所有朋友的简单列表，所以我们可以说
and for the state we can pass a simple list of all of the friends of octalium so we can say

679
01:16:38,060 --> 01:16:45,180
octalium、louis和chico，接下来让我们尝试打印出消息，让我们尝试评估
octalium louis and chico next let us try and print out the message and let us try to evaluate

680
01:16:45,820 --> 01:16:53,040
我们还要检查服务器的状态，所以我们可以说状态，并让我们尝试重新评估
let's also check the state of our server so we can say state and let us try to reevaluate

681
01:16:53,040 --> 01:16:59,560
我们得到了正确的列表，所以正如你所看到的，元组是一种非常方便的数据结构
and we get the right list back so as you can see tuples are a very convenient data structure

682
01:16:59,560 --> 01:17:06,020
在Elixir中，但通常不要在元组中使用超过三个或四个元素，下一个
inside elixir but normally don't use more than three or four element inside a tuple the next

683
01:17:06,020 --> 01:17:13,020
我们将要看到的数据类型也被称为关键字列表，所以让我向您展示一下
data type that we are going to see is also called as the keyword list so let me show you how a

684
01:17:13,020 --> 01:17:20,360
关键字列表在Elixir中的样子，所以我们可以创建一个名为data的变量，现在关键字列表是
keyword list looks inside elixir so we can create a variable called as data now keyword list is

685
01:17:20,360 --> 01:17:29,360
一个列表，但在列表中我们有键和值对，所以我们可以说a是一个，所以
a list but inside the list we have the key and the value pairs so we can say that a is one so

686
01:17:29,360 --> 01:17:37,180
a是你的键，1是值，你可以说b和2，让我们尝试评估一下，我们得到
a is your key one is the value and you can say b and two and let us try to evaluate and we get

687
01:17:37,180 --> 01:17:44,800
回到我们的关键词列表，现在关键词列表中发生的是你的键通常是一个
back our keyword list now what happens inside the keyword list is your key would normally be an

688
01:17:44,800 --> 01:17:51,900
但是如果你记得我们首先将项目写成冒号，然后是项目的名称，而且
but if you remember we write the item as colon first and then the name of the item and in

689
01:17:51,900 --> 01:17:58,160
事实上，这个键值对实际上被保存为一个元组，所以让我向你展示它是如何保存的
fact this key value pair is actually saved as a tuple so let me show you how it is saved as a

690
01:17:58,160 --> 01:18:06,380
所以在这里让我创建一个列表，在第一个元素内，也就是键，总是保存为
tuple so here let me create a list and inside the first element that is the key is always saved as

691
01:18:06,380 --> 01:18:13,960
一个原子，所以我可以说a，第二个元素是值，所以它将是1，让我们尝试一下
an atom so i can say a and the second element is the value so it would be one and let us try

692
01:18:13,960 --> 01:18:21,520
在一个非常简单的关键词列表上进行模式匹配，所以我们可以说a和1，正如你在这里看到的
pattern match on a very simple keyword list so we can say a and one so as you can see over here

693
01:18:21,520 --> 01:18:27,420
a和冒号，这只是一个方便的功能，但在关键词列表内保存时它是
a and colon this is just a convenience feature but while saving inside the keyword list it is

694
01:18:27,420 --> 01:18:34,500
实际上被保存为原子，这个键值对被转换为一个元组，我们可以看到
actually saved as an atom and this key value pair is converted into a tuple which we can see right

695
01:18:34,500 --> 01:18:40,800
现在在这里让我们尝试评估，如果我们得到相同的答案，那就意味着我们有一个匹配。
over here now let us try to evaluate and we get the same answer back that means we have a match

696
01:18:40,800 --> 01:18:46,420
在右手边和左手边之间，用于访问内部不同的值。
between the right hand side and the left hand side for accessing the different values inside

697
01:18:46,420 --> 01:18:54,020
我们可以使用内置模块来访问关键字列表，所以让我们回到终端，让我写一下。
the keyword list we can use the inbuilt module so let us go back to our terminal and let me write

698
01:18:54,020 --> 01:19:01,020
关键字点，然后让我按下制表符，正如你所见，我们有很多方便的功能。
keyword dot and let me press a tab and as you can see we have a lot of convenience features for

699
01:19:01,020 --> 01:19:06,600
让我们回到实时书籍，让我向你展示如何提取值。
working with our keywords let's go back to the live book and let me show you how to fetch values

700
01:19:06,600 --> 01:19:13,320
根据给定的键，例如，我可以说我想要访问我的关键字数据列表。
from a given key so for example i can say that i want to access my keyword list of data

701
01:19:13,320 --> 01:19:21,140
然后我想访问键为a的键，并且让我们尝试评估，我们将得到数据作为一个。
and then i want to access the key of a and let us try to evaluate and we get back the data as one

702
01:19:21,140 --> 01:19:27,800
好了，就这些，我们将在下一个中学到更多关于地图和结构的内容。
well that's it for this one and we'll learn more about maps and struct right in the next one the

703
01:19:27,800 --> 01:19:34,500
我们将要学习的下一个数据结构被称为地图，所以让我创建一个名为的变量
next data structure that we are going to study is called as a map so let me create a variable called

704
01:19:34,500 --> 01:19:41,520
作为我的地图，现在在上一个视频中，我们看到了如何创建一个元组，对于创建一个元组，我们通常
as my map now in the last video we saw how to create a tuple and for creating a tuple we normally

705
01:19:41,520 --> 01:19:49,260
使用花括号创建地图时，只需添加一个人符号，因此地图更像是
use the curly brackets and for creating a map we simply add a person symbol so maps are more like

706
01:19:49,260 --> 01:19:55,780
在Python中，您的字典也是一种键值对的数据结构，这些地图也是您的键和值
your dictionaries in your python these maps are also your key and value kind of a data structure

707
01:19:55,780 --> 01:20:03,360
但与元组或地图内部的关键字列表相比，地图提供了许多功能
but maps offer a lot of features as compared to your tuple or your keyword list inside maps

708
01:20:03,360 --> 01:20:10,180
我们可以为键使用不同的数据类型，但现在让我们看看如何使用原子作为键
we can use different data types for our keys but right now let us see how we can use an atom for

709
01:20:10,180 --> 01:20:19,940
我们的键，因此我们只需说一个冒号和一个，然后再添加一个元素b，再添加一个
our key so we can simply say a colon and one then let us add one more element b and let us add one

710
01:20:19,940 --> 01:20:27,900
更多的c和三，这就是您如何创建一个地图，当您使用元组时会发生什么
more c and three so this is how you can create a map and what happens is when you use a tuple for

711
01:20:27,900 --> 01:20:34,140
在那时，我们可以使用点符号来表示，我很快会向您展示点符号是什么意思
your key at that time we can use the dot notation i will show you shortly what i mean by the dot

712
01:20:34,140 --> 01:20:41,420
符号，但现在让我们看看地图的样子，然后我们会得到地图，接下来我们可以
notation but right now let us see how the map looks like and we get the map back next we can

713
01:20:41,420 --> 01:20:47,920
使用模式匹配来提取值，所以让我在这里创建一个地图，在地图的内部我们可以
use our pattern matching to extract values so here let me create a map and inside the map we can

714
01:20:47,920 --> 01:20:55,160
在键为a的地方进行模式匹配，然后将值收集到一个名为first的变量中
pattern match on the key of a and let us collect the value inside a variable called as first

715
01:20:55,160 --> 01:21:01,060
接下来，我们可以和b进行模式匹配，让我们收集第二个变量的值，
next we can pattern match with b and let us collect the value inside second and for the

716
01:21:01,060 --> 01:21:08,020
最后一个，我们可以使用第三个变量，并让我们与my map变量进行模式匹配
last one we can use the variable of third and let us pattern match with the variable of my map

717
01:21:08,920 --> 01:21:15,320
让我们看一下变量first的值，让我们尝试进行评估，我们得到的结果
and let us see the value inside the variable of first and let us try to evaluate and we get

718
01:21:15,320 --> 01:21:21,080
正确答案很明显，map是一种非常方便的数据结构，假设您想要
the right answer back well maps are a very convenient data structure suppose if you want

719
01:21:21,080 --> 01:21:27,400
只提取第二个值，您不必使用整个map，而是我们可以做一些事情
to extract only the second value you don't have to use the entire map instead we can do something

720
01:21:27,400 --> 01:21:34,200
就像这样，让我展示给你看，让我们创建一个map，假设我们只想要模式匹配
like this so let me just show you let us create a map and let us say that we simply want to pattern

721
01:21:34,200 --> 01:21:42,820
在b的键上进行匹配，让我们收集第二个变量的值，让我们与我们的变量进行模式匹配
match on the key of b and let us collect the value inside second and let us pattern match with our

722
01:21:42,820 --> 01:21:49,800
我们的map中的map，让我们看一下第二个变量的值，正如您所看到的，我们得到了正确的答案
map of my map and let us see the value inside second and as you can see we get the right answer

723
01:21:50,360 --> 01:21:56,740
因此，创建整个map进行模式匹配并不是必须的，相反，我们可以创建一个更短的map
so it's not mandatory to create the entire map to pattern match instead we can create a shorter map

724
01:21:56,740 --> 01:22:03,480
只需所需的元素，所以在这里，我们只是在b的键上进行模式匹配，
with just the required elements so here we are simply pattern matching on the key of b and we

725
01:22:03,480 --> 01:22:08,800
正在收集第二个变量内的值，下一步是因为我们正在使用
are collecting the value inside the variable of second the next thing is since we are using

726
01:22:08,800 --> 01:22:15,540
我们可以使用点标记法来访问值，因此让我们创建一个代码块
items for our keys we can use our dot notation to access the values so let us create a code block

727
01:22:15,540 --> 01:22:22,260
我们可以说我的 map 点 a，让我们尝试评估一下，我们得到了答案，但是
and we can say my map dot a and let us try to evaluate and we get the answer back but

728
01:22:22,260 --> 01:22:28,680
如果我们有不同的数据类型，例如，如果我们的键值是字符串，那么你就不能
if we have a different data type for example if we have a string for the key values then you can't

729
01:22:28,680 --> 01:22:36,820
使用点标记法，让我们再创建一个 map ，让我称其为 map two ，让我们创建
use the dot notation let us create one more map and let me call it as map two and let us create

730
01:22:36,820 --> 01:22:43,260
我们的 map 就在这里，如果您计划使用字符串作为键，则我们需要编写它们
our map right over here now if you plan to use a string as your key then we need to write them

731
01:22:43,260 --> 01:22:49,580
代码，因为它们是字符串，而且因为我们使用的是不是原子的数据类型
codes because they are strings and since we are using a data type which is not an atom for the

732
01:22:49,580 --> 01:22:56,100
键，我们需要使用箭头符号，在这里我们可以将值分配为 1 ，接下来让我们创建
key we need to use the arrow notation and here we can assign the value as one next let us create

733
01:22:56,100 --> 01:23:03,080
再创建一个键为 b ，再次记住，由于键不是原子，我们使用箭头括号
one more key for b again remember since the key is not an atom we are using the arrow brackets

734
01:23:03,080 --> 01:23:09,420
在这里，我们可以将值分配为 2 ，然后创建最后一个 c ，让我们分配值
here we can assign the value of two and we can create the last one c and let us assign the value

735
01:23:09,420 --> 01:23:17,260
三个的，让我们评估单元格，然后我们得到我们的地图。接下来，我们可以使用相同的模式。
of three and let us evaluate the cell and we get our map back next we can use the same pattern

736
01:23:17,260 --> 01:23:23,820
匹配技巧，例如，如果我们想提取c的值，那么让我们创建一个地图。
matching techniques so for example if we want to extract the value of c then let us create a map

737
01:23:23,820 --> 01:23:30,300
由于这次的键是字符串，我们就在这里进行模式匹配，假设
and since this time the keys are strings let us pattern match right over here and let's say that

738
01:23:30,300 --> 01:23:36,020
我们想收集变量c内的值，让我们与我们的模式匹配
we want to collect the value inside a variable called as c and let us pattern match with our

739
01:23:36,020 --> 01:23:42,740
第二个，让我们看看变量c内的值，我们得到正确的值返回
number two and let us see the value inside the variable of c and we get the right value back

740
01:23:42,740 --> 01:23:48,820
Elixir提供了很多内置功能来处理我们的地图，所以如果我们回到我们的
elixir provides a lot of inbuilt features for working with our maps so if we go back to our

741
01:23:48,820 --> 01:23:55,840
终端，如果我输入map并键入tab，我们可以看到我们有很多不同的功能
terminal and if i enter map and dot the tab we can see that we have a lot of different features

742
01:23:55,840 --> 01:24:06,000
例如，如果您想获取某些内容，或者如果您想创建一个新地图，或者如果您想要
for example if you want to fetch something or if you want to create a new map or if you want to

743
01:24:06,000 --> 01:24:11,740
与地图一起做很多事情，但现在让我向您展示一种非常简单的方法
do a lot of things with the map but for now let me show you a very easy method of

744
01:24:11,740 --> 01:24:18,260
更新我们的地图，让我们创建一个新的代码块，假设我们想要更新该值
updating our map so let us create a new code block and suppose we want to update the value

745
01:24:18,260 --> 01:24:25,120
将 c 的值从三更新为四，然后我们可以说我们想要更新我们的映射的值
of c from three to four then we can say that we want to update the value of our map

746
01:24:25,120 --> 01:24:32,000
变量名是 map2，然后我们可以使用管道运算符，然后我们可以说
and the variable name is map2 and then we can use the pipe operator and then we can say that

747
01:24:32,000 --> 01:24:40,080
我们想要将 c 的值从三更新为四，让我们将这个值绑定回来
we want to update the value of c from three to four and let us bind the value of this back

748
01:24:40,080 --> 01:24:46,320
到我们的变量 map2 上，然后让我们尝试评估并看看我们得到了什么样的输出
to our variable of map of two and let us try to evaluate and see what kind of output we are

749
01:24:46,320 --> 01:24:52,700
得到的结果，如你所见，我们已经更新了 c 的值，现在我们正在使用这个箭头符号
getting and as you can see we have updated the value of c now we are using this arrow notation

750
01:24:52,700 --> 01:25:00,060
因为我们的键值是字符串，但是如果我们有原子的话，我们可以简单地使用
because we have strings for our key values but in case if we have atoms then we can simply use

751
01:25:00,060 --> 01:25:07,420
冒号，所以让我给你展示一下，我们有另一个名为 my map 的映射，然后我们可以说
colons so let me show you so we have another map by the name of my map and then we can say that

752
01:25:07,420 --> 01:25:14,380
我们想要更新 my map，这次我们想要更新 c 的值，由于 c 只是一个
we want to update my map and this time we want to update the value of c and since c is just

753
01:25:14,380 --> 01:25:20,660
原子，我们可以使用常规的符号，然后我们可以说我们想要将值更新为四
an atom we can use the regular notation and we can say that we want to update the value to four

754
01:25:20,660 --> 01:25:27,040
让我们尝试评估一下，我们得到了更新后的值，好了，这就是这个视频的内容
let us try to evaluate and we get the updated value back well that's it for this video this

755
01:25:27,040 --> 01:25:32,700
这只是一个关于地图的简短介绍，随着教程的进展，我们将学习更多关于如何使用地图的内容。
was a very short introduction to maps and we will learn much more how to work with maps as

756
01:25:32,700 --> 01:25:39,280
在教程中的进展中，下一个视频将全面介绍Elixir中的结构体，这是下一个数据类型。
we progress in the tutorials the next video is all about structs in elixir the next data type

757
01:25:39,280 --> 01:25:45,380
结构体是其中一种数据类型，如果你有C或Go等编译型编程语言的经验，你一定很熟悉。
is the struct and if you come from a compiled programming language such as c or go you must

758
01:25:45,380 --> 01:25:57,020
你可能已经使用过结构体，现在让我们来看看如何在Elixir中创建一个结构体。
have worked with structs and now let us see how we can create a structure inside elixir now for

759
01:25:57,020 --> 01:26:03,980
以模块的名称为例，假设我们想为用户定义一个结构体，我们可以创建一个
take the name of the module suppose we want to define a structure for the user then we can create

760
01:26:03,980 --> 01:26:11,800
模块，我们可以说创建一个名为"用户"的模块，然后在模块内部我们可以使用另一个宏
a module so we can say create module user and then inside the module we can use another macro

761
01:26:11,800 --> 01:26:18,780
这个宏的名称叫做"def struct"，现在我们可以看到这里面的所有内容
and the name of the macro is called as def struct now all of these things that we can see over here

762
01:26:18,780 --> 01:26:26,280
def模块，def结构这些都是宏，它们意味着它们从给定的代码中创建代码
def module def structure these are all macros that means they create a code from a given code

763
01:26:26,280 --> 01:26:31,980
但是现在我们不需要更多地了解宏，让我们看看如何定义一个结构体
but right now we don't have to learn more about macros let us see how we can define a struct so

764
01:26:31,980 --> 01:26:38,460
我们所定义的是我们创建了一个名为"用户"的模块，然后我们使用了另一个宏
what we have defined is we have created a module called as user and then we are using another macro

765
01:26:38,460 --> 01:26:45,460
现在被称为def struct，现在我们需要为我们的结构体指定不同的字段，这些字段
called as def struct now here we need to specify the different fields for our struct and these

766
01:26:45,460 --> 01:26:51,660
字段必须以键值对的格式指定，现在我们可以再次使用
fields have to be specified in the format of your key and value pairs now here again we can use the

767
01:26:51,660 --> 01:26:57,680
如果你想的话，你可以使用符号，如果不想使用，可以省略，并让我们看看如何指定
notation if you want or if you don't want you can leave it out and here let us see how we can specify

768
01:26:57,680 --> 01:27:05,120
字段，因此我们可以说第一个字段应该是用户名，第二个字段应该是
the fields so we can say that the first field should be username the second one should be an

769
01:27:05,120 --> 01:27:12,160
电子邮件，这是一种指定字段的方式，但如果您想要在初始化时使用一些值
email now this is one way of specifying your fields but if you want to initialize with some values at

770
01:27:12,160 --> 01:27:18,060
那么我们还可以传递键值对，例如，如果您想要说的是，在
that time we can also pass the key and value pairs so for example if you want to say that while

771
01:27:18,060 --> 01:27:25,960
初始化时，我们希望年龄为空，对于电子邮件，我们可以说我们想要一个空的
initializing we want the age to be nil and for the email we can say that we want to have a blank

772
01:27:25,960 --> 01:27:32,500
字符串，对于用户名，我们也可以说在初始化时我们只想要一个空的
string and for the username also we can say that while initializing we simply want to have a blank

773
01:27:32,500 --> 01:27:38,940
字符串，所以我们所做的就是将一个项目列表转换为一个键值列表
string so what we have done is we have simply converted from a list of items to a list of key

774
01:27:38,940 --> 01:27:46,540
和所有这些参数都将成为用户结构体的字段，接下来让我们
value pairs and all of these parameters are going to become the fields for the user struct next let

775
01:27:46,540 --> 01:27:53,020
让我们看看如何创建和初始化一个结构体，所以让我添加一个代码块，现在我们来处理结构体
us see how we can create and initialize a struct so let me add a code block now working with struct

776
01:27:53,020 --> 01:27:58,760
这与使用地图非常相似，为了创建地图，我们过去常常使用百分号符号
is very similar to working with a map for creating a map we used to use our percent symbol

777
01:27:58,760 --> 01:28:05,180
对于结构体，使用括号非常相似，只是我们必须使用结构体的名称
and the brackets and for the struct is very similar just that we have to use the name of

778
01:28:05,180 --> 01:28:11,200
所以这就是我们如何在内部定义一个结构体，让我们指定不同的字段，我们可以这样说
the struct so this is how we define a struct inside let us specify the different fields so we can say

779
01:28:11,200 --> 01:28:19,480
用户名的值将是octalium，假设我的年龄是14岁，我的电子邮件可以是
the value for the username would be octalium suppose my age is 14 years and my email can be

780
01:28:20,020 --> 01:28:26,200
octobot at the rate sample.com，让我们试着评估一下，我们所做的就是
octobot at the rate sample.com and let us try and evaluate so what we have done is we have

781
01:28:26,200 --> 01:28:32,420
基本上创建了一个结构体，这就是我们如何初始化一个结构体，结构体的行为非常相似
essentially created a struct and this is how we can initialize a struct structs behave very similar

782
01:28:32,420 --> 01:28:38,820
对于我们的地图，我们可以在我们的结构体上使用相同的模式匹配技术，所以
to our maps and we can use the same pattern matching techniques on our struct as well so

783
01:28:38,820 --> 01:28:47,500
例如，让我们将这个分配给一个名为user one的变量，并进行下一步评估
example let us assign this one to a variable called as user one and let us evaluate next let

784
01:28:47,500 --> 01:28:53,900
我们再创建一个代码块，假设我们想要提取用户名，那么我们只需要创建
us create one more code block and suppose we want to extract the username then we can simply create

785
01:28:53,900 --> 01:29:01,000
你的普通地图，在这里我们可以说字段名称是用户名，让我们创建
your regular map and here we can say that the field name would be username and let us create

786
01:29:01,000 --> 01:29:08,180
一个变量名，让我们对变量user one进行模式匹配，接下来让我们看看这个值
a variable name and let us pattern match on the variable of user one next let us see the value

787
01:29:08,180 --> 01:29:14,460
在用户名内部，让我们尝试评估这个块，正如你所看到的，我们得到了正确的结果
inside username and let us try to evaluate the block and as you can see we are getting the right

788
01:29:14,460 --> 01:29:21,180
回答是这样的，我们所做的是user one这是一个结构体，但结构体的行为非常类似于地图
answer back so what we did was this user one this is a struct but structs behave very similar to maps

789
01:29:21,180 --> 01:29:27,240
这就是为什么我们可以使用地图符号进行模式匹配，我们可以使用相同的技术
and that's why we can use our map notation for pattern matching we can use the same technique

790
01:29:27,240 --> 01:29:33,780
也可以用来更新结构体内部的值，例如，如果您想更新年龄，则可以
for updating values inside a struct as well so for example if you want to update the age so you can

791
01:29:34,220 --> 01:29:43,480
使用我的user one的地图，并插入这个，我想将年龄更新为21岁，让我们重新绑定
the map of my user one and insert this i want to update the age to suppose 21 and let us rebind

792
01:29:43,480 --> 01:29:51,440
将此值返回给user one，让我们尝试并评估，正如我们所看到的，我们得到了更新后的值
the value this back to user one and let us try and evaluate and as we can see we get the updated

793
01:29:51,440 --> 01:29:57,780
年龄回来了，好了，到此为止，我们所做的事情到目前为止只是一个非常简短的介绍
age back well that's it for this one so what we have done is till now we just had a very short

794
01:29:57,780 --> 01:30:03,720
对Elixir中不同数据类型的简介，但如果你不自信，不要担心
introduction to the different data types in elixir but if you're not feeling confident don't worry

795
01:30:03,720 --> 01:30:09,360
随着我们的进步和更多的实践，你会开始感到更有信心。
as we progress and as we have more practice you will start feeling much more confident

796
01:30:09,360 --> 01:30:15,760
到目前为止，我们已经在Elixir中看到了几种不同的数据类型，如果你还没有感觉到自信
till now we have seen a couple of different data types inside elixir now if you're not feeling

797
01:30:15,760 --> 01:30:21,780
不要担心，在我们继续教程的过程中，我们将有更多的练习，但现在
confident don't worry we will have more practice as we progress with the tutorials but right now

798
01:30:21,780 --> 01:30:27,760
让我们顺其自然，我只是想在我们深入学习之前给你介绍一些主题
let us go with the flow i simply wanted to introduce you a couple of topics before we can

799
01:30:28,620 --> 01:30:36,800
下一个主题是关于Elixir内部的控制流程，用于创建循环
deeper into them the next topic is all about your flow control inside elixir for creating loops

800
01:30:36,800 --> 01:30:42,400
我们通常会使用递归，但除了递归之外，我们还有几种不同的机制
we would normally use recursion but other than the recursion we have a couple of different

801
01:30:42,400 --> 01:30:48,980
用于我们的控制流程，让我们先看一下第一个控制流程机制，称为case
mechanisms for our flow control so let's have a look at the first flow control mechanism called

802
01:30:48,980 --> 01:30:57,260
让我们创建一个简单的列表，我们可以说列表是一个、二、三
as a case let us create a simple list so we can say that the list is going to be one two and three

803
01:30:57,260 --> 01:31:04,100
现在我们可以创建一个case语句，这个case语句更像是你的switch语句，让我创建一个语句，然后我可以向你展示它是如何工作的
now what we can do is we can create a case statement so this case statement acts more like

804
01:31:04,100 --> 01:31:09,520
现在让我创建一个语句，然后我可以向你展示它是如何工作的
your switch statement so let me create a statement and then i can show you how it works

805
01:31:10,140 --> 01:31:18,900
所以在这里我们可以说我们想创建一个情况，让我放置结束块，现在在这里我们可以说
so here we can say that we want to create a case and let me put the end block now here we can say

806
01:31:18,900 --> 01:31:25,900
我们只是想从列表中获取第二个元素，所以记住第二个元素
that we simply want to fetch the second element from our list so remember the second element

807
01:31:25,900 --> 01:31:34,500
从我们的列表中将是三，所以它在索引号零一和二，所以我们可以说我们想要
from our list would be three so this is at index number zero one and two so we can say that we want

808
01:31:34,500 --> 01:31:42,460
从列表中获取第二个元素，然后根据这个语句的结果
to fetch from the list the second element and after that depending on the result of this statement

809
01:31:42,460 --> 01:31:49,200
我们可以根据几种不同的情况进行模式匹配，所以让我们在内部创建第一个情况
we can pattern match on a couple of different cases so let us create the first case inside of

810
01:31:49,730 --> 01:31:57,540
所以在这里我们可以说，如果这个语句求值为一，那么我们只想要
so here we can say that in case this statement evaluates to a one at that time we simply want

811
01:31:57,540 --> 01:32:04,920
返回一个字符串，字符串将是这个打印下一个，我们还可以创建多个情况
to return back a string and string would be this one print next we can also create multiple cases

812
01:32:04,920 --> 01:32:11,820
所以在我们得到答案是三的情况下，那个时候我们只想返回三是一个匹配
so in case we get the answer is three back at that time we simply want to return three is a match

813
01:32:11,820 --> 01:32:18,320
接下来是一个通用情况，对于这个情况我们可以说我们想使用一个下划线
and the next one is a catch all case and for that we can say that we want to use an underscore that

814
01:32:18,320 --> 01:32:24,420
这意味着我们对值不感兴趣，但是如果我们没有匹配此返回的情况
means we are not interested in the value but in case we don't have a match for the return of this

815
01:32:24,420 --> 01:32:31,680
在那个时候的声明中，我们只想返回一个名为catch all的字符串，现在让我们试试吧。
statement at that time we simply want to return a string called as catch all now let us try and

816
01:32:31,680 --> 01:32:38,340
评估这个，并且正如你所看到的，我们得到的答案是三是一个匹配，所以让我们试试吧。
evaluate this one and as you can see we get the answer as three is a match so let us try and

817
01:32:38,340 --> 01:32:44,240
重申一下发生的事情，所以我们创建了一个case语句，我们只想在模式匹配上进行匹配。
reiterate what happened so we have created a case statement and we simply want to pattern match on

818
01:32:44,780 --> 01:32:51,740
这个表达式的结果就在这里，所以这个语句的结果是三，因为
the result of this expression right over here so this statement evaluates to a three and since

819
01:32:51,740 --> 01:32:58,560
我们得到了一个匹配，所以我们得到了返回值为三是一个匹配，我们可以使用这个case语句
we get a match that's why we get the return as three is a match we can use this case statement

820
01:32:58,560 --> 01:33:06,300
可以在几乎任何东西上进行模式匹配，例如假设我们有一个结构体，让我们创建一个
to pattern match on almost anything so for example suppose we have a structure so let us create a

821
01:33:06,300 --> 01:33:13,760
模块，这样我们就可以说我们想为post创建一个模块，在其中我们创建一个结构体
module so we can say we want to create a module for post and inside this let us create a structure

822
01:33:13,760 --> 01:33:20,140
让我们创建不同的字段，假设我们想要一个id字段，我们想要
and let us create the different fields suppose we want to have a field for the id and we want

823
01:33:20,140 --> 01:33:26,460
将其初始化为nil，然后我们想要另一个字段用于标题，让我们将其初始化为空白
to initialize to nil and then we want one more field for the title let us initialize to a blank

824
01:33:26,460 --> 01:33:32,740
字符串，下一个可能是用于描述的，我们可以再次将其赋值为空白字符串
string the next one could be for the description and we can again assign it to a blank string

825
01:33:32,740 --> 01:33:41,360
最后一个可能是给作者的，让我们将其分配为空字符串，这样我们就创建了一个结构体。
the last one could be for an author again let us assign a blank string so we have created a struct

826
01:33:41,360 --> 01:33:50,980
接下来让我们创建一个帖子，这样我们就可以说我们想创建一个帖子一，并且我们想要有一个。
next let us create a post so we can say that we want to create a post one and we want to have a

827
01:33:50,980 --> 01:34:00,300
假设帖子的id是一，标题可以是标题一，接下来我们想要作者。
post suppose the id is one the title could be title number one the next we want the author

828
01:34:00,300 --> 01:34:08,720
假设作者是朱利叶斯·凯撒，让我们尝试评估这个单元格，你一定有
suppose the author is Julius Caesar and let us try and evaluate this cell and as you must have

829
01:34:08,720 --> 01:34:15,120
我们没有在结构体内部给出描述，但在定义时我们已经定义了
we are not giving the description inside the struct but while defining we have defined that

830
01:34:15,120 --> 01:34:21,520
万一我们没有描述的值，那么我们只想将其初始化为
in case we don't have the value of description at that time we simply want to initialize it to be

831
01:34:21,520 --> 01:34:27,640
一个空字符串，这就是为什么我们立即得到一个空字符串，接下来我们可以使用
a blank string and that's why we are getting a blank string right away next we can use the

832
01:34:27,640 --> 01:34:34,160
我们的帖子的情况陈述，假设我们想要对作者进行模式匹配，所以我们可以说
case statement for our post and suppose we want to pattern match on the author so we can say that

833
01:34:34,160 --> 01:34:40,740
我们想要一个情况陈述，并且我们想要为我们的帖子编号一进行模式匹配，以及
we want to have a case statement and we want to pattern match for our post number one and

834
01:34:40,740 --> 01:34:47,040
在这里让我们定义一些不同的场景，现在请记住，由于这是一个结构体，我们可以
here let us define a couple of different scenarios now remember that since this is a struct we can

835
01:34:47,040 --> 01:34:54,260
还可以使用地图符号进行模式匹配，所以我们可以假设我们有一个作者
also use the map notation for our pattern matching so here we can say that suppose we have an author

836
01:34:54,260 --> 01:35:01,640
如果作者名字是Octalium，我们只想返回一个字符串"got a post"
and in case the author name is Octalium then we simply want to return a string got a post

837
01:35:01,640 --> 01:35:10,100
从Octalium复制并粘贴，假设作者名字是Anil Kulkarni，那么我们可以说得到
from Octalium let me copy and paste suppose the author name is Anil Kulkarni so we can say got

838
01:35:10,100 --> 01:35:17,740
从Anil Kulkarni发布，接下来我们还可以创建一个捕获所有情况的块，这样我们就可以使用下划线
post from Anil Kulkarni next we can also create a catch all block so we can use the underscore

839
01:35:17,740 --> 01:35:25,620
这次我们可以创建一个字符串，并且可以说得到一条来自于，并且我们可以使用这个字符串
and this time we can create a string and we can say got a post from and we can use the string

840
01:35:25,620 --> 01:35:33,260
插值，所以我们可以说post one dot author，让我们尝试并评估，这次我们得到
interpolation so we can say post one dot author and let us try and evaluate so this time we get

841
01:35:33,260 --> 01:35:39,940
答案是从Julius Caesar得到一条帖子，现在只是一个小提醒，我们可以很容易地更新
the answer as got a post from Julius Caesar now just as a small reminder we can easily update

842
01:35:39,940 --> 01:35:46,940
结构体就像更新一个map一样，所以如果我们想要从Julius更新作者字段
the struct as you would update a map so in case we want to update the author field from Julius

843
01:35:46,940 --> 01:35:53,680
变成我的名字，所以我们可以说我们想要更新作者变为Anil Kulkarni
Caesar to my name so we can say that we want to update the author to become Anil Kulkarni

844
01:35:53,680 --> 01:35:59,660
让我们尝试一下评估，这次我们有了新的作者Anil Kulkarni，现在让我
and let us try to evaluate and this time we have the new author Anil Kulkarni now let me

845
01:35:59,660 --> 01:36:06,280
创建一个新的代码块，让我将case语句复制粘贴到这里
create a new code block and let me just copy and paste the case statement right over here

846
01:36:06,280 --> 01:36:12,820
让我们尝试评估，这次我们仍然得到了答案是Julius Caesar
and let us try to evaluate oh so this time we are still getting the answer as Julius Caesar

847
01:36:12,820 --> 01:36:19,660
那是因为我们在这里没有重新绑定，所以我们可以说我们想重新绑定变量
and that's because we are not rebinding over here so we can say we want to rebind the variable of

848
01:36:19,660 --> 01:36:27,760
将number one重新绑定到更新的值上，让我重新评估，这也让我们尝试重新评估
number one to the updated value so let me reevaluate and this also let us try to reevaluate

849
01:36:27,760 --> 01:36:33,180
这次我们得到了正确的答案，与case语句类似，我们还有另一个
and this time we get the right answer back similar to the case statement we have another

850
01:36:33,180 --> 01:36:38,640
流控制机制的名称为condition，所以让我在这里创建一个新的代码块
flow control mechanism by the name of condition so let me create a new code block over here

851
01:36:38,640 --> 01:36:44,780
这是给条件的，我们可以在这里定义几个不同的条件
and this is going to be for the condition and here we can define a couple of different conditions

852
01:36:44,780 --> 01:36:50,280
现在条件语句不在这里接受表达式进行模式匹配
to pattern match on now the condition statement does not take an expression right over here

853
01:36:50,280 --> 01:36:55,360
相反，我们可以在这里对不同的条件进行模式匹配，所以假设第一个
instead we can pattern match for the different conditions right over here so suppose the first

854
01:36:55,360 --> 01:37:02,020
我们想要匹配的条件是帖子作者，假设您想说的是
condition that we want to match would be for the post author and suppose if you want to say that

855
01:37:02,020 --> 01:37:08,940
如果作者是Octalium，那么我们只需要返回一个字符串，上面写着
in case the author is Octalium at that time we simply want to return a string back saying that

856
01:37:08,940 --> 01:37:16,800
Octalium发布的帖子，让我复制粘贴这个，这次我们来检查一下这个条件
post from Octalium let me copy and paste this one and this time let us check for the condition of

857
01:37:16,800 --> 01:37:24,420
Anil Kulkarni，然后变成Anil
Kulkarni，接下来我们还要定义一个用于捕捉所有情况的代码块
Anil Kulkarni and this also becomes Anil Kulkarni next let us also define the catch all block for

858
01:37:24,420 --> 01:37:30,440
现在来定义捕捉所有情况的代码块的条件，我们只需对true条件进行模式匹配
the condition now for defining the catch all block we simply pattern match on the true condition

859
01:37:30,440 --> 01:37:36,460
如果我们有一个true条件，那么我们只需返回一个
and we can say that in case we have a true condition then we simply want to return a

860
01:37:36,460 --> 01:37:43,100
字符串，上面写着这是一个捕捉所有情况的，现在让我们尝试评估这个单元格，我们会得到
string saying that this is a catch all now let us try to evaluate this cell and we get back the

861
01:37:43,100 --> 01:37:50,020
编辑来自Anil Kulkarni的帖子的答案，让我们再看一个条件块，所以
answer as editing a post from Anil Kulkarni let us have a look at one more condition block so let

862
01:37:50,020 --> 01:37:56,760
让我在这里创建一个新的块，我们还可以使用这个条件语句进行更高级的
me create a new block right over here we can also use this condition statement for more advanced

863
01:37:56,760 --> 01:38:05,360
模式匹配，例如，我们在这里有一个列表，假设我们想进行模式匹配
pattern matching so example we have a list right over here and and suppose we want to pattern match

864
01:38:05,360 --> 01:38:11,460
在第一个元素上，那么这时我们可以简单地使用head函数
on the first element so at that time what we can do is we can simply use the head function

865
01:38:11,460 --> 01:38:19,720
所以我们可以说我们想要从我们的列表中提取头部，如果头部是一个的话
so we can say that we want to extract the head from our list and in case the head is one at

866
01:38:19,720 --> 01:38:26,560
那个时候我们想要返回一个消息，说得到了一个，让我们定义一个捕获所有的块
that time we want to return a message saying that got a one and let us define the catch all block

867
01:38:26,560 --> 01:38:34,460
所以这次我们可以使用字符串插值，我们可以说头部是，然后我们可以放入
so this time we can use a string interpolation and we can say head is and then we can put the

868
01:38:34,460 --> 01:38:40,300
就在这里，让我们在列表上调用头部函数，让我们尝试评估一下
right over here so let us invoke the function of head on the list and let us try to evaluate

869
01:38:40,300 --> 01:38:46,740
这个块，我们得到的答案是得到了一个，所以你可以看到我们可以使用所有不同的
this block and we get the answer as got a one so as you can see we can use all of the different

870
01:38:46,740 --> 01:38:53,720
条件和情况的模式匹配技术，最后的流程控制机制是 if
pattern matching techniques for condition as well as case the last flow control mechanism is the if

871
01:38:53,720 --> 01:39:00,180
和 else 块，但通常你不必使用 if 和 else 块，我们会使用
and else block but normally you will not have to work with the if and else block we would use

872
01:39:00,180 --> 01:39:06,280
递归或模式匹配，而不是使用 if 和 else，但让我向你展示我们如何使用
recursion or pattern matching instead of using if and else but let me show you how we can use the

873
01:39:06,280 --> 01:39:13,560
如果需要的话，让我创建一个新的部分，这个部分是关于 if 和 else 的
if and else block if required so let me create a new section this section is for the if and else

874
01:39:13,560 --> 01:39:20,040
让我们创建一个新的代码块，所以 if 和 else 条件是相同的，所以我们可以
and let us create a new code block so the if and else condition is pretty much the same so we can

875
01:39:20,040 --> 01:39:28,300
如果条件为真，我们将打印出"this will work"，否则我们将打印出"else this
will work"。
say if true then we want to print out this will work else we want to print out else this will work

876
01:39:28,300 --> 01:39:34,000
让我们尝试评估这个单元格，我们得到的答案是"this will work well"。就这些。
and let us try to evaluate this cell and we get the answer as this will work well that's it for

877
01:39:34,000 --> 01:39:39,520
讲解了Elixir中的各种不同的流程控制机制。到目前为止，我们已经学习了非常简短的介绍。
all of the different types of flow control mechanisms inside elixir well till now we had

878
01:39:39,520 --> 01:39:45,760
对Elixir中不同的数据类型和流程控制机制进行了非常简短的介绍。
a very short introduction to the different data types and flow control mechanisms inside elixir

879
01:39:45,760 --> 01:39:51,520
从下一个视频开始，我们将开始使用混合项目，届时我们将更详细地学习所有这些概念。
from the next video we will start working with a mixed project and at that time we will learn all

880
01:39:51,520 --> 01:39:57,980
我认为到现在为止，我们已经学习了足够的内容，可以开始学习函数式编程的基本概念了。
of these concepts in much more details i think by now we have learned enough to start with the basic

881
01:39:57,980 --> 01:40:05,000
让我们继续，开始一个新项目，使用Elixir的基本概念。
concepts of functional programming so let us go ahead and let us start a new project now elixir

882
01:40:05,000 --> 01:40:12,080
Elixir附带了一个名为Mix的工具，它是一个项目管理工具。
ships with a tool called as mix which stands for mixing elixir so this mix is like your project

883
01:40:12,080 --> 01:40:18,560
让我们看看如何使用Mix创建我们的第一个项目，让我回到我的终端。
management tool so let us see how we can use this to create our first project so let me go back to

884
01:40:18,560 --> 01:40:25,640
我想进入我的文件夹"functional programming with
elixir"，现在就开始。
my terminal and i want to go inside my folder functional programming with elixir so right now

885
01:40:25,640 --> 01:40:32,820
我只创建了一个文件夹，用于我们的脚本，现在让我创建一个新的文件夹，让我
i have created only one folder which was for our scripts now let me create a new folder and let me

886
01:40:32,820 --> 01:40:42,420
</summary>
name it as code let me go inside code here we can create a new project by saying mix new and let me

887
01:40:42,420 --> 01:40:50,760
<scene></scene>
name the project as tutorials and that's it we have a new elixir project let me go inside the folder

888
01:40:51,460 --> 01:40:59,400
将其命名为代码，让我进入代码，我们可以通过mix new命令创建一个新项目，让我
and let me open it up in my code editor so as you can see elixir by default creates a bunch of

889
01:40:59,400 --> 01:41:05,980
</summary>
different folders and files for us so inside the lib directory we can see that we have a model for

890
01:41:05,980 --> 01:41:12,180
<scene></scene>
the tutorials let me zoom in for you the first main topic that we are going to learn in our

891
01:41:12,180 --> 01:41:18,020
将项目命名为教程，这就是我们有一个新的elixir项目，让我进入文件夹
journey of functional programming is all about recursion and that's what we are going to start

892
01:41:18,020 --> 01:41:24,200
</summary>
right in the next video now let's start with the most fundamental blocks of functional programming

893
01:41:24,820 --> 01:41:30,680
<scene></scene>
and that is recursion now don't worry if you have never worked with recursion or if you find

894
01:41:30,680 --> 01:41:37,340
让我在我的代码编辑器中打开它，正如你所见，默认情况下，elixir会创建一堆
recursion very confusing i will show you recursion step by step and line by line i will also include

895
01:41:37,340 --> 01:41:42,760
有很多图表和小动画帮助你理解递归的工作原理，但现在先
a lot of diagrams and small animations to help you understand how recursion works but for now

896
01:41:42,760 --> 01:41:48,100
让我们开始吧，这是我们在上个视频中创建的混合项目
let us get started so this is the mix project that we created in the last video

897
01:41:48,100 --> 01:41:55,140
现在我不需要这些代码了，让我把它们拿出来，然后保存一下，现在让我们
now i don't need all of this code let me just take it out and let me just save it now let's

898
01:41:55,140 --> 01:42:00,820
编写一个非常简单的递归程序来打印数字的位数，假设你有一个函数
write a very simple recursive program to print the number of digits so suppose you have a function

899
01:42:00,820 --> 01:42:07,160
称为"up to"，如果你把3传递给它，那么我们应该打印出0到3，所以这是一个非常简单的程序
called as up to and if you pass 3 to it then we should print 0 to 3 so it's a very simple program

900
01:42:07,160 --> 01:42:12,460
但是我们将使用递归来实现这个程序，所以在lib目录下，我希望你创建一个
but we will implement the program recursively so inside the lib directory i want you to create

901
01:42:12,460 --> 01:42:19,540
一个名为"recursion"的新文件夹，在这个文件夹里，让我们创建一个文件，并称之为
a new folder by the name of recursion and inside this folder let us create a file and let us call

902
01:42:19,540 --> 01:42:27,640
它的名字是print digits.dot ex，这次请记住扩展名是.dot ex，因为
it as print digits dot ex now this time please remember that the extension is dot ex because

903
01:42:27,640 --> 01:42:34,420
我们要编译这个文件，如果你在这里测试，我们可以看到我们有.dot ex的文件
we want to compile this file and if you go to test here we can see that we have dot ex's

904
01:42:34,420 --> 01:42:39,760
所以这些是脚本文件，不适用于你的生产代码，现在让我回到
so these are script files and they are not meant for your production code now let me get back to

905
01:42:39,760 --> 01:42:45,800
打印数字，然后让我折叠我的侧边栏，现在记住，elixir中的所有代码
print digits and let me collapse my sidebar now remember that all of the code inside elixir

906
01:42:45,800 --> 01:42:52,360
留在它的模块中，所以第一件事是我们需要为这个文件定义一个模块，所以让我们
stays inside its modules so the first thing is we need to define a module for this file so let's

907
01:42:52,360 --> 01:42:59,980
通过输入 deft module 创建一个模块，这个名字是 recursion dot print
digits，但是
create a module by typing deft module and this is the name recursion dot print digits but the

908
01:42:59,980 --> 01:43:06,140
命名约定是这样的，首先我们通常包含我们的项目名称，所以我们把它命名为
naming convention goes like this first we normally include the name of our project so we have named

909
01:43:06,140 --> 01:43:13,020
项目名称为 tutorials，然后让我打开我的侧边栏，所以在我们的项目 tutorials
中，我们创建了
project as tutorials and let me open up my sidebar so inside our project of tutorials we have created

910
01:43:13,020 --> 01:43:18,820
一个名为 recursion 的文件夹，在该递归文件夹中，我们创建了一个名为 print 的文件
a folder called as recursion and inside that recursion we have created a file called as print

911
01:43:18,820 --> 01:43:24,980
digits，现在记住，这只是一个社区约定，不是必需的，你可以命名为任何名称
digits now remember that this is just a community convention and it is not required you can name

912
01:43:24,980 --> 01:43:30,740
这个模块，任何你想要的名称都可以，现在考虑到这一点，让我折叠我的侧边栏，现在在
this module anything that you want now with that in mind let me collapse my sidebar now inside of

913
01:43:30,740 --> 01:43:36,660
这个模块中，让我们创建一个名为 up to 的函数，这样我们就可以使用关键字 def 来定义一个函数
this module let us create a function called as up to so we can define a function by using the

914
01:43:36,660 --> 01:43:43,020
然后我们可以说 up to，现在这个函数将接受一个参数
keyword of def and then we can say up to now this function is going to accept one parameter

915
01:43:43,020 --> 01:43:49,500
然后我们可以开始使用do和end块处理我们的数字，假设数字是三，我们可以简单地打印出如下内容，所以我们将输入设为三
and that would be for our numbers and then we can start with the do and end blocks now suppose the

916
01:43:49,500 --> 01:43:55,640
数字是三，然后我们想要打印从零到三的数字，这就是我们想要打印的内容，但我们需要以递归的方式来实现，你可能会想也许我们可以创建一个for循环
number is three then we simply want to print out something like this so we take the input as three

917
01:43:55,640 --> 01:44:01,880
然后我们想要打印从零到三的数字，这就是我们想要打印的内容，但我们需要以递归的方式来实现
and then we want to print digits from zero to three so this is what we want to print but we

918
01:44:01,880 --> 01:44:07,240
我们需要以递归的方式来实现这个，你可能会想也许我们可以创建一个for循环
need to do this thing recursively you must be thinking maybe we can just create a for loop

919
01:44:07,240 --> 01:44:15,240
所以我们可以创建一个for循环，让i等于零，然后我们可以说i小于等于
so we can create a for loop for i is equal to zero then we can say i less than and equal to

920
01:44:15,240 --> 01:44:21,960
你的数字，然后i加加，然后我们可以简单地打印出i，所以如果你认为我们可以
your number and then i plus plus and then we can simply print out i so if you're thinking we can

921
01:44:21,960 --> 01:44:28,880
像这样做，答案是否定的，因为Elixir中的所有数据类型都是常量
something like this then the answer is no because all of the data types inside elixir are constants

922
01:44:28,880 --> 01:44:35,260
它们是不可变的，for循环内部的操作是在每次迭代中改变
they're immutable and what's happening inside the for loop is for each iteration we are changing

923
01:44:35,260 --> 01:44:41,860
i的值是在这里改变的，所以我们不能在Elixir中使用这种类型的for循环
the value of i which is right over here so we can't use this kind of for loops inside elixir

924
01:44:41,860 --> 01:44:48,720
那么我们可以使用什么呢？答案是使用递归，让我先删除注释
then what can we use so the answer is by using recursion so let me take out the comments first

925
01:44:48,720 --> 01:44:54,100
让我先写代码，然后我会解释现在发生的情况，让我们考虑一个基本情况。
let me write the code and then i will explain what's happening now let's think of a base case

926
01:44:54,100 --> 01:45:01,000
假设数字本身是零，那么在那个时候我们不需要做任何事情。
suppose the number itself is zero then at that time we don't have to do anything so at that time

927
01:45:01,000 --> 01:45:07,360
我们只需要返回零，所以我们在这里写零，现在记住最后一点。
we simply have to return back zero so we just write zero over here now remember that the last

928
01:45:07,360 --> 01:45:13,400
函数内部的行会自动返回，所以这是你的自动返回语句。
line inside your function automatically returns so this is your automatic return statement and

929
01:45:13,400 --> 01:45:18,920
最后一行不需要使用返回关键字，现在记住，Elixir是一种函数式的。
don't have to use the keyword of return for the last line now remember that elixir is a functional

930
01:45:18,920 --> 01:45:24,900
编程语言，所以基本上我们必须为每个函数返回某种值。
programming language so essentially we have to return some kind of a value for each function

931
01:45:24,900 --> 01:45:31,240
如果函数在那时创建某种副作用，默认情况下会返回一个值。
and in case the function is creating some kind of a side effect at that time by default an item of

932
01:45:31,240 --> 01:45:37,300
返回一个OK，但现在让我们继续进行这个程序，让我写下一个基本情况。
okay is returned but for now let us continue with this program and let me write the next base case

933
01:45:37,300 --> 01:45:43,160
在Elixir中我们可以创建多个相同函数的副本。
so what we can do in elixir is we can actually create multiple copies of the same function

934
01:45:43,400 --> 01:45:50,160
这也被称为函数重载，我们可以这样做，因为Elixir支持模式。
this is also called as function overloading and we can do this because elixir supports pattern

935
01:45:50,160 --> 01:45:55,880
匹配，所以我们在这里创建了一个名为up to的函数，我们
matching so what we did right over here is we created a function called as up to and we are

936
01:45:55,880 --> 01:46:01,840
在零上进行模式匹配，所以如果数字是零，我们只想返回零并且
pattern matching on zero so in case if the number is zero then we simply want to return zero and

937
01:46:01,840 --> 01:46:08,240
就这样，现在我们可以创建另一个相同函数的副本，我们可以说定义up to这个函数
that's it now we can create one more copy of the same function so we can say define up to this

938
01:46:08,240 --> 01:46:14,680
再次接受一个叫做numbers的参数，让我们看看这次我们能做什么，所以这一次
again accepts a parameter called as numbers and let's see what we can do this time so this time

939
01:46:14,680 --> 01:46:20,840
我们想要做的是简单地打印出来，所以我们可以使用io.puts来打印出来，所以让我们
what we want to do is we simply want to print out so we can print out by using io.puts so let us

940
01:46:20,840 --> 01:46:26,640
打印出这个数字，但是我们想要做的是在每次迭代中减少这个数字
print out the number but what we want to do is for each iteration we want to reduce the number

941
01:46:26,640 --> 01:46:33,720
减一，所以例如如果数字是三，那么在我们打印出三之后的下一次迭代中
by one so for example if the number was three then after we print out three for the next iteration

942
01:46:33,720 --> 01:46:38,640
你的数字应该变成二，然后你的数字应该变成一，然后你的数字应该
your number should become two then your number should become one and then your number should

943
01:46:38,640 --> 01:46:44,700
变成零，当你的数字变成零的时候，我们跳到第三行
become zero and when your number becomes zero at that time we go to this line number three

944
01:46:44,700 --> 01:46:50,200
在那里我们只是简单地返回零，所以下一个问题是我们如何减少数字的值
where we simply return zero back so the next question is how can we reduce the value of number

945
01:46:50,200 --> 01:46:56,240
每次递归调用相同的函数，答案都是递减一个，所以
by one each time the answer is by using a recursive call to the same function so for

946
01:46:56,240 --> 01:47:02,740
每次迭代，我们可以调用自身，但每次我们可以做的是说出数字
each iteration we can call ourselves back but each time what we can do is we can say numbers

947
01:47:02,740 --> 01:47:09,260
减一，所以我们假设这个数字是三，所以下一次我们调用时
minus of one so what we are doing is suppose this number is three so the next time when we call the

948
01:47:09,260 --> 01:47:15,700
传递的是三减一，也就是我们传递的是两。现在不用担心
same function we are passing three minus one that means we are passing two now don't worry if you

949
01:47:15,700 --> 01:47:22,000
如果你觉得这个逻辑有点混乱，我们会看看如何追踪这个函数以及如何创建
find this logic a little bit confusing we will see how to trace this function and how we can create

950
01:47:22,000 --> 01:47:27,900
递归树。所以我会用一个小图和一个小动画来解释。但首先让我们运行这个
recursive trees so i will use a small diagram and small animation for it but first let us run this

951
01:47:27,900 --> 01:47:34,300
文件，看看它是否正常工作。所以让我保存文件，然后打开终端
file and let us see if it is working or not so let me save the file and let me open up my terminal

952
01:47:34,300 --> 01:47:40,660
到现在为止，我们一直在使用IEX。但这次我们使用我们自己创建的项目
now till now we have been working with IEX but this time we have created a project by using our

953
01:47:40,660 --> 01:47:47,500
的mix工具。但幸运的是，我们也可以在我们的mix项目中使用IEX，所以在这里我们可以说
mix tool but fortunately we can use IEX along with our mix project as well so here we can say that

954
01:47:47,500 --> 01:47:54,700
嘿，IEX，我想让你启动mix，所以我们只需要使用连字符和s标志，然后跟上mix命令</summary>
hey IEX I want you to start mix so we just use the flag of hyphen and s followed by the mix command

955
01:47:55,320 --> 01:48:01,100
所以背景中发生的是IEX简单地编译您的项目和所有的模块
so what happens in the background is IEX simply compiles your project and all of the modules

956
01:48:01,100 --> 01:48:07,180
在我们的IEX中，所有这些模块都可以使用，让我来澄清一切，让我们调用这个函数
are available to you inside our IEX so let me clear up everything and let us call this function

957
01:48:07,180 --> 01:48:14,120
但要记住，这个函数留在这个模块中，所以我们可以说
of up to but remember that this function stays in this module so what we can do is we can say

958
01:48:14,440 --> 01:48:21,220
从教程模块中，我想让你转到递归模块，从递归中我想让你
from the module of tutorials I want you to go to the module of recursion from recursion I want you

959
01:48:21,220 --> 01:48:27,320
去打印数字的模块，从这里我想使用up to函数，让我们通过
to go to the module of print digits and from here I want to use the function of up to and let us pass

960
01:48:27,320 --> 01:48:33,120
在这里输入三，让我们看看得到的输出，这就是我们得到的结果
three right over here and let us see the output we are getting so here it is we are getting the

961
01:48:33,120 --> 01:48:39,020
输出是三、二和一，所以这个零不会打印，如果你想要，我们可以在这里打印零
output of three two and one so this zero is not printing if you want we can print zero right over

962
01:48:39,020 --> 01:48:45,660
在第四行处，所以如果你想要，我们可以再次用io.puts和零替换这一行
here at line number four so if you want we can replace this line by again io.puts and zero

963
01:48:45,660 --> 01:48:51,580
但我认为打印零没有意义，所以我们可以把这个去掉，或者我们也可以
but I think there is no point in printing zero so we can take this one out or else we can also

964
01:48:51,580 --> 01:48:57,900
说，每当我们得到一个零，我们就简单地想要停止，并且我们可以返回一个被称为“okay”的原子
say that whenever we get a zero we simply want to stop and we can return back an atom called as okay

965
01:48:57,900 --> 01:49:04,660
这象征着我们的操作成功了，现在让我保存文件，既然我们已经保存了。
which symbolizes that our operation was successful now let me save the file now since we have saved

966
01:49:04,660 --> 01:49:11,820
文件后，我们还需要重新编译我们的项目，现在我们有两个选择，要么我们可以重新编译
the file we also need to recompile our project now here we have two choices either we can recompile

967
01:49:11,820 --> 01:49:18,200
整个项目，要么我们可以只重新编译我们更改的模块，但每次
the entire project or we can recompile just the module that we have changed but each time

968
01:49:18,200 --> 01:49:24,280
键入如此庞大的模块名称非常麻烦，所以我们可以做的是创建一个小型的
typing such a huge model name is a big pain in the ass so what we can do is we can create a small

969
01:49:24,280 --> 01:49:32,100
别名，这样我们就可以说我想为tutorials dot recursion dot print
digits创建一个别名
alias so we can say that I want to create an alias for tutorials dot recursion dot print digits

970
01:49:32,100 --> 01:49:38,170
让我清理一下屏幕，现在我们可以说我只想重新编译我的模块
let me clear up the screen and now we can say that I simply want to recompile my module of

971
01:49:38,730 --> 01:49:45,750
digits，就是这样，我们已经重新编译了那个模块，现在让我再清理一次
digits and here it is we have recompiled that module now let me clear it up one more time

972
01:49:45,750 --> 01:49:52,950
这次我们再次可以使用print digits模块，并调用到现在的函数
and this time again we can use the module of print digits and we can invoke the function of up to now

973
01:49:52,950 --> 01:49:58,150
如果你想的话，你可以使用括号，或者你可以省略它们，所以让我传递三个
again if you want you can use the parentheses or you can leave them out so let me just pass three

974
01:49:58,150 --> 01:50:03,730
就在这里，这次我们得到了三个两个一的输出，好的，让我们回到
right over here and this time we get the output of three two one and okay so let us go back to

975
01:50:03,730 --> 01:50:10,710
让我们看看发生了什么，这里发生的事情也被称为你的
let us see what's happening so what's happening right over here is this is also called as your

976
01:50:10,710 --> 01:50:16,490
基本情况，让我在这里加上注释，所以你可以称之为你的基本情况
base case so let me put up comment right over here so this you can call this is your base case

977
01:50:16,490 --> 01:50:23,070
这意味着，如果我们得到一个输入为零的情况，那么我们只是希望
so that means that in case if we get an input which is zero at that moment we simply want to

978
01:50:23,070 --> 01:50:29,630
返回某种值，并且我们希望退出我们的递归函数，既然这个函数
return some kind of a value and we want to exit from our recursive function now since this function

979
01:50:29,630 --> 01:50:37,050
返回一个单一的值，我们可以使用一个更简短的语法，所以让我拿出来，让我拿出来
returns a single value we can use a much shorter syntax so let me take out and let me take out the

980
01:50:37,050 --> 01:50:43,910
写的声明，在函数定义之后，我必须在之后加上一个逗号，我必须加上一个
written statement and after the function definition I have to put a comma after do I have to put a

981
01:50:43,910 --> 01:50:50,670
冒号，让我把这里的好拿出来，然后我把它粘贴到这里，就这样
colon and let me take out the okay from here and let me paste it right over here and that's it so

982
01:50:50,670 --> 01:50:55,490
这也是一个有效的函数定义，所以通常当我们返回一个单一的值时
this is also a valid function definition so normally whenever we return a single value

983
01:50:55,490 --> 01:51:01,050
那个时候我们使用单行定义，现在不返回好了，让我回过头来
that time we use a single line definition now instead of returning okay let me go back to

984
01:51:01,050 --> 01:51:06,670
返回零，所以发生的事情是我们有一个基本情况，每当我们得到输入的情况时
returning zero so what's happening is we have a base case whenever we are getting the input of

985
01:51:06,670 --> 01:51:12,550
那个时候我们只是返回零，但我们没有打印任何东西，在其他所有情况下
zero at that time we are simply returning zero but we are not printing anything and in all other

986
01:51:12,550 --> 01:51:19,870
在其他情况下，我们首先打印该数字，然后进行递归调用，现在让我们看看我们如何
cases we are first printing that number and then we have a recursive call now let's see how we can

987
01:51:20,430 --> 01:51:28,450
所以让我打开我的浏览器，这是我们的打印数字函数，所以
function so let me open up my browser and so this is our function for print digits so this

988
01:51:28,450 --> 01:51:35,530
打印直到零和零这是我们的基本情况，这是我们的递归函数，所以
print up to zero and do zero this is our base case and this is our recursive function so this

989
01:51:35,530 --> 01:51:41,610
第四行是实际打印发生的地方，而第五行我们有
line number four is a place where actual printing is taking place and on line number five we have

990
01:51:41,610 --> 01:51:47,970
一个对同一函数的递归调用，现在让我们看看我们如何跟踪这个函数，想象一下
a recursive call to the same function now let's see how we can trace this function just imagine

991
01:51:47,970 --> 01:51:53,630
我们传递给这个函数的第一个参数是三，所以对于每次迭代，是什么
that the first argument we are passing to this function is three so for each iteration what's

992
01:51:53,630 --> 01:51:59,130
会发生什么，elixir将从上到下比较三和零是否相等
going to happen so elixir is going to compare from top to the bottom is three and zero equal

993
01:51:59,130 --> 01:52:05,010
不，他们不相等，所以elixir将跳到这个函数定义，让我们看看发生了什么
no they are not so elixir will jump to this function definition so let's see what's going

994
01:52:05,010 --> 01:52:10,630
对于这个函数定义要发生的第一件事是我们只是告诉elixir打印出来
to happen for this function definition the first thing is we are simply telling elixir to print out

995
01:52:10,630 --> 01:52:16,130
数值的价值，所以接下来会发生什么，第一个调用是打印，我们得到的是
the value of number so that's what is going to happen so the first call is to print and we get

996
01:52:16,910 --> 01:52:22,830
接下来会发生什么，接下来是对同一函数的递归调用，但是传入的值是
now what happens next so next is a recursive call to the same function but with the value of

997
01:52:22,830 --> 01:52:28,570
减去一，那么我们来看接下来会发生什么，接下来我们调用了同一函数
number minus one so let's see what's going to happen so next is we are calling the same function

998
01:52:28,570 --> 01:52:35,090
但是值变为了两，现在两是否等于零，不等于零，所以再次 elixir
back but the value becomes two now is two equal to zero no it's not equal to zero so again elixir

999
01:52:35,090 --> 01:52:46,110
会跳转到这个函数定义，再次发生了什么，第一行我们只是想要
will jump to this function definition and again what happens the first line is we simply want to

1000
01:52:46,810 --> 01:52:53,550
我们自己返回，但是这次再次减去一，所以下一次调用变成了上一个
ourselves back but this time again number minus one so the next call becomes up to and your

1001
01:52:53,550 --> 01:53:00,370
参数变成了一，同样的事情发生，一是否等于零，不等于零，所以再次 elixir
argument becomes one again the same thing happens is one equal to zero no it's not so again elixir

1002
01:53:00,370 --> 01:53:06,270
会跳转到这个函数定义，第一行是打印出数值，所以我们得到的是
will jump to this function definition the first line is to print the value so we get the value of

1003
01:53:06,270 --> 01:53:12,810
一个回来，现在这里再次发生了什么，我们必须再次调用自己，所以我们再次调用同一个
one back now what happens over here again we have to call ourselves back so again we call the same

1004
01:53:12,810 --> 01:53:19,770
函数，但是这次参数变成了零，记住一个减零，那就是我们得到的是
function but this time the argument becomes zero remember one minus zero that's why we get the

1005
01:53:19,770 --> 01:53:27,150
现在参数是零，再次跳到第一个子句，记住 Elixir 会从上到下扫描你的代码
argument here as zero now again elixir jumps to the first clause now remember elixir scans your

1006
01:53:27,150 --> 01:53:34,650
从上到下扫描代码，第一个定义是使用零进行模式匹配，这次
code from top to the bottom and the first definition is up to with a pattern match of zero and this time

1007
01:53:34,650 --> 01:53:40,810
正在发生的是我们有一个匹配，因为 up to 得到一个零参数，我们只想返回
what's happening is we have a match since up to gets a parameter of zero we simply want to return

1008
01:53:40,810 --> 01:53:47,150
零，所以这里会发生什么？所以对于这个函数，我们只会返回
zero back so what's going to happen over here so for this function we are simply going to return

1009
01:53:47,150 --> 01:53:53,650
零，就这样了，还有其他的调用吗？没有了，所以我们只是退出，就这样
zero back and that's it do we have any other calls left no so we simply exit and that's it

1010
01:53:53,650 --> 01:53:59,150
我们在控制台中显示了从三到一，所以让我再次打开终端
we have the display of three to one in our console so let me open up my terminal one more time

1011
01:53:59,150 --> 01:54:06,210
在这里，我们得到了完全相同的输出，三、二和一，所以我们在这里做的就是
and here it is we have the exact same output of three two and one so what we did right over here

1012
01:54:06,210 --> 01:54:12,830
我们看到了如何跟踪递归程序，所以请记住绘制这种类型的树形结构
is we saw how we can trace our recursive program so always remember to plot this kind of trees

1013
01:54:12,830 --> 01:54:17,870
这将帮助你更好地理解递归编程，现在让我们继续
and this will help you to understand recursive programming in a much better way now let us go

1014
01:54:17,870 --> 01:54:24,930
回到代码，这次让我做一个非常小的改变，现在不再打印数字
back to the code and this time let me make a very small change now instead of printing the number

1015
01:54:24,930 --> 01:54:31,350
首先，如果我先打印数字，然后再看看会发生什么，这一次让我打开终端
first what happens if i print the number afterwards now let's see what happens this time let me open

1016
01:54:31,350 --> 01:54:38,650
再次打开我的终端，让我们重新编译我们的模块，因为我们改变了代码，然后让我
up my terminal one more time and let us recompile our module since we changed the code and let me

1017
01:54:38,650 --> 01:54:45,510
清除它，然后让我再次调用打印数字函数，让我们传入三，这一次
clear it up and then let me again call the print digits up to and let us pass three so this time

1018
01:54:45,510 --> 01:54:52,230
发生了什么，所以不是得到三、二和一的输出，我们得到了一、二和三的输出
what happened so instead of getting the output of three two and one we have the output of one two

1019
01:54:52,230 --> 01:54:59,030
以及三，所以发生了什么？我们只是在这里改变了一行代码，然后我们的整个输出都变了
and three so what happened we simply change one line right over here and our entire output got

1020
01:54:59,030 --> 01:55:05,990
逆转了，所以让我们回过头来，尝试追踪一下这个递归程序，这是之前的
reversed so let us go back and try to trace this recursive program as well so this was the earlier

1021
01:55:05,990 --> 01:55:13,230
一个，而这将是新的，所以记住我们之后有一个打印语句，但是
one and this is going to be the new one so remember that we have the print statement afterwards but

1022
01:55:13,230 --> 01:55:18,650
首先，我们递归调用函数，所以让我们看看这一次会发生什么
first we are calling the function recursively so let's see what's going to happen this time

1023
01:55:18,650 --> 01:55:24,710
所以再次假设我们传入的参数是三，那么会发生什么呢？三等于零吗？
so again suppose that we are passing the argument of three so what happens is three equal to zero

1024
01:55:24,710 --> 01:55:30,550
不是的，三不等于零，然后Elixir将跳到这个函数定义，现在发生了什么？</summary>
no three is not equal to zero then elixir will jump to this function definition now what's happening

1025
01:55:30,550 --> 01:55:36,970
在这个定义中，首先我们调用了自己，所以会发生什么呢？我们有一个递归调用。
in this definition first we are calling ourselves so what's going to happen we have a recursive call

1026
01:55:36,970 --> 01:55:43,590
然后参数变为三减一，这意味着我们有一个名为两的参数，但是什么会发生呢？
and the parameter becomes three minus one that means we have a parameter called as two but what

1027
01:55:43,590 --> 01:55:51,050
在第五行发生了什么呢？这个语句没有执行，因为首先
happens to this call at line number five nothing that statement remains un-executed because first

1028
01:55:51,050 --> 01:55:56,730
我们必须用完这个函数，所以下一步会发生什么呢？让我们看一下
we have to exhaust this function right over here so what's going to happen next time so let us see

1029
01:55:56,730 --> 01:56:02,470
在这里，这个调用不会执行，而是首先我们必须用完
right over here so this call right over here this does not execute instead first we have to exhaust

1030
01:56:02,470 --> 01:56:09,130
这个函数的所有参数，现在发生了什么呢？参数是两，两等于零吗？
all of the parameters for this function now what's happening the parameter is two is two equal to zero

1031
01:56:09,130 --> 01:56:15,110
不，不是，所以我们要进入这个函数定义，那么这一次会发生什么呢？
no it's not so we are going to go in this function definition so what's happening this time we again

1032
01:56:15,110 --> 01:56:21,930
有一个递归调用，那么让我们再次调用自己，但这一次参数变为一
have a recursive call so let us call ourselves back but this time the argument becomes one

1033
01:56:21,930 --> 01:56:27,750
打印语句会发生什么呢？没有执行，它被保留在这里，现在让我们
and what happens to the print statement nothing that is kept on hold right over here now let

1034
01:56:27,750 --> 01:56:33,370
回到这个函数，这里是一等于零吗？不是，所以我们进入这个函数
us go back to this function right over here is one equal to zero no so we go to this function

1035
01:56:33,370 --> 01:56:40,330
再次发生的是我们需要回调自己，所以让我们回调自己，但是这次
again what happens we have to call ourselves back so let us call ourselves back but this time the

1036
01:56:40,330 --> 01:56:46,550
参数变成了零，那么打印语句又会发生什么呢，现在这个还是挂起的
argument becomes zero and what happens to the print statement again that is kept pending now

1037
01:56:46,550 --> 01:56:53,430
这次会发生什么呢，我们在调用自己，但是参数是零，所以我们有一个
what's going to happen this time we are calling ourselves but the argument is zero so we have a

1038
01:56:53,430 --> 01:56:59,930
模式匹配就在这里，每当参数是零时，我们只是返回零，然后
pattern match right over here and whenever the argument is zero we simply give back zero and

1039
01:56:59,930 --> 01:57:10,070
这就是发生在这里的事情，所以这个调用导致了零，现在
that's what happened right over here so this call right over here this resulted in a zero now the

1040
01:57:10,070 --> 01:57:16,090
在之前的函数中，这个打印语句还在等待中，但是number的值是多少呢
in the previous function this print statement is pending but what is the value of number

1041
01:57:16,090 --> 01:57:22,830
所以number的值是一，这就是为什么我们首先得到了一个的输出，现在我们再次耗尽了
so the value of number is one that's why we get the output of one first now again we have exhausted

1042
01:57:22,830 --> 01:57:29,350
这个子句，控制权会再次返回到这里，还有什么是等待中的呢，那就是这个打印语句还在等待中
this clause the control will go back to this one again what's pending the print statement is pending

1043
01:57:29,350 --> 01:57:35,770
但是number的值是多少呢，number的值是二，这就是为什么我们得到的输出是二
but what is the value of number the value of number is two that's why we get the output as two

1044
01:57:35,770 --> 01:57:42,330
现在再次耗尽了这个函数，所以控制权再次返回到这个函数的这里
now again this function is exhausted so the control goes back to this function right over here again

1045
01:57:42,330 --> 01:57:48,530
打印语句还在等待中，但是数字的值是三，这就是为什么。
what's pending the print statement is pending but what is the value of number it's three that's why

1046
01:57:48,530 --> 01:57:54,470
我们得到了三的值，这正是发生在这里的情况，所以我们得到了值。
we get the value of three back and this is exactly happening right over here so we get the value of

1047
01:57:54,470 --> 01:58:01,090
一、二和三，所以这里发生的是我们可以说我们的打印语句正在执行。
one two and three so what's happening over here is we can say that our print statement is executing

1048
01:58:01,090 --> 01:58:08,590
在返回阶段，但在之前的例子中，我们的打印语句是在升序执行的。
in the return stage but in the earlier example our print statement was executing in the ascending

1049
01:58:08,590 --> 01:58:15,010
所以我们在执行递归函数时有一个基本的区别，让我们
stage so we have a basic difference in the execution of our recursive functions let us

1050
01:58:15,010 --> 01:58:20,910
尝试总结一下我们到目前为止学到的东西，我们所做的是创建了一个简单的
try and summarize what we have learned till now so what we have done is we have created a simple

1051
01:58:20,910 --> 01:58:26,570
用于打印出数字的程序，但我们已经在递归函数中实现了逻辑
program to print out the digits but we have implemented the logic in a recursive function

1052
01:58:26,570 --> 01:58:32,450
现在唯一的区别就在这里，第一次递归调用是在这里
now the only line of difference is right over here in the first time the recursive call is

1053
01:58:32,450 --> 01:58:38,370
在这个函数内部的最后一行，现在记住最后一行会自动返回，我们不需要
the last line inside this function now remember the last line is automatically returned we don't

1054
01:58:38,370 --> 01:58:44,650
必须使用返回关键字，这为我们创建了一个循环，现在我们何时退出</summary>
have to use the keyword of return and this is creating a loop for us now when do we exit

1055
01:58:44,650 --> 01:58:51,710
我们在有基本情况时退出，而基本情况是在我们获得一个时，就会发生这种情况。
we exit when we have a base case and what is the base case it's right over here whenever we get a

1056
01:58:52,330 --> 01:58:58,590
我们只是想要在获得时返回零，这是我们从递归函数中退出的时候。
time we simply want to return zero and this is the time when we exit from our recursive function

1057
01:58:58,590 --> 01:59:04,290
因此，我们有两种不同的函数定义，第一个定义是针对我们的基本情况的。
so we have two different function definitions the first definition is for our base case the

1058
01:59:04,290 --> 01:59:10,490
第二个定义是针对我们的递归情况的，现在我们在第二次做的是简单地改变了。
second definition is for our recursive case now what we did in the second time is we simply changed

1059
01:59:10,490 --> 01:59:16,550
我们的递归调用，所以在第二种情况下，首先我们有一个递归调用，然后我们有打印。
our recursive call so in the second case first we have a recursive call and then we have the print

1060
01:59:16,550 --> 01:59:23,290
这一次发生了什么，执行从上升阶段转移到返回阶段。
and what happened this time the execution shifted from ascending stage to the return stage

1061
01:59:23,290 --> 01:59:29,570
因此，如果我必须在这里进一步总结发生的事情，打印是在上升阶段完成的。
so if i have to summarize further here what's happening the printing is done in ascending stage

1062
01:59:29,570 --> 01:59:35,470
而在第二种情况下，打印是在返回阶段完成的，这意味着工作或者
and in the second case the printing is done in the return stage that means the work or

1063
01:59:35,470 --> 01:59:41,430
执行发生在返回而不是上升阶段，因此这种函数
the execution happened during return and not during ascending stage so this kind of function

1064
01:59:41,430 --> 01:59:48,070
也被称为尾递归，现在请记住，在尾递归中，我们调用相同的函数。
is also called as tail recursion now remember in tail recursion we are calling the same function

1065
01:59:48,070 --> 01:59:55,090
每次返回，但参数不同，在第二种情况下，这种递归被称为
back but each time with a different argument and on the second case this recursion is called as

1066
01:59:55,090 --> 02:00:00,530
头递归，因为首先我们有递归调用，然后有某种执行
head recursion because first we have the recursive call and then we have some kind of an execution

1067
02:00:00,530 --> 02:00:07,450
现在你可以看到，我们可以通过使用递归在elixir中创建高效的循环
left now you can see that we can create efficient loops in elixir by using recursion and that too

1068
02:00:07,450 --> 02:00:13,150
通过改变值来避免所有的副作用，就是这样了，希望你喜欢
avoiding all of the side effects by mutating our values well that's it for this one i hope you

1069
02:00:13,150 --> 02:00:18,310
喜欢递归讲座，下次再见，到目前为止我们看到了如何
enjoyed the lecture on recursion and i will catch you in the next one so till now we saw how to

1070
02:00:18,310 --> 02:00:25,430
通过使用递归打印数字，我们看到了两种方法，即尾递归和头递归
print digits by using recursion and we saw two methods that was tail recursion and head recursion

1071
02:00:25,430 --> 02:00:31,470
现在让我们通过递归进行更多练习，这次不仅打印数字
now let us get some more practice with recursion and this time instead of just printing the digits

1072
02:00:31,470 --> 02:00:38,390
让我们将所有数字相加，例如，让我们创建一个名为up two的函数
let us add all of the digits together so for example let us create a function called as up two

1073
02:00:38,390 --> 02:00:44,830
如果你在那时传递了三个参数，我们希望得到所有数字的总和
and if you pass the argument of three at that time we want to get the sum of all of the digits

1074
02:00:44,830 --> 02:00:52,330
所以这个函数应该返回三加上二等于五，五加上一等于六，所以这个函数
so this function should return three plus two that is five five plus one is six so this function

1075
02:00:52,330 --> 02:00:59,090
应该返回6，那么让我们继续并创建这个文件，所以在内部
should return us six so let us go ahead and let us create the file for this one so inside the

1076
02:00:59,090 --> 02:01:07,750
递归目录下，让我创建一个新文件，然后命名为sum of digits.dot ex
directory of recursion let me create a new file and let me call it as sum of digits dot ex the

1077
02:01:07,750 --> 02:01:14,610
首先，我们要定义一个模块，根据社区约定，让我们写
first thing we want to define a module and as per the community convention let us write the

1078
02:01:15,350 --> 02:01:21,210
首先是应用程序名称，应用程序名称是tutorials，然后是文件夹recursion和
application name first so the application name is tutorials and then the folder is recursion and

1079
02:01:21,210 --> 02:01:28,350
然后文件名是sum of our digits，让我关闭我的侧边栏，在这里先写
then the file name is sum of our digits let me collapse my sidebar now here let me first write

1080
02:01:28,350 --> 02:01:35,590
非常简单的递归函数，然后我们将尝试和重启函数，所以让我们调用一个函数
very simple recursive function and then we will try and restart function so let us call a function

1081
02:01:35,590 --> 02:01:42,590
根据up to的名称，让我们传递数字的参数，让我们看看我们能做什么
by the name of up to and let us pass the argument for the numbers and let's see what we can do this

1082
02:01:42,590 --> 02:01:48,350
这次我们可以使用一个非常简单的递归函数，我们可以说对于每一个
time so this time we can use a very simple recursive function we can say that for each

1083
02:01:48,350 --> 02:01:55,250
迭代i只是想要添加数字，下一次我想调用相同的函数up
iteration i simply want to add the number and the next time i want to call the same function of up

1084
02:01:55,250 --> 02:02:02,830
但是每次我的参数应该是数字减一，但是这个函数永远不会结束，因为
but every time my argument should be number minus of one but this function will never end because

1085
02:02:02,830 --> 02:02:08,810
我们没有基本条件，数字会不断变为负值，所以我们还需要
we don't have a base condition the number will keep on going into negative values so we also need

1086
02:02:08,810 --> 02:02:15,510
定义一个基本条件，所以让我们在顶部创建基本条件，让我创建一个新的
to define a base condition so on the top let us create the base condition so let me create a new

1087
02:02:15,510 --> 02:02:22,730
通过名称为up to的函数，这次让我们在零上进行模式匹配，假设数字为零
function by the name of up to and this time let us pattern match on zero suppose the number is zero

1088
02:02:22,730 --> 02:02:28,750
那么这时候我只想返回零，请记住，如果我们只有一行
then at that time i simply want to return back zero now remember if we have a single line of

1089
02:02:28,750 --> 02:02:34,410
返回语句，我们可以将其写在同一行，如果我们有一个普通函数
return then we can write it on the same line and in case if we have a regular function

1090
02:02:34,410 --> 02:02:41,130
那么最后一行会自动返回，我们不需要使用return关键字，所以
then the last line is automatically returned we don't have to use the keyword of return so let

1091
02:02:41,130 --> 02:02:47,450
先保存文件，然后运行文件，然后我们将尝试追踪递归函数
me save the file first let me run the file and then we will try and trace the recursive function

1092
02:02:47,450 --> 02:02:56,590
那么让我打开终端，让我们进入ix，这样我可以输入ix.s，这代表
so let me open up my terminal and let us enter inside ix so i can say ix dot s that stands for

1093
02:02:56,590 --> 02:03:04,130
开始，我想让ix启动我的mix，让我清除所有这些东西，让我们创建一个别名，这样我们就可以
start i want ix to start my mix and let me clear all of these things let us create an alias so we

1094
02:03:04,130 --> 02:03:12,190
可以说我想为tutorials.recursion.一些数字创建一个别名，让我清理一下
can say i want to create an alias for tutorials dot recursion dot some digits let me clear up

1095
02:03:12,810 --> 02:03:19,570
现在我们可以从一些数字的模型中保存，我想使用最多的函数，让我来使用
and now we can save from the model of some digits i want to use the function of up to and let me

1096
02:03:19,570 --> 02:03:26,670
传递参数三，所以我们得到的答案是六，所以发生了什么，三加二
pass the argument of three so as expected we get the answer as six so what happened three plus two

1097
02:03:26,670 --> 02:03:33,570
加一等于六，现在让我们看看我们如何追踪这个递归函数，所以这是我们的
plus one is equal to six now let us see how we can trace this recursive function so this is our

1098
02:03:33,570 --> 02:03:39,790
一些数字的程序，这是我们在第一行写的函数，我们有基础
program for some digits and this is the functions that we wrote on line number one we have the base

1099
02:03:39,790 --> 02:03:45,670
在线号码三，我们有递归的情况，现在让我们看看会发生什么
and online number three we have the recursive case now let us see what's going to happen let's

1100
02:03:45,670 --> 02:03:50,730
拿相同的例子，让我们将三传递给这个函数，现在三等于零吗
take the same example and let us pass three to this function now is three equal to zero

1101
02:03:50,730 --> 02:03:57,110
不是的，三不等于零，所以魔药会进入下一个函数，这里会发生什么
no three is not equal to zero so elixir will go to the next function and here what's going to happen

1102
02:03:57,110 --> 02:04:03,570
在这里，我们说我们想要添加这个数字，在添加数字之后，我们只想要调用
here we are saying that we want to add the number and after adding the number we simply want to call

1103
02:04:03,570 --> 02:04:09,810
递归调用函数，所以会发生的是我们得到三加，然后再次调用
the function recursively so what's going to happen is we get three plus and again we call

1104
02:04:09,810 --> 02:04:16,710
返回相同的函数，但是这次参数是数字减一，所以下次我们会这样做
back the same function but this time the argument is number minus one that's why the next time we

1105
02:04:16,710 --> 02:04:22,230
现在我们用参数为2来调用相同的函数，接下来会发生什么呢？
are calling the same function up to with an argument of two now what's going to happen is

1106
02:04:22,230 --> 02:04:28,350
2等于0吗？不是的，所以elixir会进入下一个函数，然后又发生了同样的事情。
two equal to zero no so elixir will go to the next function now what happens again the same thing

1107
02:04:28,350 --> 02:04:35,250
数字加上递归调用，那么会发生什么呢？这将计算2，我们得到的结果是
number plus the recursive call so what's going to happen is so this will evaluate two we get the

1108
02:04:35,250 --> 02:04:41,070
数字，这种情况下的数字是2，所以是2加上，然后我们再次返回递归调用
number so the number in this case is two so two and plus and then we again get back the recursive

1109
02:04:41,070 --> 02:04:47,810
函数，但这次的参数是2减去1，所以参数变成了1
function but this time the argument is two minus of one that's why the argument becomes one now

1110
02:04:47,810 --> 02:04:53,570
再次回到同样的函数，1等于0吗？不是的，然后我们进入下一个
again let us go back to the same function is one equal to zero no then we will go to the next

1111
02:04:54,010 --> 02:05:00,450
现在这里又重复了同样的事情，所以这次又是数字加上，也就是1加上
now here again the same thing repeats so this time again the number plus that means one plus

1112
02:05:00,450 --> 02:05:06,850
然后让我们再次调用相同的函数，但这次参数变为0，所以接下来会发生什么呢？
and let us call the same function again but this time the argument becomes zero so what's going

1113
02:05:06,850 --> 02:05:12,450
这次会发生什么呢？这次我们有一个基本条件，就在这里
to happen this time this time we have a base condition in place which is right over here

1114
02:05:12,450 --> 02:05:18,770
我们说的是，每当参数为零时，我们只想返回零
we are saying that whenever the argument is zero at that time we simply want to return back zero

1115
02:05:18,770 --> 02:05:24,950
所以这个函数就在这里简单地返回一个零，现在发生了什么呢
so this function right over here this will simply return back a zero so now what has happened we

1116
02:05:24,950 --> 02:05:31,690
已经用完了这个调用，现在控制权必须返回到之前的函数，那么发生了什么呢
have exhausted this call and now the control has to return back to the earlier functions so what's

1117
02:05:31,690 --> 02:05:38,470
接下来会发生什么呢，这整个表达式中的一个加上这个函数将被评估为一加
going to happen so this entire expression one plus of this function this will be evaluated to one plus

1118
02:05:38,470 --> 02:05:45,590
零等于一，所以这整个表达式的值是一，现在控制权将回到
zero is equal to one so this entire expression evaluated to a one now the control will go back

1119
02:05:45,590 --> 02:05:50,970
此函数，但这次发生了什么呢，所以这整个函数调用
to this function right over here but this time what's happening so this entire function call

1120
02:05:50,970 --> 02:05:57,330
评估为一，所以这里会发生什么呢，这整个表达式将会
evaluated to a one so what's going to happen right over here this entire expression would be

1121
02:05:57,330 --> 02:06:02,890
评估为二加一等于三，现在控制权再次回到之前的
evaluated to two plus one is equal to three now again the control will go back to the earlier

1122
02:06:02,890 --> 02:06:09,670
函数调用，所以这次发生了什么呢，up to和two的函数调用已经被评估为
function call so this time what's happening the function call of up to and two has evaluated into

1123
02:06:10,550 --> 02:06:17,590
所以这整个表达式被评估为三加三，这意味着我们得到了六
so this entire expression gets evaluated to three plus of three that means we get back a six

1124
02:06:17,590 --> 02:06:23,550
这就是从我们的函数返回的结果，你现在可以看到，如果你
and this is what is returned from our function which you can see right over here now if you

1125
02:06:23,550 --> 02:06:28,750
看看这个函数，这个函数既不是头递归，也不是尾递归。
have a look at this function this function is neither head recursive neither it is tail

1126
02:06:28,750 --> 02:06:35,010
递归函数，但我们能将这个函数转换为尾递归吗？
recursive it is just a recursive function but can we convert this function into a tail recursive

1127
02:06:35,790 --> 02:06:41,750
是的，我们可以，让我来展示一下如何将这个函数从普通函数转换为尾递归。
yes we can so let me show you how we can convert this function from a regular function to a tail

1128
02:06:41,750 --> 02:06:47,550
递归函数，所以让我们在这里创建一个新函数，我们可以说这次的函数是
recursive function so let us create a new function right over here and we can say that this time the

1129
02:06:47,550 --> 02:06:54,050
上一个函数将是尾递归的，现在先让我写出函数的定义，然后
up to function would be tail recursive now first let me write the function definition and then

1130
02:06:54,050 --> 02:06:59,410
我将解释发生了什么，所以这个函数将接受两个不同的参数
i will explain what's happening so this function is going to accept two different parameters the

1131
02:06:59,410 --> 02:07:06,310
第一个参数是原样的数字，我还想接受一个额外的参数
first parameter is the number as it is and i also want to accept one more parameter which i am going

1132
02:07:06,310 --> 02:07:13,070
称为累加器，简称为acc，接下来让我们考虑一下我们的基本条件
to call as accumulator so which stands for acc for short next let us think of our base condition

1133
02:07:13,070 --> 02:07:19,170
所以正如我们刚才在这里看到的，我们有一个基本条件，当数字为零时，让我们尝试一下
so as we just saw over here we have a base condition where the number is zero so let's try

1134
02:07:19,170 --> 02:07:25,530
并在这里复制相同的逻辑，所以如果我说我的数字本身为零
and replicate that same logic right over here so in case if i say that my number itself is zero

1135
02:07:25,530 --> 02:07:32,850
那个时候，我只是想把我的累加器还回去，所以我可以说做累加器，这就是我们的
then at that time i simply want to return back my accumulator so i can say do acc so this is our

1136
02:07:32,850 --> 02:07:39,290
基本条件，现在让我们看看如何定义我们的递归条件，所以让我复制粘贴
base condition now let us see how we can define our recursive condition so let me copy and paste

1137
02:07:39,290 --> 02:07:44,690
就在这里，这次我们想要得到一个数字，让我们使用返回语句
right over here and this time we want to get a number and let us take the return statement

1138
02:07:44,690 --> 02:07:50,810
在不同的行上，让我把它拿出来，现在让我们看看我们可以使用什么作为我们的递归调用
in a different line so let me take it out now let's see what we can use as our recursive call

1139
02:07:50,810 --> 02:07:55,930
现在再请让我重复一遍，首先让我写代码，然后当我们看到如何时
now again please let me repeat first let me write the code and then when we see how to

1140
02:07:55,930 --> 02:08:01,230
追踪递归算法的逻辑将变得清晰，但现在我想要的是
trace the recursive algorithm at that time the logic will get clear but right now what i want

1141
02:08:01,230 --> 02:08:08,490
要做的就是简单地再次调用相同的函数，但对于每次迭代，我想说的是
to do is i simply want to call the same function again but for each iteration i want to say that

1142
02:08:08,490 --> 02:08:15,750
我的数字必须减一，而对于每次迭代，我只想要添加我的累加器
my number has to decrease by one and for each iteration i simply want to add my accumulator

1143
02:08:15,750 --> 02:08:21,490
与数字一起，就是这样，我们完成了，让我保存文件，让我打开终端
with the number and that's it we are done so let me save the file and let me open up the terminal

1144
02:08:21,490 --> 02:08:28,950
现在我可以重新编译一些数字的模块，现在让我清理屏幕，我们可以说
and now i can recompile the module of some digits now let me clear up the screen and we can say that

1145
02:08:28,950 --> 02:08:35,510
我们想要使用尾递归版本，并让我把三传给这个函数，哦，出错了。
we want to use the tail recursive version and let me pass three to this one oh we have an error

1146
02:08:35,510 --> 02:08:41,870
那是因为我们还需要传递累加器，所以这个尾递归函数需要两个参数。
that's because we also need to pass the accumulator so this function the tail recursive requires two

1147
02:08:41,870 --> 02:08:48,870
我只传递了一个参数，这就是为什么出错的原因，所以让我搞清楚这个问题，然后我们就可以
and i pass only a single argument that's why we get an error so let me clear this up and we can

1148
02:08:48,870 --> 02:08:56,550
说累加器必须为零，这次我们得到的答案是六，现在我们可以
say that the accumulator has to be zero and this time we get the answer back as six now we can

1149
02:08:56,550 --> 02:09:02,410
每次稍微改进我们的程序，而不是传递一个累加器，我可以做的是
slightly improve our program each time instead of passing an accumulator what i can do is i can

1150
02:09:02,410 --> 02:09:09,710
简单地设置默认值，让我们回到代码编辑器，让我复制粘贴这个
simply set the default values so let us go back to the code editor and let me copy and paste this

1151
02:09:09,710 --> 02:09:15,870
所以我们要做的是创建一个函数定义，因为我们
so what we are going to do is we are going to create a function definition and since we are

1152
02:09:15,870 --> 02:09:21,030
只是创建函数定义或者可以说函数头，我们不需要
just creating the function definition or you can say just the function header we don't need to

1153
02:09:21,030 --> 02:09:27,330
指定返回语句，所以这个要去掉，我们可以说默认值为
specify the return statement so this has to go and here we can say that the default value of the

1154
02:09:27,330 --> 02:09:34,230
累加器是零，所以如果没有指定累加器，那么累加器将会
accumulator is zero so in case the accumulator is not specified at that time the accumulator would

1155
02:09:34,230 --> 02:09:40,110
将其设置为零，而不是零，我们可以说第一个参数可以是任意数字
be set to zero and here instead of zero we can say that the first argument can be any number

1156
02:09:40,110 --> 02:09:45,730
所以我们在这里所做的就是简单地创建了一个公共函数，这样我们的代码
so what we have done right over here is we have simply created a public function so as our code

1157
02:09:45,730 --> 02:09:52,030
编辑器帮助我们，它只是一个具有给定名称和体的公共函数，所以通常这些
editor is helping us it's just a public function with a given name and body so normally these

1158
02:09:52,030 --> 02:09:57,610
这些东西在帮助您编写代码文档方面非常有用，我们首先需要重新编译
things they help you with the documentation of your code the first thing we again need to recompile

1159
02:09:57,610 --> 02:10:03,750
让我们清除屏幕上的一些数字模块，然后让我们尝试调用相同的函数
our module of some digits let me clear up the screen and let us try to invoke the same function

1160
02:10:03,750 --> 02:10:09,350
但是这次由于累加器有一个默认参数，所以我可以简单地忽略它
but this time since we have a default argument for the accumulator i can simply leave it out

1161
02:10:09,350 --> 02:10:16,230
在我们继续并跟踪这个递归函数之前，我们再次得到与之前的六相同的答案
and again we get the same answer back as six before we go ahead and trace this recursive function

1162
02:10:16,230 --> 02:10:22,330
我们现在可以做一件小事，这个函数稍微有点昂贵，因为它需要
we can do one small thing now what happens this function is slightly expensive because it takes

1163
02:10:22,330 --> 02:10:28,410
稍微多一点内存，所以我们在这里可以简单地调用尾递归函数
slightly more memory so what we can do over here is we can simply call the tail recursive function

1164
02:10:28,410 --> 02:10:35,110
并传入数字参数，就是这样，所以现在让我们打开终端，让我们再次
and pass the argument of number and that's it so now let us open up our terminal and let us again

1165
02:10:35,110 --> 02:10:42,870
重新编译，让我澄清一切。这一次，如果我做数字点升两倍，如果我...
recompile let me clear up everything and this time if i do some digits dot up two and if i

1166
02:10:42,870 --> 02:10:48,270
将参数传递为三，那么在幕后发生了什么？我们仍然在调用尾递归
pass the argument of three so what's happening behind the scenes we are still invoking the tail

1167
02:10:48,270 --> 02:10:53,730
函数，我们得到的答案与六相同，现在让我们继续前进
recursive function and we are getting the same answer back as six so now let us go ahead and

1168
02:10:53,730 --> 02:11:01,210
看看我们如何追踪尾递归函数，所以这是最后一个函数，现在我们要追踪
see how we can trace the tail recursive function so this was the last function now we want to trace

1169
02:11:01,210 --> 02:11:07,270
尾递归函数在第二行，我们只有函数定义，所以这个函数
the tail recursive function on line number two we just have the function definition so this function

1170
02:11:07,270 --> 02:11:13,270
接受一个数字，累加器的默认值设为零，第三行
accepts a number and for accumulator we have set the default value as zero on line number three we

1171
02:11:13,270 --> 02:11:18,870
有基础条件，我们说当我们得到的数字为零时
have the base condition and we are saying that whenever we get the number as zero at that time

1172
02:11:18,870 --> 02:11:24,970
我们只想返回累加器，接下来是我们的递归调用，现在让我们传递
we simply want to return back the accumulator the next is our recursive call now let us pass

1173
02:11:24,970 --> 02:11:30,850
参数为三传递给这个函数，让我们尝试追踪这个递归函数，所以我们有
the argument of three to this function and let us try to trace this recursive function so we have

1174
02:11:30,850 --> 02:11:37,990
这样的初始调用，数字的值为三，累加器默认为零
an initial call like this the value of number is three and by default the accumulator is set to zero

1175
02:11:37,990 --> 02:11:44,410
现在让我们看看现在发生了什么，三等于零吗？不等于零，所以魔药会...
now let's see what's happening now is three equal to zero no it's not equal to zero so elixir will

1176
02:11:44,410 --> 02:11:49,810
这里的函数右边，现在发生了什么，我们正在调用同一个函数...
function right over here now what's happening now we are calling the same function back

1177
02:11:49,810 --> 02:11:56,130
好的，所以我们需要做的是需要调用同一个函数回来，但是参数会发生什么...
okay so what we need to do we need to call the same function back but what happens to the argument

1178
02:11:56,130 --> 02:12:02,610
所以第一个参数是我们只是想将数字减一，所以在这个条件下...
so the first argument is we simply want to decrement the number by one so in this condition

1179
02:12:02,610 --> 02:12:08,010
发生了什么，数字是三，好的，我们在这里得到了三，而且对于每个调用，我们只是...
what's happening the number is three okay so we get three over here and for each call we simply

1180
02:12:08,010 --> 02:12:13,590
想从中减去一个，所以这里的答案是二，而下一个参数在这里...
want to subtract one from it so the answer here is two and the next parameter is right over here

1181
02:12:13,590 --> 02:12:20,630
所以我们只是想将累加器与数字相加，所以让我们在这里继续，那么是什么...
so we simply want to add the accumulator with the number so let's go right over here so what's the

1182
02:12:20,630 --> 02:12:26,710
累加器，正如你所看到的，最初累加器是零，所以我们得到了一个零，在这里...
accumulator so as you can see initially the accumulator is zero so we get a zero right over

1183
02:12:26,710 --> 02:12:32,350
在这里，数字是三，所以零加三我们得到了一个三，在这里...
here what's the number the number is three so zero plus three we get a three right over here

1184
02:12:32,350 --> 02:12:37,750
所以整个函数看起来会像这样，新的数字是二，和新的...
so this entire function would look something like this the new number is two and the new

1185
02:12:38,210 --> 02:12:44,550
是三现在让我们看看会发生什么，两个等于零吗？不，不是，所以我们继续
is a three now let's see what's going to happen is two equal to zero no it's not so we will go

1186
02:12:44,550 --> 02:12:50,410
在这个函数内部，我们再次需要递归调用相同的函数，所以让我们看看会发生什么
inside this function again we have to recursively call the same function so let us see what's going

1187
02:12:50,410 --> 02:12:56,570
所以再次调用相同的函数，但这次会发生什么？数字是负一
to happen so again we call the same function but this time what happens the number is minus one

1188
02:12:56,570 --> 02:13:03,510
所以这个两减去一个，那么余数是什么？是一，下一个是累加器
so this two comes over here minus of one so what's the remainder it's one the next is accumulator

1189
02:13:03,510 --> 02:13:09,670
加上这个数字，那么在这种情况下累加器是什么？累加器是三，它来自
plus the number so in this case what is the accumulator the accumulator is three which comes

1190
02:13:09,670 --> 02:13:15,250
就在这里，数字是什么？数字是二，所以二就在这里，所以我们有三加二
right over here what is the number number is two so two comes over here so three plus two we have

1191
02:13:15,250 --> 02:13:22,110
等于五，所以这个函数被计算到这里，直到数字变成一，还有
a five so this function gets evaluated to right over here up to the number becomes one and the

1192
02:13:22,110 --> 02:13:28,170
累加器变成五，现在我们必须再次调用自己，现在是一
accumulator becomes five now again the same thing we have to call ourselves back again now is one

1193
02:13:29,030 --> 02:13:34,770
不，所以我们进入下一个条件，再次调用自己，那么接下来会发生什么
no so we go to the next condition and again we call ourselves back so what's going to happen

1194
02:13:34,770 --> 02:13:40,970
这次数字是一，减去一，所以这就是为什么我们得到了一个零在这里
this time so this time number is one one minus of one so that's why we get a zero right over here

1195
02:13:40,970 --> 02:13:47,050
下一个仍然是同样的累加器加上数字，那么累加器是什么
the next is again the same thing accumulator plus the number so what's the accumulator the

1196
02:13:47,050 --> 02:13:58,150
累加器是五，所以我们在这里得到了五，数字是一，所以我们得到
accumulator is five that's why we get a five over here what's the number the number is one so we get

1197
02:13:58,150 --> 02:14:05,470
计算出来的结果是从这里到零和六，所以这次数字变成了
is evaluated something like this up to zero and six oh so this time the number becomes

1198
02:14:05,470 --> 02:14:11,870
零，所以会发生什么呢，它会走到这里，所以数字是零，是的
zero so what's going to happen so it's going to go right over here so is the number zero yes the

1199
02:14:11,870 --> 02:14:18,210
数字是零，那我们应该怎么办，我们只需返回累加器，这就是将要发生的
number is zero so what do we do we simply return back the accumulator so that's what is going to

1200
02:14:18,210 --> 02:14:23,850
就在这里发生，我们只需返回累加器，那么累加器是什么
happen right over here we simply have to return back and the accumulator so what's the accumulator

1201
02:14:23,850 --> 02:14:29,890
累加器是六，这就是我们写的，所以现在还有什么吗，没有，没有
the accumulator is six and that is what we have written so now is anything left nothing nothing

1202
02:14:29,890 --> 02:14:36,970
剩下的就是这样了，我们得到的答案是六，所以正如你所见，这些尾递归函数
is left and that's it we get the answer back as six so as you can see these tail recursive functions

1203
02:14:36,970 --> 02:14:43,610
非常特殊，第一个原因是它们需要更少的内存，为什么它们需要更少的内存
are very special the first reason is they require less memory and why do they require less memory

1204
02:14:43,610 --> 02:14:48,910
这是因为它们在递归地再次调用自己，现在如果你来自于
it's because they are recursively calling themselves back again now if you come from

1205
02:14:48,910 --> 02:14:54,730
其他编译语言，比如Java或者可能是Python，你一定在想，对于每个调用，我们必须分配不同的堆栈内存，但事实并非如此，在Elixir中不会发生这种情况。
other compiled language like java or maybe like python you must be thinking that for each of

1206
02:14:54,730 --> 02:15:01,870
这些调用，我们必须分配不同的堆栈内存，但在Elixir中并不会发生这种情况。
these calls we must be allocating different stack memory but no that does not happen in elixir since

1207
02:15:01,870 --> 02:15:07,590
Elixir是一种函数式编程语言，这些函数调用进行了高度优化，那么问题是什么呢？
elixir is a functional programming language this function calls are highly optimized so what's

1208
02:15:07,590 --> 02:15:13,710
正在发生的是我们只是重用相同的堆栈，因此没有额外的内存分配。
happening we are simply reusing the same stack and hence there is no extra memory allocation

1209
02:15:13,710 --> 02:15:18,910
所以，无论何时可能，请尽量使用尾递归函数，因为它们的内存占用更少。
so always whenever possible try and use tail recursive functions because they are more memory

1210
02:15:18,910 --> 02:15:24,890
从速度上来说更高效，可能更多也可能更少，你不知道，但从内存方面来说，它们要求的内存少得多。
efficient in terms of speed it could be more it could be less you don't know but in terms of

1211
02:15:24,890 --> 02:15:29,910
肯定要求较少的内存，好了，这就是本视频的内容了，我会继续下一个，我们在最后一个视频中练习了一些递归，计算了不同数字的和，但是对于本视频，我想计算一个数字的阶乘，先让我把它改回旧代码。
memory for sure they require much less memory well that's it for this video and i will catch

1212
02:15:29,910 --> 02:15:36,410
下一个视频见，我们在下一个视频中继续练习递归，在上一个视频中，我们编写了一个简单的递归程序来计算不同数字的和，但是在本视频中，我想计算一个数字的阶乘。
you in the next one let's have some more practice with our recursion in the last video we wrote a

1213
02:15:36,410 --> 02:15:42,250
非常简单的递归程序，用于计算不同数字的和，但是在本视频中，
very simple recursive program to calculate the sum of the different digits but for this video

1214
02:15:42,250 --> 02:15:49,210
我想计算一个数字的阶乘，首先让我把它改回旧代码。
i wanted to calculate the factorial of a number first let me get this back to the old code so the

1215
02:15:49,210 --> 02:15:58,670
旧代码是数字加上的总和，然后我们只需要调用减去一个的数字，所以这样
old code was number plus of up to and then we simply want to call number minus of one so this

1216
02:15:58,670 --> 02:16:04,550
时间，我想要做的是编写一个计算阶乘的程序，例如
time what i wanted to do is i wanted to write a program for calculating factorial so for example

1217
02:16:04,550 --> 02:16:13,410
比如三，那么阶乘就会是这样的，三乘以二乘以一，输出就是
like three then the factorial would be like this three into two into one and the output would be

1218
02:16:13,410 --> 02:16:19,970
六，所以我想要暂停一下视频，然后你自己试一试，我希望你能做到
six so i wanted to pause this video for a moment and try it on your own so i hope you were able to

1219
02:16:19,970 --> 02:16:26,850
如果不行，我们一起来做，首先让我创建一个新文件，让我把它叫做
do it if not let us do it together so first let me create a new file and let me call that file as

1220
02:16:26,850 --> 02:16:34,770
阶乘.dot.ex，首先让我们创建模块，让我们得到模块的名称，这一点很重要
factorial dot ex and first let us create the module let us get the module name right this has

1221
02:16:34,770 --> 02:16:41,270
是tutorials.dot.recursion.dot.factorial，这里让我创建一个名为的函数
to be tutorials dot recursion dot factorial and here let me create a function called as

1222
02:16:41,270 --> 02:16:47,970
off，这样我们就可以简单地调用阶乘.off，所以第一个条件是，如果我得到一个
off so we can simply call factorial dot off so the first condition is in case if i get one

1223
02:16:47,970 --> 02:16:55,330
在那个时候，我只是想要返回一个，接下来让我们写递归情况，所以如果我们得到了
at that time i simply want to return one back next let us write the recursive case so in case we get

1224
02:16:55,330 --> 02:17:01,670
其他数字，我们可以说数字，这次让我来展示一下你如何计算，通过
some other number so we can say number and this time let me show you how you can calculate by

1225
02:17:01,670 --> 02:17:07,410
使用一个普通的递归程序，然后我还会教你如何编写这个程序
using a regular recursive program and after that i will also show you how to write this program by

1226
02:17:07,410 --> 02:17:13,890
使用尾递归，但现在让我们顺其自然，所以在这里我们可以说每次迭代
using tail recursion but for now let us go with the flow so here we can say that for each iteration

1227
02:17:13,890 --> 02:17:20,870
我们想要乘以一个数字，每次调用自己，但每次
we want to multiply a number and we simply want to call ourselves back each time but each time

1228
02:17:20,870 --> 02:17:28,450
要将数字减一，所以这是一个非常简单的递归案例，让我们打开我们的
want to decrement the number by one so this is a very simple recursive case let us open up our

1229
02:17:28,450 --> 02:17:36,570
终端让我清理一切，让我们使用我们的 ix，让我调整一下我的终端，在这里
terminal let me clear up everything and let us use our ix let me adjust my terminal as well here we

1230
02:17:36,570 --> 02:17:44,930
可以创建一个别名，所以我们可以说tutorials dot recursion dot
factorial，让我们调用我们的函数
can create an alias so we can say tutorials dot recursion dot factorial and let's call our function

1231
02:17:44,930 --> 02:17:52,730
我们可以说阶乘的结果是，让我们传入三，所以答案是六，让我们试试四
we can say factorial of and let us pass three so we get the answer as six let us try with four

1232
02:17:52,730 --> 02:17:58,950
所以我们得到24的答案，现在让我们尝试跟踪这个递归程序，看看发生了什么
so we get the answer as 24 back now let us try and trace this recursive program and see what's

1233
02:17:58,950 --> 02:18:05,850
所以这是我们写的第一个递归程序，所以这里有一个基本条件
happening so this is the first recursive program that we wrote so here we have the base condition

1234
02:18:05,850 --> 02:18:12,410
如果我们得到一个，我们只想返回一个，否则我们想调用这个函数
define of if we get one we simply want to return one otherwise we want to call this function so

1235
02:18:12,410 --> 02:18:19,250
让我们尝试追踪发生的情况，假设我们使用参数三调用这个函数
let us try and trace what's happening so suppose we invoke this function with an argument of three

1236
02:18:19,250 --> 02:18:25,950
那么在那个时候会发生什么呢？三等于一吗？不，所以elixir会进入这个函数
so at that time what's going to happen so is three equal to one no so elixir will go to this function

1237
02:18:25,950 --> 02:18:32,850
接下来会发生什么？我们需要将数字相乘，并再次调用函数本身
and now what's going to happen we have to multiply the number and call the function itself again so

1238
02:18:32,850 --> 02:18:39,030
这里我们要将三相乘，并再次调用相同的函数
here it goes we want to multiply three and we want to call the same function one more time

1239
02:18:39,030 --> 02:18:45,410
但是由于我们将数字减一，所以这次参数变为了二，现在再次是
but since we are decrementing the number by one so this time the argument becomes two now again is

1240
02:18:45,410 --> 02:18:51,090
二等于一吗？不，所以我们将再次跳转到这个函数，同样的事情会发生
two equal to one no so we will jump to this function again the same thing will happen we

1241
02:18:51,090 --> 02:18:56,790
首先需要将数字相乘，并再次调用相同的函数，所以这次再次
first have to multiply the number and call the same function one more time so this time again

1242
02:18:56,790 --> 02:19:04,890
我们有两个，这次两个将与相同的函数相乘，新的参数是一，所以在
we have two and this time two multiplied by the same function and the new argument is one so in

1243
02:19:04,890 --> 02:19:11,930
下一次迭代中，我们在基本情况下找到了匹配，所以既然我们找到了匹配，我们只需要返回
next iteration we have a match on the base case so since we have a match we simply have to return

1244
02:19:11,930 --> 02:19:19,650
一，所以这个函数将被计算为一个简单的一，现在控制权将返回到这里
one so this function would be evaluated to a simple one now the control will go back to this

1245
02:19:19,650 --> 02:19:26,170
在这里的语句是两乘以这个函数，所以这将被计算为二
statement right over here two multiplied by and this function so this would be evaluated to two

1246
02:19:26,170 --> 02:19:33,250
这句话就在这里，所以整个表达式将被计算为二，现在
and this one comes right over here so this entire expression would be evaluated to a two now the

1247
02:19:33,250 --> 02:19:39,410
控制流将再次回到这里，所以这个将被计算为类似这样的
control will again flow back right over here so this one would be evaluated something like this

1248
02:19:39,410 --> 02:19:44,990
三乘以二，我们有六，现在顶部没有任何东西了
three multiplied by two and we have a six now there is nothing on the top we have exhausted

1249
02:19:44,990 --> 02:19:51,450
同样这个函数，这就是为什么我们得到六作为返回值，这是三的阶乘
this function as well that's why we get the return value as six which is the factorial of three now

1250
02:19:51,450 --> 02:19:57,450
回到我们的程序，这是一个非常简单的递归方式来创建阶乘
let's go back to our program so this was a very simple recursive way of creating the factorial

1251
02:19:57,450 --> 02:20:03,710
接下来你能否用尾递归方式写出相同的程序，所以如果你可以就给出
next is can you write the same program but by using tail recursion so if you can just give it

1252
02:20:03,710 --> 02:20:08,570
暂停一下，自己尝试一下，否则我会告诉你我们如何编写相同的程序
a pause and try it on your own otherwise i will show you how we can write the same program by

1253
02:20:08,570 --> 02:20:14,450
使用尾递归，让我在这里创建一个新函数，我可以说是的但是
using tail recursion so let me create a new function right over here and i can say off but

1254
02:20:14,450 --> 02:20:19,910
这次它将使用尾递归，这个函数将接受两个参数
this time it's going to be with tail recursion this function is going to accept two arguments

1255
02:20:19,910 --> 02:20:25,850
所以第一个数字将是数字，对于尾递归函数，让我们首先创建
so the number one would be on number and for the tail recursive function first let us create the

1256
02:20:25,850 --> 02:20:32,550
在这里，我们可以在数字上进行模式匹配，所以我们可以说如果数字是一的情况下
case so here we can pattern match on the number so we can say that in case the number is one

1257
02:20:32,550 --> 02:20:39,170
第二个参数是我们的累加器，所以这次我只是想返回我的
and the second argument is our accumulator so this time i simply want to return back my

1258
02:20:39,170 --> 02:20:43,910
累加器，所以不用担心如果你不懂，我们也会追踪这个程序
accumulator so don't worry if you don't understand we will trace this program as well

1259
02:20:43,910 --> 02:20:51,350
接下来是我们的递归情况，所以我们可以说我们的尾递归版本，所以第一个参数
next comes our recursive case so we can say off our tail recursive version so the first argument

1260
02:20:51,350 --> 02:20:56,870
是我们的数字，第二个参数是我们的累加器，所以在这里我可以说对于每一个
is our number the second argument is our accumulator so here i can say that for each

1261
02:20:56,870 --> 02:21:04,150
迭代，我只想再次调用同一个函数，所以尾递归，但是对于每次迭代
iteration i simply want to call the same function again so off tail recursion but for each iteration

1262
02:21:04,150 --> 02:21:12,530
我只想让我的数字减一，并且对于每次迭代，我还想乘以我的
i simply want to decrement my number by one and for each iteration i also want to multiply my

1263
02:21:12,530 --> 02:21:18,810
累加器和我的数字，接下来我们还可以对这个程序进行一点改进
accumulator with my number next we can do one slight improvement for this program as well

1264
02:21:18,810 --> 02:21:23,830
我们还可以为累加器设置一个默认值，所以让我们继续吧
we can also have a default value for the accumulator so let us go ahead and let us

1265
02:21:23,830 --> 02:21:28,690
在顶部创建函数定义，记住函数定义总是在顶部
create the function definition on the top so remember that the function definition always

1266
02:21:28,690 --> 02:21:35,850
在顶部定义我们的尾递归函数，第一个
goes on the top so here we can say we want to define off our tail recursive function the first

1267
02:21:35,850 --> 02:21:41,550
参数总是成为数字，第二个参数是累加器，对于
argument is always going to become the number the second argument is our accumulator and for

1268
02:21:41,550 --> 02:21:47,170
累加器我们希望默认值为1，而且这只是一个函数
the accumulator we want to have the default value of one and since this is just a function

1269
02:21:47,170 --> 02:21:53,350
定义我们不需要编写这个函数的主体，让我打开终端并且
definition we don't have to write the body of this function and let me open up my terminal and

1270
02:21:53,350 --> 02:21:58,810
因为我们已经修改了模块的内容，让我们先尝试重新编译这个模块
since we have changed the contents of the module first let us try and recompile this module now

1271
02:21:58,810 --> 02:22:04,870
现在让我清理一切，然后让我们尝试使用尾递归版本，所以我们可以说
let me clear up everything now let's try and use the tail recursive version so we can say

1272
02:22:04,870 --> 02:22:11,230
这次我们想要使用我们的尾递归函数来计算阶乘，并且让我们传递参数
factorial off this time we want to use our tail recursive function and let us pass the argument

1273
02:22:11,790 --> 02:22:18,890
这样我们得到的答案是6，让我们再试一次，用5的阶乘，对于5我们得到的答案是
so we get the answer back as 6 let us try one more time with 5 and for 5 we get the answer as

1274
02:22:18,890 --> 02:22:25,630
120，现在让我们继续并尝试追踪这个递归程序，这就是我们的尾部
120 so now let us go and try and trace this recursive program as well so this is our tail

1275
02:22:25,630 --> 02:22:31,510
递归版本，正如你所见，对于第一行，我们有函数定义，第一个
recursive version so as you can see for the first line we have the function definition the first

1276
02:22:31,510 --> 02:22:37,130
参数是数字，我们为累加器和默认值
argument is the number and we have the default value for the accumulator and the default value

1277
02:22:37,130 --> 02:22:43,230
是1，接下来我们有基本情况，在这里我们只想在数字上进行模式匹配
is one next we have the base case and here we simply want to pattern match on the number

1278
02:22:43,230 --> 02:22:49,750
因此，我们在数字为1的情况下，我只想返回我的
so we are saying that in case the number is one at that time i simply want to return back my

1279
02:22:49,750 --> 02:22:56,490
累加器接下来，我们有递归案例，所以对于每次迭代，我们只想递减
accumulator next we have our recursive case so for each iteration we simply want to decrement

1280
02:22:56,490 --> 02:23:03,250
数字减一，我们还想用数字乘以我们的累加器，现在让我们
the number by one and we also want to multiply our accumulator with the number so now let us

1281
02:23:03,250 --> 02:23:08,690
看看会发生什么，假设我们用三个参数调用函数
see what's going to happen with this one suppose we invoke the function with an argument of three

1282
02:23:08,690 --> 02:23:14,630
累加器的默认值是1，那么下一次迭代会发生什么
and the default value for the accumulator is one so for the next iteration what's going to happen

1283
02:23:14,630 --> 02:23:20,590
所以三等于一吗？不，所以elixir将直接跳过这里，那么接下来会发生什么
so is three equal to one no so elixir is going to jump right over here so what's going to happen

1284
02:23:20,590 --> 02:23:27,550
这次我们想回调自己，所以这个函数会回调自己，但这次的
this time we want to call ourselves back so this function will call itself back but this time the

1285
02:23:27,550 --> 02:23:33,470
参数是数字减一，所以三减一，所以我们在这里得到了一个二。
argument is number minus one so three minus one that's why we get a two right over here

1286
02:23:33,470 --> 02:23:39,750
对于下一个参数，我们只想用累加器乘以数字。
and for the next argument we simply want to multiply the accumulator with the number the

1287
02:23:39,750 --> 02:23:45,010
累加器是一个，数字是三，所以我们在这里得到了一个三，所以这个函数会。
accumulator is one the number is three so we get a three right over here so this function would

1288
02:23:45,010 --> 02:23:51,390
看起来像这样，所以下一步再次，所以二等于一吗，不，所以我们必须再调用一次。
look something like this so next again so is two equal to one no so we have to call ourselves one

1289
02:23:51,390 --> 02:23:56,670
再多一次，所以这一次会发生什么是我们想将数字减一。
more time so again this time what's going to happen is we want to decrement the number by one

1290
02:23:56,670 --> 02:24:03,610
所以这个求值为一，我们还想用累加器乘以数字，所以
so this evaluates to a one and we also want to multiply the accumulator with the number so the

1291
02:24:03,610 --> 02:24:09,790
累加器是三，数字是二，所以我们在这里得到了一个六，所以这个函数会
accumulator is three and the number is two so we get a six right over here and this function would

1292
02:24:09,790 --> 02:24:15,430
看起来像这样，这次会发生什么，哦，所以这次我们有一个匹配的
look something like this what's going to happen this time oh so this time we have a match on the

1293
02:24:15,430 --> 02:24:21,290
数字，我们正在进行模式匹配并说在那个时候，如果数字是一个
number and we are pattern matching and saying that in case the number is one at that time we

1294
02:24:21,290 --> 02:24:27,190
想要返回累加器，所以这个函数会求值为这样的东西，我们只是简单地
want to return the accumulator so this function would evaluate to something like this we simply

1295
02:24:27,190 --> 02:24:33,170
必须将累加器返回，并且累加器的值是六，这就是你的最终答案。
have to return back the accumulator and the accumulator is six and that's your final answer

1296
02:24:33,170 --> 02:24:39,170
在此之后我们只需退出，因为没有其他事情要做，这只是一个小提示。
and after this we simply exit because there is nothing else left to do so just as a small tip

1297
02:24:39,170 --> 02:24:44,150
每当你感到对递归感到困惑，或者不知道递归内部发生了什么时，
whenever you are feeling confused with recursion or if you don't know what's happening inside your

1298
02:24:44,150 --> 02:24:49,830
递归调用时，画这种递归树总是一个好主意，它们肯定会
recursive calls it's always a good idea to draw this kind of recursive trees and for sure they

1299
02:24:49,830 --> 02:24:55,730
帮助你更好地理解递归，好了，就到这里，我会理解的
help you to understand recursion in a much better way well that's it for this video and I will catch

1300
02:24:55,730 --> 02:25:01,670
在下一个视频中见到你，让我们继续练习递归，这次我想让你
you in the next one let's have some more practice with our recursion and this time I want you to

1301
02:25:01,670 --> 02:25:08,490
编写一个程序，将数字反转，例如数字是一二三，那么
write a program that will reverse the numbers so in case the number is one two three then the

1302
02:25:08,490 --> 02:25:14,290
输出应该是三二一，我在幕后创建了一个新的
output should be three two and one and what I've done is behind the scenes I have created a new

1303
02:25:14,970 --> 02:25:22,350
在递归内部创建了一个反转数字，并为它创建了一个空模型，现在你可以使用
reverse number inside recursion and I have created a blank model for this one now here you can use

1304
02:25:22,350 --> 02:25:28,490
你自己的逻辑来反转数字，或者如果你想要一些参考，我给出了一个简单的算法。
your own logic to reverse the number or if you want some reference I have given a simple algorithm

1305
02:25:28,490 --> 02:25:34,110
就在这里，但不一定要按照我的逻辑来做，如果你可以用其他方式做到，你可以。
right over here but it's not required to follow my logic if you can do it in any other way you are

1306
02:25:34,110 --> 02:25:39,830
欢迎你这样做，让我们看看我在这里给出的步骤，例如数字。
welcome to do it so let's see what steps I have given right over here so for example the number

1307
02:25:39,830 --> 02:25:47,630
如果是123，那么输出应该是321，所以对于这种情况，假设我想写一个尾递归的。
is 123 then the output should be 321 so for this case suppose I want to write a tail recursive

1308
02:25:47,630 --> 02:25:53,370
在那个时候，我想要一个名为累加器的变量。
version at that time I want to have one more variable called as accumulator and I want to

1309
02:25:53,370 --> 02:25:59,230
将累加器的默认值设为零，现在你不必写一个尾递归。
set the default value of accumulator to zero now again it's not necessary for you to write a tail

1310
02:25:59,230 --> 02:26:04,870
递归版本，你可以写任何你认为好的版本，但我要写一个尾递归的。
recursive version you can write any version that you seem fine but I am going to write a tail

1311
02:26:04,870 --> 02:26:10,850
递归版本，所以我又取了一个变量，接下来我要做的是。
recursive version for this one that's why I have taken one more variable next what I am doing is

1312
02:26:10,850 --> 02:26:18,490
我正在创建一个循环，每次迭代我都想创建一个新的数字和一个新的累加器。
I am creating a loop and for each iteration I want to create a new number and a new accumulator so

1313
02:26:18,490 --> 02:26:24,250
让我们看看每次迭代对于新的数字和新的累加器会发生什么。
let's see what's going to happen for the new number and for the new accumulator for each iteration

1314
02:26:24,250 --> 02:26:31,690
在循环中，我只是想将这个数字除以10，这样每次都会得到一个新的数字。
of the loop I simply want to divide this number by 10 so that I get a new number each time so for

1315
02:26:31,690 --> 02:26:41,550
第一次，数字是123，所以123除以10，答案是12，现在是新的累加器
first time the number is 123 so 123 divided by 10 so I get the answer as 12 now for the new accumulator

1316
02:26:41,550 --> 02:26:48,830
有两个步骤，第一步是我只想把现有的累加器乘以10
there are two steps the first step is I simply want to multiply my existing accumulator by 10

1317
02:26:48,830 --> 02:26:55,950
现在现有的累加器是零，所以零乘以10，所以我得到了一个零
now the existing accumulator is zero so zero multiplied by 10 that's why I have a zero right

1318
02:26:55,950 --> 02:27:02,810
所以这是第一部分，下一部分是我还想取这个数字的余数
so this was the first part and the next part is I also want to take the remainder of this number

1319
02:27:02,810 --> 02:27:09,730
所以我使用取模运算符，这里会发生的是123除以10的余数
so I'm using the mod operator so here what's going to happen is the remainder of 123 and 10

1320
02:27:09,730 --> 02:27:17,850
是三，最后一步是零加上三，我们立刻得到了三，下一步是
is three and the final step is zero plus of three and we get a three right away the next thing is

1321
02:27:17,850 --> 02:27:24,450
我想继续循环，直到我的数字变为零，但是现在我的数字是
I want to continue with this loop till the time my number becomes zero but right now my number is

1322
02:27:24,450 --> 02:27:32,890
所以这个数字从123变成12，而新的累加器是三，这就是为什么这个零
so this number changes from 123 to 12 and the new accumulator is three that's why this zero

1323
02:27:32,890 --> 02:27:40,470
变成了一个三，现在我的数字是否等于零？不是，所以我们继续循环，所以下一个循环
changes to a three now is my number equal to zero no so we continue with the loop so for the next

1324
02:27:40,470 --> 02:27:48,090
迭代中我们的数字是12，所以12除以10，我们得到了一个一，就在这里，而且对于新的
iteration our number is 12 so 12 divided by 10 we get a one right over here and for the new

1325
02:27:48,930 --> 02:27:55,550
累加器中的值是三，所以三乘以10得到30，就在这里。
the value inside the accumulator is three so three multiplied by 10 we get a 30 right over here

1326
02:27:55,550 --> 02:28:04,570
接下来，数字是12，12除以10的余数是2，所以这里有30加上2。
for the next part the number is 12 the remainder of 12 and 10 is two so here we have 30 plus of

1327
02:28:04,570 --> 02:28:12,750
这就是为什么结果是32，现在再次检查我的数字是否等于零，不，我的新数字是。
two that's why this will evaluate to 32 now again is my number equal to zero no my new number is

1328
02:28:12,750 --> 02:28:19,970
是1，我的新累加器是32，所以我们继续执行相同的循环，这次我的数字是。
one and my new accumulator is 32 so we continue with the same loop now this time my number is

1329
02:28:19,970 --> 02:28:27,010
1，所以1除以10得到0，就在这里，然后对于新累加器，我的值是。
one so one divided by 10 I get a zero right over here then for the new accumulator my value inside

1330
02:28:27,010 --> 02:28:35,010
累加器是32，正如你在这里看到的，我们有32，所以32乘以10，这就是为什么。
the accumulator is 32 so as you can see right over here we have 32 so 32 multiplied by 10 that's why

1331
02:28:35,010 --> 02:28:43,030
我们在这里得到320，下一部分的数字是1，1除以10的余数变成了。
we get 320 right over here the next part is the number is one the remainder of one and 10 becomes

1332
02:28:43,030 --> 02:28:52,130
1，所以这里有1加上320，所以我们得到了3、2和1，在这里，所以发生了什么呢？
one so here we have one plus of 320 so we get three two and one right over here so what happens

1333
02:28:52,130 --> 02:28:59,910
现在你的数字变成了零，你的累加器变成了321，由于你的数字变成了零，
now your number has become zero and your accumulator has become 321 and since your number becomes zero

1334
02:28:59,910 --> 02:29:06,470
我们只需要返回累加器，累加器是三二一，恰好是。
we simply want to return back the accumulator and the accumulator is three to one which is exactly

1335
02:29:06,470 --> 02:29:11,850
逆序为321，现在在您尝试这个问题之前，让我给您展示一件事情。
the reverse of 123 now before you attempt this question let me show you one more thing

1336
02:29:11,850 --> 02:29:19,670
在Elixir中，如果您执行这样的操作123除以10，您会发现我们得到的是
in elixir if you do something like this 123 divided by 10 here you can see that we get back

1337
02:29:19,670 --> 02:29:25,790
一个浮点数值，但是如果您想要得到一个整数除法，那么可以使用内置的
a float value but if you want to get back an integer division then you can use the inbuilt

1338
02:29:25,790 --> 02:29:34,750
除法函数div，所以我们可以说我们想要将123除以10，并得到整数
function of div for division so we can say we want to divide 123 by 10 and we get back the integer

1339
02:29:34,750 --> 02:29:41,690
值为12，现在对于计算余数，我们没有无操作符，而是可以使用
value of 12 now for calculating the remainder we don't have the bodiless operator instead you can

1340
02:29:41,690 --> 02:29:47,830
内置的remainder函数，所以我们可以说我们想要得到123的余数
use the inbuilt function of remainder so we can say that we want to get the remainder of 123

1341
02:29:47,830 --> 02:29:53,690
除以10，我们得到值3。所以考虑到这些事情，我希望您尝试一下这个问题
with 10 and we get back the value of three so with these things in mind I want you to try this

1342
02:29:53,690 --> 02:29:59,990
现在，让我再次重复一遍，您可以使用自己的逻辑，暂停一下视频，然后尝试一下
now again let me repeat you can use your own logic and just pause this video for a moment and try it

1343
02:29:59,990 --> 02:30:05,990
自己尝试。否则，我们将一起做。所以我希望您能够完成它，如果不能，让我们一起做
on your own otherwise we will do it together so I hope you were able to do it if not let us do it

1344
02:30:05,990 --> 02:30:11,150
。一起，我将为这个程序编写一个尾递归版本，首先
together I am going to write a tail recursive version for this program and the first thing

1345
02:30:11,150 --> 02:30:18,070
我想要做的就是定义我的基本情况，我的基本情况是什么，我的基本情况
which I want to do is I simply want to define my base case and what is my base case my base case

1346
02:30:18,070 --> 02:30:24,530
就在这里，所以如果我的数字是零，那么我只想返回累加器，让我
is right over here so if my number is zero then I simply want to return the accumulator let me

1347
02:30:24,530 --> 02:30:30,730
创建一个名为off的函数，这个函数将接受两个参数，我的数字和
create a function called as off and this function is going to accept two parameters my number and

1348
02:30:30,730 --> 02:30:37,970
我的累加器和我的基本情况就像这样，如果我的数字是零，那么我只想要
my accumulator and my base case is something like this in case my number is zero then I simply want

1349
02:30:37,970 --> 02:30:45,150
返回我的累加器，这就是我们的基本情况，现在让我们定义递归情况，所以我们
to return back my accumulator so this is our base case now let us define the recursive case so we

1350
02:30:45,150 --> 02:30:50,970
可以说off函数将接受一个参数表示数字，第二个
can say that the function of off is going to accept one parameter for the number the second

1351
02:30:50,970 --> 02:30:57,590
一个用于累加器，让我们在这里创建do和end块，我们可以说我的新数字
one for the accumulator and let us create the do and end blocks here we can say that my new number

1352
02:30:57,590 --> 02:31:05,770
将是我的数字除以10的整数除法，而且对于每次迭代，我都想要
is going to be the integer division of my number with 10 and also for each iteration I want to

1353
02:31:05,770 --> 02:31:11,650
创建一个新的累加器，这样我可以说我的新的累加器，让我们再次使用我们的逻辑
create a new accumulator so I can say that my new accumulator again let us use the logic that we

1354
02:31:11,650 --> 02:31:17,770
在这里定义的逻辑是这样的，对于每次迭代，我只想要将其乘以
defined over here so the logic goes like this for each iteration I simply want to multiply the

1355
02:31:17,770 --> 02:31:24,110
累加器为10，接下来我们只需将余数加上即可
accumulator with 10 and for the next part we simply want to add the remainder of the number

1356
02:31:24,110 --> 02:31:30,550
再加上10，现在只需简单地再调用一次相同的函数就可以了
along with 10 now the only thing left to do is to simply call the same function one more time

1357
02:31:30,550 --> 02:31:37,750
但这次参数将是我们的新数字，现在我们有了新的累加器
but this time the argument is going to be our new number and here we have the new accumulator now

1358
02:31:37,750 --> 02:31:43,310
我们还需要将累加器的默认值设置为零，让我创建一个函数
here we also need to set the default value of accumulator to zero so let me create a function

1359
02:31:43,310 --> 02:31:49,490
在顶部进行定义，这样我们可以说off函数接受一个名为number的参数
definition on the top so we can say that function of off accepts one parameter by the name of number

1360
02:31:49,490 --> 02:31:56,570
第二个参数被称为accumulator，默认值为零，因为这只是
the second parameter is called as accumulator the default value is zero now since this is just the

1361
02:31:56,570 --> 02:32:02,690
函数定义，我们不需要创建函数体，让我保存这个程序，让我打开我的
function definition we don't have to create the body let me save this program let me open up my

1362
02:32:03,570 --> 02:32:09,870
现在，由于我这次添加了一个新文件，让我们重新编译整个项目，这样我们就可以说
now since this time I have added a new file let us recompile the entire project so we can say

1363
02:32:09,870 --> 02:32:17,950
我想重新编译，然后让我为tutorials.dot.recursion.dot.reverse创建一个别名
that I want to recompile then let me create an alias for tutorials dot recursion dot reverse

1364
02:32:17,950 --> 02:32:27,340
number哦，抱歉，我拼错了，所以应该是alias，让我清除屏幕，现在让我们
number oh sorry I spelt it wrong so it has to be alias let me clear up the screen and now let us

1365
02:32:27,340 --> 02:32:35,840
新定义的函数，我们可以说是反转数字，并让我们传入参数123。
newly defined function so we can say that reverse number of and let us pass the argument of 123

1366
02:32:35,840 --> 02:32:43,080
我们得到了正确的答案，让我们尝试一下12345，我们得到的答案是
and we get the right answer back let us try with 12345 and we get back the answer of

1367
02:32:44,380 --> 02:32:50,660
到目前为止，我们已经看到了如何在我们的elixir中使用递归，现在是时候
54321 till now we have seen how to work with recursion inside our elixir now it's time to

1368
02:32:50,660 --> 02:32:58,540
我们如何将列表与我们的elixir结合起来，我再怎么强调elixir内部的列表也不为过
how we can combine list along with our elixir and I can't emphasize more that the list inside elixir

1369
02:32:58,540 --> 02:33:06,240
这不是你常规的数组或者列表，elixir中的列表实际上是链表，所以即使是一个列表
are not your regular arrays or list list inside elixir are actually linked list so even if a list

1370
02:33:06,240 --> 02:33:12,320
看起来像这样，它并不是看起来那样，所以对于那些不知道什么是的人来说
looks something like this it's not what it looks like so for those of you who don't know what is

1371
02:33:12,320 --> 02:33:19,320
这是一个链表，我们这里有三个不同的节点，对于第一个节点，数据是
a linked list here it goes so here we have three different nodes and for the first node the data

1372
02:33:19,320 --> 02:33:25,800
头部内的数据是1，所以你可以看到列表内的数据，这个数据实际上是
inside the head is one so as you can see the data inside the list this one this one actually

1373
02:33:25,800 --> 02:33:31,960
在内存中看起来像这样，所以整个东西就是你的节点编号
looks something like this inside the memory so this entire thing this would be your node number

1374
02:33:31,960 --> 02:33:39,220
一个，你头部内的数据就是1，你可以在这里看到的较暗部分，所以
one and the data inside your head would be one the darker portion that you can see over here so

1375
02:33:39,220 --> 02:33:45,480
这将成为您的节点编号一的尾部，这个尾部实际上指向另一个节点
this is going to be your tail of your node number one and this tail is actually pointing to yet

1376
02:33:45,480 --> 02:33:52,060
另一个节点，该节点内部的数据是二，你可以在这里看到，所以整个
another node and the data inside this node is two that you can see over here so this entire

1377
02:33:52,060 --> 02:33:58,660
结构，这是我们的节点编号二，头部内部的数据是二，现在再次，这个节点
structure this is our node number two and the data inside the head is two now again this node

1378
02:33:58,660 --> 02:34:05,540
也有一个尾部，这个尾部指向另一个节点，节点内部的数据是三
also has a tail and this tail is pointing to yet another node the data inside the node is three

1379
02:34:05,540 --> 02:34:11,200
正如您所见，这将成为我们的节点编号三，头部和内部数据
and as you can see this is going to be our node number three the head and the data inside the

1380
02:34:11,200 --> 02:34:17,820
头部是三，现在如果您查看列表，我们没有剩下任何其他参数，所以
head is three now if you have a look at the list we don't have any other parameters left so the

1381
02:34:17,820 --> 02:34:24,060
您的节点编号三的尾部实际上指向一个空值，这意味着它是
tail of your node number three this would actually point to something which is null that means it is

1382
02:34:24,060 --> 02:34:30,160
不指向其他任何东西，这就是链表在内存中的样子，现在只是
not pointing to anything else so this is how a linked list would look inside the memory now just

1383
02:34:30,160 --> 02:34:35,680
为了刷新您的记忆，让我们回到我们的终端，这样我们就可以说我们有一个列表和
to refresh your memory let us go back to our terminal so we can say that we have a list and

1384
02:34:35,680 --> 02:34:41,540
元素是一、二和三，现在正如我们刚才看到的，我们有三个不同的节点
the elements are one two and three now as we just saw we have three different nodes

1385
02:34:41,540 --> 02:34:46,400
如果你想看到第一个元素的头部，那么你可以使用内置的
and if you want to see the head of the first element then either you can use the built-in

1386
02:34:46,400 --> 02:34:52,380
头部的函数，或者我们也可以使用模式匹配，如果你想使用模式
function for the head or we can also use pattern matching and in case if you want to use the pattern

1387
02:34:52,380 --> 02:34:59,060
匹配，我们可以说第一个元素应该是头部，那么我们需要我们的cons运算符
matching then we can say that the first element should be head then we need our cons operator

1388
02:34:59,060 --> 02:35:06,320
然后我们需要另一个变量来表示尾部，让我们在列表上进行模式匹配，这样我们就可以看到
then we need one more variable for the tail and let us pattern match on list and here we can see

1389
02:35:06,320 --> 02:35:13,260
头部是1，尾部是2和3，现在假设我们有另一个列表，我们称之为
that the head is one and the tail is two and three now suppose we have one more list let us call it

1390
02:35:13,260 --> 02:35:20,320
作为第二个列表，其中包含一个元素a，现在如果我尝试
as list number two and this has a single element of a inside of this list now what happens if i try

1391
02:35:20,320 --> 02:35:26,780
对这个列表进行模式匹配，所以让我们进行模式匹配并看到让我们写下头部，我们也
to pattern match on this list so let us pattern match and see let us write the head and we also

1392
02:35:26,780 --> 02:35:33,000
想要尾部，这次我们想对第二个列表进行模式匹配，所以你可以看到
want the tail and this time we want to pattern match on list number two so as you can see the

1393
02:35:33,000 --> 02:35:40,280
头部中的数据是a，但是尾部发生了什么，让我们来检查一下，所以你可以看到
data inside our head is a but what happens to our tail let us check it out so as you can see that

1394
02:35:40,280 --> 02:35:45,940
尾部为空，这意味着我们已经用完了这个链表，没有更多的元素了
tail is blank that means we have exhausted this linked list and there are no more elements left

1395
02:35:45,940 --> 02:35:51,540
所以记住这个模式，我们将看到如何使用递归和列表进行工作，对吧。
so keep this pattern in your mind and we will see how to work with recursion and lists right

1396
02:35:51,540 --> 02:35:58,000
从下一个视频开始，让我们开始使用链表，但在开始之前，我想要
from the next video so let us get started with linked list but before we can get started i wanted

1397
02:35:58,000 --> 02:36:05,700
向你展示一些东西，让我们返回到终端，我现在在我的iex中，以防万一
to show you a couple of things so let us go back to our terminal and i am inside my iex now in case

1398
02:36:05,700 --> 02:36:12,480
如果我想查看列表的信息，让我们创建一个列表，包括one，two和three，这样我们就会得到
if i want to see the info for a list so let's create a list one two and three here we get back

1399
02:36:12,480 --> 02:36:18,720
我们的列表有一些信息参数，我们可以看到我们有一些
a couple of information parameters for our list and here we can see that we have a couple of

1400
02:36:19,680 --> 02:36:26,040
协议，其中一个最重要的协议就是这个，它代表可枚举的
protocols and one of the most important protocol is this one so this stands for enumerable that

1401
02:36:26,040 --> 02:36:32,260
简而言之，就是enum，让我们去官方文档，我可以在那里解释
means in short as enum and let us go to the official documentation and there i can explain

1402
02:36:32,260 --> 02:36:40,140
所有这些东西，这是elixir的官方网站，它是elixirlang.org，让我们去文档
all of these things so this is the official website for elixir it's elixirlang.org let us go to docs

1403
02:36:40,140 --> 02:36:46,180
在这里，我们想要看到当前稳定版本的文档，所以这会带我们去一个新的
and here we want to see the documentation of the current stable version so this takes us to a new

1404
02:36:46,180 --> 02:36:53,580
网站，正如你所见，这个网站被称为hexdocs.pm，所以hex就像是软件包注册表
website and as you can see this website is called as hexdocs.pm so hex is like the package registry

1405
02:36:53,580 --> 02:37:00,280
对于Elixir，如果你去这个网站hex.pm，在这里我们可以搜索不同的
for elixir so in case if you go to this website hex.pm and here we can search for different

1406
02:37:00,280 --> 02:37:05,200
包，假设你想搜索Phoenix，你可以在这里搜索Phoenix
packages suppose you want to search for phoenix then you can search for phoenix right over here

1407
02:37:05,200 --> 02:37:11,060
这将列出所有的包，所以这是Phoenix的官方包
and this is going to list all of the packages so this is the official package for phoenix

1408
02:37:11,060 --> 02:37:17,060
如果你点击在线文档，它将带你到文档页面，这是
and if you click on the online documentation it will take you to the docs page and this is

1409
02:37:17,060 --> 02:37:22,420
Phoenix的官方文档，现在让我们回到Elixir的文档
the official documentation for phoenix now let us go back to the documentation for elixir

1410
02:37:22,960 --> 02:37:28,760
正如你所见，我们在这里有两个选项卡，这个选项卡是用于页面，而这个选项卡是
and as you can see we have two tabs right over here so this tab is for the pages and this tab is

1411
02:37:28,760 --> 02:37:35,120
用于模块，现在内核模块是自动导入的，我们不需要
for the modules now this module of kernel is automatically imported for us we don't have to

1412
02:37:35,120 --> 02:37:42,420
导入这个内核，我想要展示给你的下一个模块是用于我们的列表，所以让我们滚动一下
import this kernel the next module which i want to show you is for our list so let us scroll a

1413
02:37:42,420 --> 02:37:48,820
稍微往下滚动，在这个集合和枚举的部分，我们有我们的列表
little bit down and inside this section of collections and enums we have our list right

1414
02:37:48,820 --> 02:37:55,800
在这里，我们可以看到我们有很好的文档，并且我们还有一些
over here and here we can see that we have nice documentation in place and also we have a couple

1415
02:37:55,800 --> 02:38:02,000
关于列表类型的函数的实现，我们可以看到这里有不同的函数。
of functions that are implemented on the type of list so here we can see we have different functions

1416
02:38:02,000 --> 02:38:07,000
如果你想查看任何函数的文档，只需点击这个。
and if you want to see documentation for any of the functions you have to just click on this one

1417
02:38:07,000 --> 02:38:12,820
这将打开所请求函数的文档。现在在终端中我们看到
and this opens up the documentation for the requested function now in the terminal we saw

1418
02:38:12,820 --> 02:38:19,260
列表还实现了我们的枚举的协议，所以让我们查看一下文档。
that list also implements the protocol for our enum so let us check out the documentation for

1419
02:38:19,260 --> 02:38:27,200
枚举，让我收起我的列表，让我们去枚举的文档。枚举基本上帮助你
enum let me collapse my list and let us go to the documentation for enum so enum basically helps you

1420
02:38:27,200 --> 02:38:33,400
迭代你的列表或任何集合，并且大多数可迭代对象的函数都在枚举中。
iterate over your list or any of the collections and most of the functions for your iterables are

1421
02:38:33,400 --> 02:38:39,780
枚举中，其中一些函数可能在列表、映射或哈希映射中，但枚举将是你最常用的模块。
inside enum and some of them could be in list or maps or hash map but enum would be your most

1422
02:38:39,780 --> 02:38:46,180
经常使用的模块，正如你在文档中看到的，第一个例子本身就使用了一个列表。
frequently used module and as you can see in the documentation the first example itself uses a list

1423
02:38:46,180 --> 02:38:53,260
第二个例子也接受一个列表，并简单地返回列表的总和，所以我们可以做什么
the second example also takes a list and simply gives back the sum of the list so what we can do

1424
02:38:53,260 --> 02:39:00,480
让我们尝试使用我们的列表和递归来复制这个功能，所以现在让我们去吧
let us try and replicate this functionality by using our list and recursion so now let us go

1425
02:39:00,480 --> 02:39:08,020
回到我们的代码编辑器，现在让我们创建一个新的文件夹，所以在我的lib目录下
back to our code editor now here let us create a new folder so inside my directory of lib let

1426
02:39:08,020 --> 02:39:14,340
我们创建一个名为list的文件夹，在这个文件夹里创建一个名为list.ex的新文件
us create a folder by the name of list and inside this folder let us create a new file by the name

1427
02:39:16,000 --> 02:39:25,560
list.ex，让我们首先定义模块，它必须是dot tutorials和这个命名
list.ex and let us first define the module so this has to be dot tutorials and this naming

1428
02:39:25,560 --> 02:39:30,820
转换没有意义，所以现在让我把这个list拿出来，然后我们给它命名
conversion doesn't make any sense so right now let me just take out this list and let us name

1429
02:39:30,820 --> 02:39:38,080
模块命名为tutorials.dot.list，所以让我定义一个名为sum的函数，这个函数将会接受
the module as tutorials dot list so let me define a function called as sum and this is going to take

1430
02:39:38,080 --> 02:39:45,840
我们的数字列表，现在首先让我们考虑一个基本情况，假设我们得到一个空列表，那么在那种情况下
a list of our numbers now first let us think of a base case suppose we get an empty list so at that

1431
02:39:45,840 --> 02:39:52,380
我们可以简单地返回零，让我在顶部定义一个基本情况，我可以说定义
time we can simply return back a zero so let me define a base case on the top so i can say define

1432
02:39:52,380 --> 02:39:58,840
我的sum，让我们对空列表进行模式匹配，所以我们可以直接在这里写空列表
my sum and let us pattern match on an empty list so we can just write empty list right over here

1433
02:39:58,840 --> 02:40:05,180
所以如果我们得到一个空列表，我们只需要返回零，现在让我们看看我们如何
so in case we get an empty list we simply want to return back a zero so now let us see how we can

1434
02:40:05,180 --> 02:40:11,400
递归情况下，我们可以做的是这个参数numbers，实际上是一个列表
the recursive case now what we can do is this parameter of numbers this is actually a list

1435
02:40:11,400 --> 02:40:17,400
所以我们可以在这里进行模式匹配，我可以将这个参数拿出来
so we can pattern match right over here so what i can do is let me take out this parameter and

1436
02:40:17,400 --> 02:40:23,500
让我们在函数定义中进行模式匹配，让我们将头部收集到一个叫做的变量中
let us pattern match inside the function definition let us collect the head inside a variable called

1437
02:40:23,500 --> 02:40:30,940
作为h，让我们将尾部收集到一个叫做的变量中，现在让我们看看我们要做什么
as h and let us collect the tail inside a variable called as t now let us see what we want to do for

1438
02:40:30,940 --> 02:40:37,460
每次迭代，我们只想将头部与总和相加，每次我们只想
each iteration we simply want to add the head along with the sum and each time we simply want

1439
02:40:37,460 --> 02:40:43,820
传递尾部，就这样，我们有一个递归函数，用于将所有元素相加
to pass the tail and that's it we have a recursive function for adding all of the elements inside the

1440
02:40:43,820 --> 02:40:49,980
现在，正如你所看到的，这不是一个尾递归版本，所以我们可以
list now as you can see that this is not a tail recursive version so what we can do is let us

1441
02:40:49,980 --> 02:40:56,880
试着给这个函数改个名字，不叫sum了，我们把它重命名为sum
try and rename this file so instead of calling this as sum let us rename this function from sum

1442
02:40:58,340 --> 02:41:04,400
这样做很简单，因为这只是一行返回语句，让我来处理一下
simple and here what we can do is since this is just one single line of return let me take it

1443
02:41:04,400 --> 02:41:11,140
变成一行代码，我们不需要结束块，让我们打开我们的
to a single line let me put the codes and we don't need the end block and let us open up our

1444
02:41:11,140 --> 02:41:18,000
终端，看看这个是否正常工作，让我进入我的ix，让我清理一下
terminal and see if this is working or not so let me go inside my ix and let me clear up my

1445
02:41:18,000 --> 02:41:23,940
终端，我们可以说从教程模块跳转到列表模块
terminal and here we can say that from the module of tutorials i want to go to the module of list

1446
02:41:23,940 --> 02:41:31,460
然后我想调用简单求和函数，并让我们传递列表[1, 2, 3]
then i want to invoke the function of sum simple and let us pass the list of one two and three

1447
02:41:31,460 --> 02:41:39,000
正如预期的那样，我们得到了答案六。现在我们可以写这个函数
and as expected we get back the answer as six now what we can do is we can also write this function

1448
02:41:39,000 --> 02:41:45,700
通过使用尾递归，让我们看看如何创建尾递归函数，以便我们可以调用
by using tail recursion so let us see how we can create the tail recursive function so we can call

1449
02:41:45,700 --> 02:41:52,620
将该函数命名为sum_and_tail_recursive，让我们考虑可以传递的不同参数
that function as sum and tail recursive and let us think of different parameters that we can pass

1450
02:41:52,620 --> 02:41:58,900
对于我们的尾递归版本，此函数将接受两个参数，第一个参数显然是我们的
for our tail recursive version this function will accept two parameters the first is obviously our

1451
02:41:58,900 --> 02:42:05,280
数字列表，我们还需要一个累加器，我们可以定义这个函数
list of numbers and we also need an accumulator and what we can do is let us define the function

1452
02:42:05,280 --> 02:42:12,040
在这里定义，因此我们可以说累加器的默认值必须为零
definition right over here so we can say that the default value for our accumulator has to be zero

1453
02:42:12,040 --> 02:42:17,460
现在，由于我们刚刚创建了函数定义或函数头，我们不需要
and now since we have just created the function definition or the function header we don't need

1454
02:42:17,460 --> 02:42:23,620
为这个函数创建函数体，接下来让我们编写实际的实现，让我复制一下
to create a body for this one next let us write the actual implementation so let me just copy and

1455
02:42:23,620 --> 02:42:30,620
所以在这里我们不需要默认参数，首先让我们考虑基本情况，所以如果
paste so here we don't need the default argument and first let us think of the base case so in case

1456
02:42:30,620 --> 02:42:37,100
numbers只是一个空列表，所以在那时我们只想返回我们的累加器
the numbers is just an empty list so at that time we simply want to return back our accumulator

1457
02:42:37,100 --> 02:42:44,000
下一个是我们的递归情况，所以让我再次复制和粘贴，这一次我们可以模式匹配
the next is our recursive case so let me again copy and paste now this time again we can pattern

1458
02:42:44,000 --> 02:42:49,900
在头部和尾部进行匹配，所以我们可以说我们想收集头部，我们也想要
match on the head and on the tail so we can say that we want to collect the head and we also want

1459
02:42:49,900 --> 02:42:56,300
收集尾部，并且对于每次迭代，我们只想调用相同的函数，但是
to collect the tail and for each iteration we simply want to call the same function back but

1460
02:42:56,300 --> 02:43:02,100
现在对于每次迭代，我们只想传递尾部，我们不需要为每次传递头部
now for each iteration we simply want to pass the tail we don't need to pass the head for each

1461
02:43:02,100 --> 02:43:09,600
迭代，我们的累加器变成了我们的累加器加上我们的头部，就这样我们有了一个尾部
iteration and our accumulator becomes our accumulator plus of our head and that's it we have a tail

1462
02:43:09,600 --> 02:43:15,620
递归函数，现在让我们做一件简单的事情，让我来到顶部，这里让我
recursive function as well now let us do one simple thing let me go at the top and here let

1463
02:43:15,620 --> 02:43:22,380
创建一个名为sum的函数，它接受我们的numbers，在这里让我们简单地
me create a function which is called as sum and this accepts our numbers and here let us simply

1464
02:43:22,380 --> 02:43:28,200
调用尾递归版本，所以我们可以说我想调用我的尾递归版本
call the tail recursive version so we can say that i want to call my tail recursive version

1465
02:43:28,200 --> 02:43:34,560
让我把数字传递给它，这样我们就有一个更小的名字，这让我们的生活更轻松
and let me pass numbers to it so now we have a much smaller name and this makes our life much

1466
02:43:34,560 --> 02:43:43,180
更容易，所以让我们回到终端，重新编译tutorials.dot.list，让我清理一下
more easy so let us go back to our terminal let us recompile tutorials dot list let me clear up

1467
02:43:43,180 --> 02:43:49,400
屏幕上，让我们调用相同的函数，但这次函数的名字只是sum
the screen and let us invoke the same function but this time the name of the function is just sum

1468
02:43:49,400 --> 02:43:55,600
正如预期的那样，我们得到的答案是六，这次计算总和我们使用的是
and as expected we get back the answer as six and this time for calculating the sum we are using

1469
02:43:55,600 --> 02:44:02,260
尾递归版本。现在，我不会再画递归树了，但如果你
the tail recursive version now going forward i am not going to draw the recursive trees but if you

1470
02:44:02,260 --> 02:44:07,920
感到自信，或者感到困惑，那么我强烈建议你画出递归树
feeling confident or if you're feeling confused then i highly motivate you to draw the recursive

1471
02:44:07,920 --> 02:44:13,920
现在，在结束这个视频之前，我想向你展示一些东西。第一件事是
trees now before ending this video i wanted to show you a couple of things the first thing is

1472
02:44:13,920 --> 02:44:19,080
让我们看看如何为我们的所有代码做文档。第一件事是我们可以使用一些东西
let us see how we can document all of our code the first thing is we can use something which is

1473
02:44:19,080 --> 02:44:25,600
称为模块属性，所以在顶部，我们可以说我们想要为
called as module attributes so on the top we can say that we want to create documentation for the

1474
02:44:25,600 --> 02:44:31,580
整个模块，所以让我们记录下我们要为这个列表模块做的事情
entire module so let's document what we are going to do for this module of list we are going to

1475
02:44:31,580 --> 02:44:37,740
实现一些可用于列表的函数，以便我可以为我们创建一个标题。
implement a couple of functions that can be used on the list so i can create a heading for our

1476
02:44:37,740 --> 02:44:44,000
函数概要，我们实现的第一个函数是求和函数，这是它的用法。
function summary and the first one that we have implemented is for our sum so this is how you

1477
02:44:44,000 --> 02:44:49,320
接下来，写模块级文档，让我来展示一下我们如何编写文档。
write the module level documentation next let me show you how we can write the documentation for

1478
02:44:49,320 --> 02:44:55,920
我们的函数，我们可以使用`__doc__`模块属性，在引号内编写文档。
our function so for this we can use the model attribute of just doc and inside the quotation

1479
02:44:55,920 --> 02:45:01,400
让我们编写文档，说明这个函数返回数字的和。
marks let us write the documentation saying that this function returns the sum of the numbers

1480
02:45:01,400 --> 02:45:06,760
在一个列表中，现在如果你将鼠标悬停在sum的定义上，我们可以看到代码。
inside a list so now if you hover over the definition of sum we can see that the code

1481
02:45:06,760 --> 02:45:11,900
编辑器正在显示文档，这是我在这个视频中想要向你展示的最后一件事。
editor is showing us the documentation and the last thing which i wanted to show you in this

1482
02:45:11,900 --> 02:45:19,360
在这个视频中，我想向你展示如何定义类型规范或类型提示，我们可以使用另一个模块。
video is how we can define the type specifications or the type hints so here we can use another module

1483
02:45:19,360 --> 02:45:31,360
通过spec这个名称来定义属性，这代表函数的规范，所以这里我们想要定义
attribute by the name of spec so this stands for the function specifications so here we want to

1484
02:45:31,360 --> 02:45:39,140
这个参数的类型，在我们的例子中，sums实际上是一个列表，这个列表包含不同的
type of this parameter so in our case sums is actually a list and the list contains different

1485
02:45:39,140 --> 02:45:45,740
数字，所以这就是我们定义数字类型的方式，接下来是返回类型，所以我们可以将返回类型定义为数字，所以在这里
numbers so this is how we can define the type of numbers the next comes the return type so here we

1486
02:45:45,740 --> 02:45:51,760
可以使用双引号，并且我们可以说返回类型也将是一个数字，所以
can put double quotes and we can say that the return type is also going to be a number so what

1487
02:45:51,760 --> 02:46:01,340
我们所做的是我们还添加了文档，也添加了规范，所以在
we have done is we have also added the documentation and we have also add the specifications so in the

1488
02:46:01,980 --> 02:46:07,500
你的代码内部，接下来让我们也为我们的其他函数编写规范
inside your code next let us write the specifications for our other functions as well

1489
02:46:07,500 --> 02:46:14,640
所以让我复制这个并粘贴到这里，这个函数将是我们的求和函数
so let me copy this one and let me paste it right over here this function is going to be our sum of

1490
02:46:14,640 --> 02:46:21,120
接下来让我们也为我们的尾递归函数编写规范，所以我可以说
simple next let us also write the specification for our tail recursive function so here i can say

1491
02:46:21,120 --> 02:46:27,560
这个函数的名称实际上是我的尾递归求和函数，现在这个函数接受两个参数
that this function name is actually my sum of tail recursive now this function accepts two

1492
02:46:27,560 --> 02:46:34,260
第一个参数是一个数字列表，第二个参数只是一个整数，所以我们可以说
the first parameter is a list of numbers the second one is simply an integer so we can say

1493
02:46:34,260 --> 02:46:40,060
第二个参数是整数，返回类型是数字，如果你想阅读更多
that the second parameter is an integer and the return type is number and if you want to read more

1494
02:46:40,060 --> 02:46:47,060
关于类型规范的信息，我们可以查阅官方文档，我们可以去
about the type specifications then we can go to the official documentation and we can go to the

1495
02:46:47,060 --> 02:46:53,180
页面标签上，我们可以看到我们的类型规范文档没错了
tab of pages and here we can see that we have the documentation for our type specifications right

1496
02:46:53,180 --> 02:46:58,240
不要过于担心类型规范，我会向你展示如何编写规范
don't worry too much about type specifications i will show you how we can write the specifications

1497
02:46:58,240 --> 02:47:04,020
从这里开始，我们就结束了这个视频，我会在下一个视频中与你见面
from here on well that brings us to the end of this video and i will catch you in the next one

1498
02:47:04,540 --> 02:47:10,760
现在让我们看看如何在elixir中反转一个列表，例如我们有一个列表，它是这样的
now let us see how we can reverse a list inside elixir so for example we have a list and this

1499
02:47:10,760 --> 02:47:16,340
列表有两个元素两个和三，所以在你的内存中，这个列表会像这样
list has two elements two and three so this list would look something like this inside your memory

1500
02:47:16,340 --> 02:47:23,200
我们有两个节点，所以这个节点是为了两个，这个节点是为了三，现在我有一个问题
we have two nodes so this node is for two and this node is for three now here goes my question

1501
02:47:23,200 --> 02:47:28,960
假设我们在左边有两个节点，我们可以看到我们有一个节点，在右边
suppose we have two more nodes on the left here we can see that we have one node and on the right

1502
02:47:28,960 --> 02:47:36,000
在这里我们可以看到我们有一个节点，所以现在的问题是将这个节点添加到我们的列表中
here we can see that we have one more node so now the question is would adding this node to our list

1503
02:47:36,000 --> 02:47:42,020
将两个和三添加到列表中是更快的，还是将四添加到我们的列表中是更快的，所以
of two and three would be faster or adding four to our list of two and three would be faster so

1504
02:47:42,020 --> 02:47:48,280
你认为哪个操作会更快，这个操作会更快，所以答案是
do you think this operation would be faster or this operation would be faster so the answer is

1505
02:47:48,280 --> 02:47:55,480
添加这个节点会更快，这是因为它在常数时间内完成，原因是我们没有
adding this node would be faster and this happens in constant time and the reason is we don't have

1506
02:47:55,480 --> 02:48:01,660
为了遍历整个列表，我们只需取一个节点，然后将尾部指向
to traverse throughout this entire list we simply take a node and we simply point the tail to an

1507
02:48:01,660 --> 02:48:08,640
现有列表，就这样，但如果我们想在最后添加一个节点，那时它
existing list and that's it but what happens if we want to add a node at the last at that time it

1508
02:48:08,640 --> 02:48:14,620
效率不高，因为它需要线性时间，添加这个节点也需要线性时间
is not efficient because it is going to take a linear time and adding this node takes a linear

1509
02:48:14,620 --> 02:48:20,420
因为我们必须遍历整个链表，所以需要一些时间，因此在这种情况下，我们必须从
time because we have to traverse through the entire linked list so in this case we have to go from

1510
02:48:20,420 --> 02:48:28,280
这个节点到这个节点，然后我们就可以将这个节点的尾部指向最后一个节点，所以它需要
this node to this node and after that we can point the tail of this node to our last node so it takes

1511
02:48:28,280 --> 02:48:34,200
线性时间，所以请记住，将节点添加到头部始终更快
linear time so just keep this thing in mind that adding a node to the head would be always faster

1512
02:48:34,200 --> 02:48:40,640
而且，使用这种逻辑，在最后添加一个节点需要线性时间，让我们看看我们如何
and adding a node at the last would take linear time with this logic in place let us see how we

1513
02:48:40,640 --> 02:48:46,300
可以反转一个列表，例如，我们有一个列表在这里，并且我们有元素one，two
can reverse a list so for example we have a list right over here and we have elements of one two

1514
02:48:46,300 --> 02:48:52,960
和three，所以这时候我们将使用一个额外的累加器列表，对于每次迭代我们都将
and three so at that time we will take one more accumulator list and for each iteration we will

1515
02:48:52,960 --> 02:48:59,180
将这个元素的头部取出，并将该头部插入我们的累加器列表中，那么会发生什么呢？
take the head of this one and we will insert that head inside our accumulator list so what happens

1516
02:48:59,180 --> 02:49:05,020
第一次迭代时，我们只需取出头部并将其插入累加器中
for the first iteration is we simply take out the head and insert the head inside our accumulator

1517
02:49:05,560 --> 02:49:11,800
由于我们是在头部插入，所以此操作的时间是恒定的，并且对于下一步
now here since we are inserting at the head this operation takes constant time and for the next

1518
02:49:11,800 --> 02:49:17,740
迭代中会发生什么呢？由于我们已经取出了一个，您的列表现在变为两个和三个
iteration what happens since we have taken out one your list now becomes two and three so for

1519
02:49:17,740 --> 02:49:24,020
在下一次迭代中，我们只需取出两个，并将两个添加到现有列表的头部
the next iteration we simply take out two and we add two to the head of our existing list now again

1520
02:49:24,020 --> 02:49:29,640
由于我们是在头部添加，这个操作也是按线性时间进行的，现在进入我们的
since we are adding to the head this operation also happens in linear time now going to our

1521
02:49:29,640 --> 02:49:35,360
原始列表，由于我们已经取出了两个，所以只剩下一个元素，同样的情况再次发生
original list since we have taken out two we have just one element left and the same thing happens

1522
02:49:35,360 --> 02:49:41,440
我们只需将三取出，并将三添加到累加器列表的头部，就是这样
we simply take the three out and we add three to the head of our accumulator list and that's it we

1523
02:49:41,440 --> 02:49:46,920
已经反转了一个链表，或者说我们只是在elixir中简单地反转了一个列表，所以让我们
have reversed a linked list or rather we have simply reversed a list inside elixir so let us

1524
02:49:46,920 --> 02:49:52,300
为这个编写代码，让我们看看这些东西是如何运作的，所以让我加上一个注释
write the code for this one and let us see these things in action so here let me put up a comment

1525
02:49:52,300 --> 02:49:58,760
这将是我们的反转功能，在这里让我们定义一个名为reverse的函数。
this is going to be our function of reverse here let us define a function called as reverse

1526
02:49:58,760 --> 02:50:04,980
现在这个函数接受两个参数，第一个是我们的元素，第二个是
now this function accepts two parameters the first one is for our elements the second one

1527
02:50:04,980 --> 02:50:10,260
是用于累加器的，并让我们在这里定义函数签名，以防万一
is for the accumulator and let us define the function signature right over here so in case

1528
02:50:10,260 --> 02:50:16,420
累加器在那时没有给出，那么我们只需将累加器设置为空列表
the accumulator is not given at that time we simply want to set the accumulator to be a blank list

1529
02:50:16,420 --> 02:50:22,900
接下来是我们的基本情况，所以让我复制粘贴，这里我们可以进行模式匹配，我们可以
the next comes our base case so let me copy and paste and here we can pattern match and we can

1530
02:50:22,900 --> 02:50:28,740
说在这里如果我们有一个空列表，那么我们只想要返回
say that in case we have a blank list right over here at that time we simply want to return back

1531
02:50:28,740 --> 02:50:35,640
我们的累加器，所以我可以说做和我的累加器，接下来是我们的递归情况
our accumulator so here i can say do and my accumulator the next comes our recursive case

1532
02:50:35,640 --> 02:50:41,200
所以再让我复制粘贴，现在我们可以做的是对列表进行简单的模式匹配
so again let me copy and paste now here what we can do is we can simply pattern match for the list

1533
02:50:41,200 --> 02:50:47,620
所以我们可以取头部，也可以取尾部，对于每次迭代，我们必须调用
so we can take the head and we can also take the tail and for each iteration we have to call the

1534
02:50:47,620 --> 02:50:53,640
相同的函数回来，现在让我们看看如何为我们的尾递归函数传递参数
same function back now let us see how we can pass the arguments for our tail recursive function

1535
02:50:53,640 --> 02:50:59,640
首先让我们为累加器编写参数，所以如果我们回到我们的图表
first let us write the argument for our accumulator so if we go back to our diagram

1536
02:50:59,640 --> 02:51:05,560
所以这里我们想做的是，我们想要取出头部，然后将头部插入到
so here what we want to do is we want to take the head and we want to insert the head inside

1537
02:51:05,560 --> 02:51:12,260
我们的累加器中，这就是我们可以在这里做的，所以我们只想取出头部，然后
our accumulator so that's what we can do over here so we simply want take the head and we want

1538
02:51:12,260 --> 02:51:18,460
将头部添加到我们的累加器中，现在让我们再回到图表，因为我们已经
to add the head to our accumulator now let us again go back to the diagram now since we have

1539
02:51:18,460 --> 02:51:24,700
取出了一个列表，下一次迭代应该是两个和三个，而且我们可以很容易地
taken out one our list for the next iteration should be two and three and we can very easily

1540
02:51:24,700 --> 02:51:35,540
做到这一点，所以对于下一次迭代，我们只需要将尾部传递回来，就这样我们就有了一个
do that so for the next iteration we simply have to pass the tail back and that's it we have a

1541
02:51:35,540 --> 02:51:42,780
这个程序在我们的 ix 中，所以让我打开我的终端，现在让我进入我的 ix，现在让我
this program inside our ix so let me open up my terminal let me go inside my ix now here let me

1542
02:51:42,780 --> 02:51:49,240
清屏，我可以说我想要从我的教程模块转到我的列表，然后我
clear up my screen and i can say that i want to go from my module of tutorials to my list and i

1543
02:51:49,240 --> 02:51:56,400
想要反转，然后让我们传递参数 one two 和 three，正如预期的那样，我们得到了
want to reverse and let us pass the argument of one two and three and as expected we get back the

1544
02:51:56,400 --> 02:52:02,880
答案为 three two 和 one，现在视频中的最后一件事是让我们也写一下
answer as three two and one now the last thing inside this video is let us also write the

1545
02:52:03,350 --> 02:52:09,540
对于这个函数，我们可以使用模块属性来进行规范，我们可以说
for this function here we can use the module attribute for our specifications and we can say

1546
02:52:09,540 --> 02:52:15,480
我们的reverse函数现在可以说，elements实际上是一个列表
that our function of reverse now here we can say that elements is actually going to be a list

1547
02:52:15,480 --> 02:52:21,380
由于我们不知道列表中会有什么类型的元素，我们可以说
and since we don't know what type of elements would be there inside the list we can say that

1548
02:52:21,380 --> 02:52:27,240
它们可以是任何类型，并且累加器也是同样的情况，让我给你展示一下
they can be of any type and the same thing goes for our accumulator as well here let me show you

1549
02:52:27,240 --> 02:52:33,420
更多的替代语法，所以我们可以简单地写成这样的列表，里面
more alternate syntax so instead of writing list we can simply write a list like this and inside

1550
02:52:33,420 --> 02:52:39,620
我们可以指定这个列表可以容纳任何类型的元素，而且对于返回类型
the list we can specify that this list can hold any kind of elements and again for the return type

1551
02:52:39,620 --> 02:52:45,880
我们可以说返回类型也是一个列表，而且这个列表可以容纳任何东西，所以我们可以指定
we can say that the return type is also a list and this list can hold anything so we can specify

1552
02:52:45,880 --> 02:52:51,280
这里可以是任何东西，为了保持一致，让我也将这个转换一下，所以让
any right over here and just for the sake of consistency let me convert this as well so let

1553
02:52:51,280 --> 02:52:57,040
我放上方括号，我们不需要这个，就这样结束了，下一个视频见
me put square brackets we don't need this and that's it for this video i'll catch you in the

1554
02:52:57,040 --> 02:53:04,300
下一个，让我们看看如何实现map函数，但首先让我向你展示一下我做了什么
next one next let us see how we can implement the map function but first let me show you what do i

1555
02:53:04,300 --> 02:53:12,200
在这里我是想说，让我们看看文档，我想要查看枚举模型的文档。
mean to say so here let us see the documentation so i want to go to my model of enum and i want

1556
02:53:12,200 --> 02:53:20,600
要查看map函数的文档，正如你在这里所看到的，这个map函数接受一个列表。
to see the documentation of map so as you can see over here so this map function this takes a list

1557
02:53:20,600 --> 02:53:28,960
元素列表和一个函数作为参数，对于每次迭代，它会简单地应用这个函数。
of elements and it also takes a function and what does it do for each iteration it simply applies

1558
02:53:28,960 --> 02:53:35,740
将这个函数应用于元素，例如，我们可以看到第一个元素是1，这个函数将1乘以2，所以我们得到了答案2。
this function to the element so for example we can see that the first element is one and this

1559
02:53:35,740 --> 02:53:42,320
这个函数接受1并返回1乘以2，这就是为什么我们得到了答案2。
function is taking one and it is giving back one multiplied by two that's why we have the answer of

1560
02:53:42,320 --> 02:53:48,760
现在我们转到下一个元素，下一个元素是2，所以2乘以2等于4。
two over here now we move to the next element the next element is two so two multiplied by two we

1561
02:53:48,760 --> 02:53:55,160
得到4，下一个元素是3，3乘以2等于6，就是这样。
get a four the next one is three three multiplied by two so we get a six right over here and we

1562
02:53:55,160 --> 02:54:01,240
还有一个例子就在这里，在这种情况下，这是一个关键字列表，这个函数会对键值对进行模式匹配，并将值从正数变为负数。
have one more example right over here so in this case this is a keyword list and what this function

1563
02:54:01,240 --> 02:54:06,880
这个函数会对键和值的对进行模式匹配，并简单地改变值。
is doing it is pattern matching on the key and value pairs and it is simply changing the value

1564
02:54:06,880 --> 02:54:14,740
从正数变为负数，因此对于第一次迭代，你的键是a的项，然后将其值变为负数。
from a positive to a negative number so for the first iteration your key is the item of a and the

1565
02:54:14,740 --> 02:54:21,420
是一个，这个函数正在做的是返回一个负值，所以我们有
is one and what this function is doing it is returning back a negative value so we have

1566
02:54:21,420 --> 02:54:27,760
这里右边是负一，用于下一次迭代，键是b的项，值是两个
minus one right over here for the next iteration the key is the item of b and the value is two

1567
02:54:27,760 --> 02:54:34,420
在这里我们只是翻转符号，这就是为什么我们得到负二在这里，让我们看看
and here we are simply flipping the sign so that's why we get minus two right over here so let us see

1568
02:54:34,420 --> 02:54:40,340
我们如何通过使用我们的列表来实现这个函数，所以让我们回到我们的代码编辑器和
how we can implement this function by using our list so let us go back to our code editor and

1569
02:54:40,340 --> 02:54:47,080
在这里，让我们创建一个叫做map的新函数，看看我们如何实现这个功能
here let us create a new function called as map and let us see how we can implement this functionality

1570
02:54:47,080 --> 02:54:53,460
所以这个函数将接受三个参数，第一个是我们的元素
so this function is going to accept three parameters the first is for our elements the

1571
02:54:53,460 --> 02:55:00,020
第二个是函数，第三个显然是我们的累加器，还让我们设置一下
second one is for the function and the third one is obviously our accumulator and also let us set

1572
02:55:00,020 --> 02:55:06,180
累加器是一个空列表，现在在继续之前，我想给你展示一件事
the accumulator to be a blank list now before we can go ahead i wanted to show you one more thing

1573
02:55:06,180 --> 02:55:12,660
我们在模块中定义的所有这些函数，所以这个sum的函数
all of these functions that we are defining inside the module so this function of sum of

1574
02:55:12,660 --> 02:55:19,260
一些简单的尾递归反转所有这些函数都被称为命名函数
some simple sum of tail recursive reverse all of these functions are called as named functions

1575
02:55:19,260 --> 02:55:24,480
它们被称为命名函数，因为所有这些函数都属于一个模块
and they're called named functions because all of these functions belong to a module

1576
02:55:24,480 --> 02:55:31,260
而在我们的例子中，模块被称为tutorials.list，但是对于这个map函数来说
and in our case the module is called as tutorials dot list but in case for this function of map

1577
02:55:31,260 --> 02:55:38,340
我们传递了一个匿名函数，所以这个函数不属于任何模块，所以让我们看看我们如何使用匿名函数
we are passing an anonymous function so this function does not belong to any module so let

1578
02:55:38,340 --> 02:55:43,960
看看我们如何与匿名函数一起工作，我们可以这样做
us see how we can work with our anonymous functions as well so what we can do is either we can create

1579
02:55:43,960 --> 02:55:49,740
我们可以在需要的地方创建一个匿名函数，或者我们也可以将其单独定义
an anonymous function right where we require or we can define it separately as well so suppose

1580
02:55:49,740 --> 02:55:56,520
我们定义一个名为double的函数，我们可以说这是一个匿名函数
we define a function called as double and we can say that this is going to be a anonymous function

1581
02:55:56,520 --> 02:56:03,020
这个函数接受一个元素，并简单地返回该元素乘以2的结果
and this function accepts some element and it simply returns that element multiplied by two

1582
02:56:03,020 --> 02:56:10,540
现在记住语法，开头是fn，代表函数，结束位于
now remember the syntax the opening is by fn that stands for the function the end happens with your

1583
02:56:10,540 --> 02:56:16,980
在这里结束块，为了使用这个函数，我们必须使用点符号
end block right over here now in order to use this function we have to use a dot notation so in order

1584
02:56:16,980 --> 02:56:26,300
为了调用这个函数，我们可以说我们想调用double的匿名函数，但是我们
to invoke this function we can say that we want to invoke the anonymous function of double but we

1585
02:56:26,300 --> 02:56:32,060
因为这是一个匿名函数，所以我们必须使用点表示法，记住这一点
have to use the dot notation since this is an anonymous function so keeping this thing in mind

1586
02:56:32,060 --> 02:56:38,420
让我们回到我们的代码编辑器，让我滚动到函数定义的位置，就在这里
let us go back to our code editor so let me scroll down to our function definition and here it is

1587
02:56:38,840 --> 02:56:44,960
像往常一样，首先让我们考虑基本情况，让我复制粘贴一下，基本情况是
so as usual first let us think about the base case so let me just copy and paste so the base

1588
02:56:44,960 --> 02:56:51,640
如果元素为空，那就是一个空列表，这时我们只需要
case would be in case the elements are blank that means it's just a blank list at that time we simply

1589
02:56:51,640 --> 02:56:57,340
想要返回累加器，我们可以说do和我们的累加器，现在这里发生了什么
want to return back the accumulator so we can say do and our accumulator now here what happens is

1590
02:56:57,340 --> 02:57:03,000
我们不需要这个参数，还有一件事可以做，因为我们不使用这个函数
we don't need this argument and we can do one more thing since we are not using the function we can

1591
02:57:03,000 --> 02:57:08,920
通过使用下划线来忽略它，所以这个下划线的意思是我们只是想忽略
ignore it by using an underscore so what this underscore means is we simply want to ignore the

1592
02:57:08,920 --> 02:57:15,140
在我们的基本情况下，函数的值是什么，接下来让我们来看看我们的递归情况，让我再来一次
value of function in our base case next let us have a look at our recursive case so let me again

1593
02:57:15,140 --> 02:57:22,860
像往常一样复制和粘贴在这里，让我模式匹配头部和尾部，接下来是我们的函数
copy and paste here as usual let me pattern match on our head and our tail the next is our function

1594
02:57:23,380 --> 02:57:29,220
由于这是一个尾递归函数，我们每次都必须调用自己，所以首先让我们
and since this is a tail recursive function we have to call ourselves back each time so first let

1595
02:57:29,220 --> 02:57:34,020
忽略第一个值，稍后再讲。接下来的参数是用于
me ignore the first value i'll come to this a little later now the next argument is for the

1596
02:57:34,020 --> 02:57:39,180
对于每次迭代，我们只需要按原样传递函数，不需要做任何处理
function and for each iteration we simply have to pass the function as it is we don't have to do

1597
02:57:39,800 --> 02:57:46,440
现在第三个参数是我们收集累加器的地方，累加器内部我们想要做什么？
now the third is where we collect our accumulator now inside the accumulator what do we want to do

1598
02:57:46,440 --> 02:57:53,020
我们只是想要拿到这个函数，并在头部上应用这个函数，现在记住
is we simply want to take this function and we want to apply this function on our head now remember

1599
02:57:53,020 --> 02:57:58,660
因为这是一个匿名函数，我们可以使用点语法，所以我们可以说首先我们
that since this is an anonymous function we can use the dot syntax so we can say here first we

1600
02:57:58,660 --> 02:58:04,280
想要拿到这个函数并使用点语法，然后我们想要将这个函数应用在头部
want to take the function and use the dot syntax and we want to apply this function on our head

1601
02:58:04,280 --> 02:58:10,060
我们只想在后面附加上我们的累加器，现在让我们来看第一个参数
and we simply want to append our accumulator at the back now let us come to the first argument

1602
02:58:10,060 --> 02:58:16,140
现在既然我们已经使用了头部，剩下的就是传递尾部了，就这样，让我
now since we have used the head the only thing left is to pass the tail and that's it let me

1603
02:58:16,140 --> 02:58:23,080
保存文件，然后让我们打开我们的ix，让我们进入我们的ix，并让我清理一切
save the file and let us open up our ix let us go inside our ix and let me clear up everything

1604
02:58:23,080 --> 02:58:30,520
然后让我们试试，我们可以说教程.列表.映射，我们可以说我们的映射是一个
and let us try it out so we can say tutorials dot list dot map and we can say that our map is one

1605
02:58:30,520 --> 02:58:37,180
和三，我们要传递的函数是相同的，让我们取元素并且
and three and the function that we want to pass is the same one let us take the element and for

1606
02:58:37,180 --> 02:58:44,760
每个元素，让我们简单地乘以二，不要忘记结尾，就这样，我们得到了答案
each element let us simply multiply by two don't forget the end and that's it and we get the answer

1607
02:58:44,760 --> 02:58:51,140
但是正如你所看到的，顺序不对，发生了什么事，是我们把列表反转了
back but as you can see the order is not right what has happened is we have reversed the list

1608
02:58:51,140 --> 02:58:57,080
同样，这个三是正确的，所以三乘以二应该是六，但在我们的情况下
as well so this three is right over here so three multiplied by two it should be six but in our case

1609
02:58:57,080 --> 02:59:03,500
是第一个元素，两乘以二，我们在这里有四，而对于第一个元素是一乘以
is the first element and two into two we have four over here and for the first element is one into

1610
02:59:03,500 --> 02:59:09,680
二，我们在这里有两个，但正如你所看到的，这不是正确的答案
two and we have two right over here but as you can see that this is not the right answer we have

1611
02:59:09,680 --> 02:59:16,500
我们也反转了元素的顺序，所以我们可以做的是，首先我们可以调用我们的tutorials dot
reversed the order of our elements as well so what we can do is first we can call our tutorials dot

1612
02:59:16,500 --> 02:59:24,320
list dot reverse，在其中让我们传递我们的map函数，让我复制并粘贴过来
list dot reverse and inside this let us pass our map function let me just copy and paste it over

1613
02:59:24,320 --> 02:59:31,460
现在我们可以看到我们有正确的答案二四和六，但正如你所看到的
and now we can see that we have the right answer two four and six but as you can see that this

1614
02:59:31,460 --> 02:59:38,100
语法可能会让人困惑，所以让我向您介绍管道运算符，让我们粘贴map
syntax can be confusing so let me introduce you the pipeline operator so let us paste the map

1615
02:59:38,100 --> 02:59:44,660
在这里有一个函数，我们可以看到我们只是想要获取这个map函数的输出，
function over here and we can see that we simply want to take the output of this map function and

1616
02:59:44,660 --> 02:59:51,080
我们想要将该输出传递给新的函数，新的函数是我们的tutorials.list，
we want to pipe that output inside the new function and the new function is our tutorials dot list

1617
02:59:51,080 --> 02:59:58,740
dot reverse，现在我们不需要指定参数，管道操作符会发生什么
dot reverse now here we don't need to specify the arguments what happens is the pipeline operator

1618
02:59:58,740 --> 03:00:05,220
简单地接受前面语句的输出，并将该输出传递给我们的函数，
simply takes the output of the previous statement and it simply passes that output inside our

1619
03:00:05,220 --> 03:00:11,500
作为第一个参数，所以让我们按下回车键，看看发生了什么，正如我们所预期的那样
function as the first argument so let us press enter and let us see what's happening so as expected

1620
03:00:11,500 --> 03:00:19,120
我们得到了正确的答案两个四个和六个，让我来澄清一下，让我们再做一些，例如
we get the right answer back two four and six let me clear it up let us do some more so for example

1621
03:00:19,120 --> 03:00:25,420
如果您想要反转相同的列表，那么我们可以调用tutorials.list.reverse，假设
if you want to reverse the same list so we can invoke tutorials dot list dot reverse and suppose

1622
03:00:25,420 --> 03:00:32,720
在我们的例子中，列表是一个两个三个和四个，现在我们可以不使用这种语法，我们可以做的是
in our case the list is one two three and four now instead of using this syntax what we can do is

1623
03:00:32,720 --> 03:00:39,180
我们可以先获取我们的元素，我们可以使用管道操作符，所以我们可以说我想要你
we can first take our elements here we can use the pipe operator so we can say that i want you

1624
03:00:39,180 --> 03:00:45,580
获取所有这些元素，并将它们传递给我的tutorials.list.reverse函数
to take all of these elements and i want you to pass them to my tutorials dot list dot reverse

1625
03:00:45,580 --> 03:00:52,080
所以发生的是，如果我们有多个转换，我们可以使用这个管道操作符
so what happens is we can use this pipeline operator in case if we have multiple transformations

1626
03:00:52,080 --> 03:00:59,440
所以让我们再次使用相同的例子，在这里让我们创建一个匿名函数称为
so let us use the same example one more time here let us create an anonymous function called as

1627
03:00:59,440 --> 03:01:05,060
double，我们想要做的就是简单地取出元素并将其返回
double and what we want to do is we simply want to take the element and we want to return that

1628
03:01:05,060 --> 03:01:11,200
乘以二的元素，现在让我们看看如何使用管道操作符，例如
element multiplied by two and now let us see how we can use the pipeline operator so for example

1629
03:01:11,200 --> 03:01:17,400
我们有一个列表，像这样的一个、二、三和四，我们可以拿这些元素
we have a list like this one two three and four and what we can do is we can take these elements

1630
03:01:17,400 --> 03:01:25,600
我们可以将这些元素传递给我们的函数tutorials.dot.list.dot.map，现在要记住
and we can pipe these elements to our function of tutorials dot list dot map now remember that the

1631
03:01:25,600 --> 03:01:32,020
map函数接受两个参数，元素和函数，现在这里发生的是因为
function of map accepts two parameters the elements and the function now here what happens is since

1632
03:01:32,020 --> 03:01:38,500
我们使用了管道操作符，这些元素会自动传递给map函数
we are using the pipeline operator these elements are passed automatically to the function of map

1633
03:01:38,500 --> 03:01:44,600
而且管道操作符总是将这些元素作为第一个参数传递，所以由于我们有
and the pipeline operator always passes these elements as the first argument so since we have

1634
03:01:44,600 --> 03:01:50,320
第一个参数，我们只需传递第二个参数，所以我们可以说我们想要
the first argument we simply have to pass the second argument so here we can say that we want

1635
03:01:50,320 --> 03:01:56,120
传递名为double的匿名函数，对于累加器，我们不需要传递任何值
to pass the anonymous function called as double and for the accumulator we don't have to pass any

1636
03:01:56,120 --> 03:02:02,080
因为累加器的默认值是一个空列表，所以不需要传递值，让我们看看这个的输出
value because the default value for the accumulator is an empty list so let us see the output of this

1637
03:02:02,080 --> 03:02:08,660
所以我们得到了8、6、4和2的输出，现在我们可以采用完全相同的方式
so we get the output of eight six four and two now what we can do is we can take the exact same

1638
03:02:08,660 --> 03:02:14,560
表达式，并将map函数的输出传递给我们的reverse函数，这样我们就可以使用
expression and we can pipe the output of the map function to our reverse function so we can use

1639
03:02:14,560 --> 03:02:21,540
tutorials.list.reverse，这次我们得到了预期的答案：2、4、6和8
tutorials dot list dot reverse and this time we get the expected answer as two four six and eight

1640
03:02:21,540 --> 03:02:27,780
现在，我们可以使用内置模块，而不是使用list.reverse，如果我们进入
now instead of using the list dot reverse in fact we can use the inbuilt module so if we go to

1641
03:02:27,780 --> 03:02:34,300
enum模块，所以在这里我们可以说我们想将输出传递到enum
the module of enum so here we can say that we want to pipe the output into enum dot

1642
03:02:34,300 --> 03:02:40,860
reverse，我们得到了完全相同的答案，所以我们可以使用内置函数，而不是使用我们定义的函数
reverse and we get the exact same answer back so instead of using our defined function we can use

1643
03:02:40,860 --> 03:02:46,780
也可以使用内置函数，正如你所看到的，这个管道操作符非常方便，无论何时
the inbuilt function as well so as you can see that this pipeline operator is very handy whenever

1644
03:02:46,780 --> 03:02:53,680
我们想进行多个转换，让我们回到map函数，我们想要的是
we want to do multiple transformations so let us go back to our function of map and what we want

1645
03:02:53,680 --> 03:03:00,940
要做的就是将这个累加器传送到我们的反转函数中，就这样，现在如果我们打开
to do is this accumulator has to be piped to our function of reverse and that's it now if we open

1646
03:03:00,940 --> 03:03:08,560
打开我们的终端，重新编译教程.列表，清理一切，这一次如果
up our terminal let us recompile tutorials dot list let us clear up everything and this time if

1647
03:03:08,560 --> 03:03:16,620
我有一个包含1、2、3和4的列表，如果我只是将这个列表传送到教程.列表.点
i have a list of one two three and four and if i just pipe this list to tutorials dot list dot

1648
03:03:16,620 --> 03:03:23,300
映射，让我们传递一个匿名函数，这样我们就可以说让我们取出那个元素，然后让我们乘以
map and let us pass an anonymous function so we can say let us take that element and let us multiply

1649
03:03:23,300 --> 03:03:30,160
这次将元素乘以3，就这样，我们得到了正确的输出，现在再回到
element by three this time and that's it we get the right output back now again coming back to

1650
03:03:30,160 --> 03:03:35,540
我们的代码编辑器，你可以使用这个管道运算符，或者你可以使用转换语法
our code editor either you can use this pipeline operator or you can use the conversion syntax

1651
03:03:35,540 --> 03:03:41,380
这样你可以简单地调用反转函数，传递累加器的元素，让我来
so you can simply call the function of reversed pass the element of accumulator and let me take

1652
03:03:41,380 --> 03:03:47,380
拿出这个，我们还要看一下如何编写这个函数的规格，所以让我们使用
out this one let us also see how to write the specifications for this function so let us use

1653
03:03:47,380 --> 03:03:53,600
映射函数的规格的模型属性，现在第一个参数
the model attribute of specifications for the function of map now the first parameter

1654
03:03:53,600 --> 03:04:00,500
将是一个列表，类型可以是任何东西，所以任何东西都可以放在这里，下一个
elements is going to be a list and the type can be of anything so anything goes over here the next

1655
03:04:00,500 --> 03:04:06,100
现在是一个函数，为了表示这是一个函数，我们可以在这里使用括号
is a function now in order to denote that this is a function we can use brackets over here

1656
03:04:06,100 --> 03:04:12,880
在这里，我们可以说这个函数接受一个输入，输入可以是任何类型的，然后它
and here we can say that this function accepts an input the input can be of any type then it

1657
03:04:12,880 --> 03:04:19,420
返回值，并且还会返回一些值，所以这就是我们定义的方式
that value and it also gives back some kind of a value back so this is how we can define

1658
03:04:19,420 --> 03:04:24,360
函数类型，下一个是累加器，累加器又是
the function type the next one is for the accumulator and again accumulator is going to

1659
03:04:24,360 --> 03:04:31,220
任何类型的列表，返回类型也将是我们的任何类型的列表，好了，就这些
be a list of any now the return type is also going to be our list of any well that's it for

1660
03:04:31,220 --> 03:04:36,760
这个，我会在下一个视频中和你见面，现在让我们看看如何连接或如何
this one and i will catch you in the next video now let us see how we can concat or how we can

1661
03:04:36,760 --> 03:04:43,500
将两个列表合并在一起，首先让我在终端里演示一下，假设我们有
add two lists together so first let me show you inside the terminal so suppose we have

1662
03:04:43,500 --> 03:04:50,680
一个像这样的列表，其中包含1、2和3，现在我们想要添加另一个列表，为了添加我们的
one list like this one two and three and we want to add one more list now in order to add our

1663
03:04:50,680 --> 03:04:58,540
要使用双加号，下一个列表将是4、5和6，在这里
contact we have to use the double plus and the next list would be four five and six and here

1664
03:04:58,540 --> 03:05:05,040
我们得到了合并后的列表，让我们看看如何编写一个连接函数来实现这一点
we get the combined list back so let us see how we can write a contact function to do exactly this

1665
03:05:05,550 --> 03:05:12,500
现在为了添加或连接，我们有两个列表，例如第一个列表是一二三
now in order to add or concat we have two lists so for example the first list is one two and three

1666
03:05:12,500 --> 03:05:19,940
还有一个列表，是四五六，所以我们实际上想要做的是
and we have one more list four five and six so essentially what we want to do is we want to

1667
03:05:19,940 --> 03:05:26,640
取出最后一个元素，并将该元素插入到下一个列表的头部，但是
take the last element and we want to insert that last element at the head of the next list but

1668
03:05:26,640 --> 03:05:32,360
取出最后一个元素不是高效的，因为我们需要遍历整个列表，并且
taking the last element is not efficient because we have to traverse through the entire list and

1669
03:05:32,360 --> 03:05:38,560
到达最后一个元素，所以我们可以简单地将第一个列表反转，使得第一个
go to the last element so what we can do is we can simply reverse the first list so the first

1670
03:05:38,560 --> 03:05:44,720
列表变成了这样的三二一，对于每一次迭代，我们只需要取出
list becomes something like this three two and one and for each iteration we simply have to take

1671
03:05:44,720 --> 03:05:51,220
头部并将其插入到我们的第二个列表的头部位置，所以对于第一个
out the head and insert it at the head position for our list number two as well so for the first

1672
03:05:51,220 --> 03:05:57,640
迭代，我们插入三，对于下一次迭代，我们插入二，最后一次迭代我们插入一
iteration we insert three for the next iteration we insert two and for the last one we insert one

1673
03:05:57,640 --> 03:06:03,860
当我们插入一时，这个列表就变成了一个空列表，所以这就是我们要做的
and by the time we insert one this list becomes an empty list so this is how we are going to

1674
03:06:03,860 --> 03:06:09,780
实现我们的连接函数，所以让我们在这里定义这个函数，我们可以说定义
implement our concat function so let's define the function right over here so we can say define

1675
03:06:09,780 --> 03:06:16,620
现在，concat函数接受两个参数，我们可以将第一个列表称为源列表，第二个列表称为目标列表
concat now this function accepts two arguments we can call the first list as our source the second

1676
03:06:16,620 --> 03:06:23,340
列表可以是我们的目标列表，对于这个函数，我们不需要一个累加器，第二个列表
list can be our destination now for this function we don't need an accumulator the second list

1677
03:06:23,340 --> 03:06:29,140
它本身就像一个累加器，所以我要做的是编写一个辅助函数
itself acts like an accumulator so here what i'm going to do is i'm going to write an auxiliary

1678
03:06:29,140 --> 03:06:34,700
所以首先让我们编写这个函数，然后我们可以定义它，这样我们就可以简单地调用这个函数
function so first let us write the function and then we can define it so we can simply call the

1679
03:06:34,700 --> 03:06:41,000
将辅助函数称为concat函数，现在记住，就像我刚才说的几分钟
auxiliary function as concat underscore function now remember as i just said a couple of minutes

1680
03:06:41,000 --> 03:06:47,200
首先要将这个列表反转，我们可以在函数定义的内部完成
back first we have to reverse this list and we can do that right inside our function definition

1681
03:06:47,200 --> 03:06:53,160
所以在这里我们可以说，让我们取出源列表，然后将其传递给我们的函数
so here we can say that let us take the source list and we simply want to pipe it to our function

1682
03:06:53,160 --> 03:07:00,880
接下来是我们的目标列表，我们希望目标列表保持不变，现在我们可以
reverse the next is our destination list and we want our destination list as it is so now we can

1683
03:07:00,880 --> 03:07:06,280
继续定义这个辅助函数，所以我们可以说我们想创建一个函数
go ahead and define this auxiliary function so here we can say that we want to create a function

1684
03:07:06,280 --> 03:07:13,200
名为concat_func的函数，它接受两个参数，第一个列表称为源列表，第二个列表称为目标列表
called as concat func this accepts two parameter the first list called as source the second list

1685
03:07:13,200 --> 03:07:20,660
称为目标，现在作为我们的基本情况，我们可以简单地在源上进行模式匹配，因此在
called as destination now here as our base case we can simply pattern match on our source so in

1686
03:07:20,660 --> 03:07:27,680
如果源为空，我们只想返回我们的目标，然后
the case the source is blank at that time we simply want to return back our destination the next let

1687
03:07:27,680 --> 03:07:34,120
让我们看看如何定义递归情况，因此我们可以说我们想再次定义concat函数
us see how we can define the recursive case so we can say we want to define concat one more time

1688
03:07:34,120 --> 03:07:39,620
在这里，我们可以简单地对第一个列表进行模式匹配，所以对于第一个列表，我们可以进行模式匹配
and here we can simply pattern match on the first list so for the first list we can pattern match

1689
03:07:39,620 --> 03:07:47,320
对头部进行模式匹配，对尾部进行模式匹配，第二个参数是我们的目标列表，让我们看看如何
on the head and for the tail the second parameter is for our destination list and let us see how

1690
03:07:47,320 --> 03:07:53,940
可以定义这个逻辑，现在对于每一次迭代，我们想要回调自己，对吧
can define the logic for this one now for each iteration we want to call ourselves back right

1691
03:07:53,940 --> 03:08:00,600
在这里，首先让我们定义第二个参数，因此对于每次迭代，我们想要做的就是简单地
here first let us define the second parameter so for each iteration what we want to do is we simply

1692
03:08:00,600 --> 03:08:07,060
想要获取头部，然后将我们的目标列表附加到这个上面，现在最后一件事情
want to take the head and we want to append our destination list to this one now the last thing

1693
03:08:07,060 --> 03:08:13,900
要做的就是将尾部作为我们的第一个参数传递，让我打开我的终端
to do is we simply have to pass the tail for our first argument so let me open up my terminal let

1694
03:08:13,900 --> 03:08:20,860
让我进入我的ix并清理一切，现在我们可以说我们想要去教程
me go inside my ix and let me clear up everything now here we can say that we want to go to tutorials

1695
03:08:20,860 --> 03:08:29,560
点号列表点号连接现在第一个列表将是一二三第二个列表将是四
dot list dot concat now the first list would be one two and three the second list would be four

1696
03:08:29,560 --> 03:08:36,880
五和六就是这样我们得到了期望的输出最后要做的是我们只是想要
five and six and that's it we get back the desired output the last thing to do is we simply want to

1697
03:08:36,880 --> 03:08:42,740
添加我们的类型说明所以让我删除注释我不需要注释在这里我们可以
add our type specification so let me take out the comment i don't need the comment and here we can

1698
03:08:42,740 --> 03:08:49,500
规范的模型属性用于我们的连接函数的规范第一个参数是一个列表
the model attribute of specifications for our function of concat the first parameter is a list

1699
03:08:49,500 --> 03:08:56,660
并且元素是任意的下一个参数也是一个列表并且元素是任意类型
and the elements are any the next parameter is also a list and the elements are of any type

1700
03:08:56,660 --> 03:09:04,480
这将返回一个列表类型可以是任意类型接下来是我们的连接函数的辅助函数
and this gives back a list and the types are any next coming to our helper function of concat

1701
03:09:04,480 --> 03:09:11,400
下划线函数现在这个函数只用于内部使用所以我们能做的是
underscore func now this function is intended only for internal use so what we can do is we

1702
03:09:11,400 --> 03:09:17,380
辅助函数是私有的所以在这里我们可以写def而不是只写def
the auxiliary function to be private so here instead of just writing def we can write def and

1703
03:09:17,380 --> 03:09:23,480
p这意味着这将成为一个私有函数就这样让我们来看一下
p that means that this is going to be a private function and that's it let's have a look at the

1704
03:09:23,480 --> 03:09:29,840
我们列表中的最后一个函数这个函数被称为flat map坦率地说我是
last function inside our list and this function is called as flat map now to be frank i was

1705
03:09:29,840 --> 03:09:35,180
有点困惑，我是否应该在这个系列中包含这个函数，然后我想好了，为什么不呢
slightly confused should i include this function in this series or not then i thought okay why not

1706
03:09:35,180 --> 03:09:40,720
让我添加这个，让我们看看它的运行情况，首先让我给你展示一下我所说的平坦是什么意思
let me add this one and let us see how it goes so first let me show you what do i mean by a flat

1707
03:09:40,720 --> 03:09:46,860
map，所以让我们回到终端，这里让我们看一下我们枚举模块的文档
map so let us go back to our terminal and here let us see the documentation for our enum module

1708
03:09:46,860 --> 03:09:54,140
以及 flat map 函数，所以这个函数的作用是接受一个枚举，还接受一个
and the flat map function so what this function does is it accepts an enum and it also accepts

1709
03:09:54,140 --> 03:10:00,560
函数，现在 flat map 就是关于你两个函数的组合，也就是说
one function now flat map is all about the combination of your two functions that is it's

1710
03:10:00,560 --> 03:10:06,740
它是你的 map 和 concat 的组合，这里还有一个例子，我们得到了一个输入
a combination of your map and concat and here we have one more example as well so we get an input

1711
03:10:06,740 --> 03:10:13,620
作为一个列表，在第一次迭代期间，我们得到了一个 a 的项，我们返回一个包含 a 和 a 的列表
as a list so during the first iteration we get an item of a and we give back a list of a and a

1712
03:10:13,620 --> 03:10:18,700
但是如果你看这里，我们没有一个 a 的列表，我们也没有一个单独的 b 的列表
but if you see right over here we don't have a list of a we don't have a separate list for b

1713
03:10:18,700 --> 03:10:25,060
我们也没有一个单独的 c 的列表，这是因为我们把整个列表变成了平坦的，所以让
and we don't have a separate list of c and that's because we have flattened the entire list so let

1714
03:10:25,060 --> 03:10:30,460
我们来看看我们如何使用递归函数来实现这一点，现在你一定在想我们为什么要这样做
us see how we can do this by using our recursive functions now you must be thinking why are we

1715
03:10:30,460 --> 03:10:35,480
实施那么多已经存在于标准库中的函数，所以答案是
implementing so many functions which are already there inside the standard library so the answer

1716
03:10:35,480 --> 03:10:40,000
我希望你真正熟悉递归，并且从下一个视频开始
is i want you to really get comfortable with the recursion and from the next video we will

1717
03:10:40,000 --> 03:10:45,680
看看我们如何使用所有内置模块，但对于最后一个，让我们看看如何
see how we can use all of the inbuilt modules but for this last one let us see how we can

1718
03:10:45,680 --> 03:10:51,540
通过使用我们的尾递归函数来实现此功能，让我们回到我们的代码
implement this functionality by using our tail recursive function so let us go back to our code

1719
03:10:51,540 --> 03:10:59,440
在这里，让我们创建一个叫做 flat map 的函数，我们可以说定义我的 flat map
editor and here let us create a function called as flat map so we can say define my flat map

1720
03:10:59,440 --> 03:11:04,560
这个函数接受两个参数，所以如果我们回到文档，我们可以看到
so this function accepts two parameters so if we go back to the documentation we can see that

1721
03:11:04,560 --> 03:11:10,400
这个接受两个参数，第一个参数是元素，第二个参数是
this accepts two parameters the first argument is for the elements the second argument is for

1722
03:11:10,400 --> 03:11:16,360
函数，所以让我们在这里做同样的事情，我们可以说第一个参数是元素
the function so let us do the same thing here we can say that the first argument is for elements

1723
03:11:16,360 --> 03:11:22,760
第二个参数是一个函数，现在我们还需要一个累加器的参数
the second argument is for a function now we also need one more argument for our accumulator

1724
03:11:22,760 --> 03:11:27,440
因为我们想要做的就是在我们的累加器中收集输出
because what we want to do is we want to collect the output inside our accumulator

1725
03:11:28,080 --> 03:11:33,720
所以在这里我们可以说我们也想要一个累加器和一个默认值
so here we can say that we also want to have an accumulator and we want to have the default value

1726
03:11:33,720 --> 03:11:40,720
以及一个空列表的默认值现在让我复制粘贴现在让我们考虑一下我们的基本情况
of an empty list as well now let me copy and paste now let us think of our base case so the

1727
03:11:40,720 --> 03:11:47,120
基本情况非常简单，如果元素是一个空列表，那么我们不需要这个函数
base case is very simple in case the elements is a bank list at that time we don't need this function

1728
03:11:47,120 --> 03:11:52,340
所以你可以在这里放一个下划线，或者你可以直接用整个函数替换
so either you can put an underscore over here or you can simply replace the entire function with

1729
03:11:52,340 --> 03:11:58,500
只是一个下划线，它们都是有效的语法，在这种情况下，我们只是想返回
just an underscore both of them are valid syntax and in this case we simply want to return back

1730
03:11:58,500 --> 03:12:04,420
累加器的值，现在让我们再复制粘贴一次，这将是我们的
the accumulator as it is now let us copy and paste one more time and this is going to be our

1731
03:12:04,420 --> 03:12:09,920
递归情况，现在在这种情况下我们也需要我们的函数，并且对于第一个参数
recursive case now in this case we need our function as well and for the first argument

1732
03:12:09,920 --> 03:12:17,160
让我们对头部和尾部进行模式匹配，对于每次迭代我们都想要调用自己
let us pattern match on our head and our tail and for each iteration we want to call ourselves back

1733
03:12:17,160 --> 03:12:22,520
所以让我们现在调用flat map，如你所知，第一个参数应该是我们的尾部，因为对于
so let us call the flat map back now as you know the first argument should be our tail because for

1734
03:12:22,520 --> 03:12:27,880
每次迭代我们都想要取出头部，所以第一个参数变成了尾部，第二个参数变成了头部
each iteration we want to take out the head so the first argument becomes the tail the second

1735
03:12:27,880 --> 03:12:33,060
我们的论点是我们想按原样传递函数，我们不想改变函数，现在让我们
argument is we want to pass the function as it is we don't want to change the function now let us

1736
03:12:33,060 --> 03:12:39,020
看看我们可以将什么作为第三个参数传递，现在如果你回到我们的文档中，清楚地说明了
see what we can pass as our third argument now if you go back to our documentation it is clearly

1737
03:12:39,020 --> 03:12:45,720
说这是我们的map和concat的组合，所以我们不要动脑筋，让我们遵循
saying that this is a combination of our map and concat so let's not use our brain and let's follow

1738
03:12:45,720 --> 03:12:57,500
这些人说的完全一样，所以我们想做的是简单地连接和
exactly what these guys are saying so here what we want to do is we simply want to concat and the

1739
03:12:57,500 --> 03:13:05,100
我们想将这个匿名函数应用于头部，现在请记住，由于函数是一个
function we want to apply this anonymous function on the head now remember since function is an

1740
03:13:05,100 --> 03:13:11,720
匿名函数，我们可以使用点运算符来调用它，所以我们可以说function dot，让我们
anonymous function we can invoke it by using the dot operator so we can say function dot and let us

1741
03:13:11,720 --> 03:13:18,260
将头部传递给这个函数，就这样我们已经实现了flat map函数，现在让我打开
pass head to this one and that's it we have implemented the flat map function now let me open

1742
03:13:18,260 --> 03:13:24,760
我的终端，让我们重新编译tutorials dot list的模块，让我清理屏幕
up my terminal let us recompile the module of tutorials dot list let me clear up the screen

1743
03:13:24,760 --> 03:13:31,460
让我们做一件事，让我们过来，让我复制所有这些东西，现在在这里面
and let's do one thing let us go over here and let me copy all of these things now here inside

1744
03:13:31,460 --> 03:13:38,480
在我们的终端中，我们可以说从tutorials dot list dot flat
map，让我们传递参数
our terminal we can say that from tutorials dot list dot flat map and let us pass the arguments

1745
03:13:38,480 --> 03:13:45,900
现在让我们试着比较一下输出，这里我们有与之完全相同的输出
and now let us try and compare the output so here we have the output which is exactly the same as

1746
03:13:45,900 --> 03:13:50,980
就在这里，这就是我们完成了这一节关于列表的部分
right over here so that brings us to the end of this section for the list now what we have done

1747
03:13:50,980 --> 03:13:56,240
在这一部分中，我们使用了标准库中的许多函数进行了实现
for this section is we have implemented a lot of functions from the standard library by using

1748
03:13:56,240 --> 03:14:01,040
在下一个视频中，我们将使用尾递归代替手动编写所有这些函数
tail recursion from the next video instead of writing all of these functions by hand

1749
03:14:01,040 --> 03:14:06,180
我们将尝试使用标准库中的函数，但现在就是这样
we will try and use the functions from the standard library but for now that's it and

1750
03:14:06,180 --> 03:14:11,820
我会在下一个视频中与你见面，嗨，恭喜你走到了这一步，到目前为止
i will catch you in the next one hi and congratulations for making it so far so till now

1751
03:14:11,820 --> 03:14:18,040
我们已经看到了很多递归，具体来说，我们已经看到了很多尾递归，现在整个
we have seen a lot of recursion specifically we have seen a lot of tail recursion now the whole

1752
03:14:18,040 --> 03:14:24,080
向你展示这么多递归的想法是我希望你习惯递归的概念
idea of showing you so much of recursion was i wanted you to get used to the idea of recursion

1753
03:14:24,080 --> 03:14:29,120
以及我们如何使用函数式编程，但前进时，不再编写所有的
and how we can use functional programming but moving forward instead of writing all of the

1754
03:14:29,120 --> 03:14:35,480
函数，我们将使用标准库中的函数，现在Elixir附带了
functions ourselves we will use the functions from the standard library now elixir ships with

1755
03:14:35,480 --> 03:14:42,180
有很多内置函数，你可以在模块中找到这些函数，比如枚举，然后我们有
a lot of inbuilt functions and you can find these functions inside modules such as enum then we have

1756
03:14:42,180 --> 03:14:47,960
为你的列表和关键字列表等创建单独的模块，这就是我们将要看到的，所以
separate model for your list and keyword list and so on so that's what we will see so the

1757
03:14:47,960 --> 03:14:53,180
本节是关于数据转换的，我们如何使用所有这些函数和方法
section is all about your data transformations how we can use all of these functions and how

1758
03:14:53,180 --> 03:14:59,160
我们可以转换数据以获得我们想要的输出，所以我会在下一个视频中见到你
we can transform data to get our desired outputs so i will catch you right in the next video till

1759
03:14:59,160 --> 03:15:06,280
那么再见，现在让我们看看我们如何开始使用我们的结构体和内置模块，所以
then bye now let us see how we can start working with our structs and the inbuilt modules so the

1760
03:15:06,280 --> 03:15:12,200
我想要做的第一件事是让我们在我们的lib文件夹中创建一个新文件夹，我们可以叫它
first thing which i want to do is let us create a new folder inside our lib and we can call that

1761
03:15:13,240 --> 03:15:20,080
结构体，在这个文件夹里让我再创建一个名为seven wonders的文件
structs and inside of this folder let me create one more file by the name of seven wonders let

1762
03:15:20,080 --> 03:15:25,580
我折叠我的侧边栏，让我们看看我们可以用这个结构体做什么，第一件事通常是
me collapse my sidebar and let us see what we can do with this struct the first thing as usual

1763
03:15:25,580 --> 03:15:32,580
我们需要定义我们的模块，所以这将是我们的tutorials. structs. seven
wonders
we need to define our module so this would be our tutorials dot structs dot seven wonders

1764
03:15:32,580 --> 03:15:38,580
所以让我们使用def struct关键字来创建一个结构体，在这里我们需要指定字段
so let us create a struct by using the keyword of def struct here we need to specify the fields

1765
03:15:38,580 --> 03:15:43,640
对于我们的结构体，我们可以说第一个字段是七大奇迹的名称
for our struct so we can say that the first field would be the name of the seven wonders

1766
03:15:44,180 --> 03:15:50,840
而第二个字段将是那个七大奇迹所在的国家，现在我们可以进行一点小改进
and the second field would be the country of that seven wonder now we can do one slight improvement

1767
03:15:50,840 --> 03:15:56,740
我们还可以在这里初始化这些值，而不仅仅是传递一个普通的列表
we can also initialize the values right over here and instead of just passing a normal list

1768
03:15:56,740 --> 03:16:04,580
我们可以传递一个关键字列表，所以在这里我们可以说名称的默认值应该是一个空字符串
we can pass a keyword list so here we can say that the default value of name should be a blank

1769
03:16:04,580 --> 03:16:10,700
对于国家也是一样的情况，所以如果没有给出参数的话
string and the same thing happens for the country as well so in case the argument is not given

1770
03:16:10,700 --> 03:16:17,060
我们想把国家初始化为空字符串，现在让我们看看如何定义
we want to initialize the country to be a blank string now let us see how we can also define the

1771
03:16:17,060 --> 03:16:22,700
我们的结构体的类型规范，现在为了定义我们的结构体的类型，我们必须使用关键字
type specifications for our struct now for defining the type of our struct we have to use the keyword

1772
03:16:22,700 --> 03:16:29,620
类型，所以让我们在这里定义一个类型，让我们把类型称为t，所以这更像是
of type so let's define a type right over here and let us call type as t so this is more like

1773
03:16:29,620 --> 03:16:35,780
你的社区约定，你的t只是代表你的类型，在这里我们可以指定我们想要的
your community convention your t stands just for your type and here we can specify that we want

1774
03:16:35,780 --> 03:16:44,080
为我们的tutorials.structs.seven
wonders指定该类型，现在记住，这个结构体
to specify that type for our tutorials dot structs dot seven wonders now remember that the struct

1775
03:16:44,080 --> 03:16:50,200
始终采用模块的名称，这种情况下我们的模块名称是tutorials点
always takes the name of the module and in this case the name of our module is tutorials dot

1776
03:16:50,200 --> 03:16:55,940
structs点七个奇迹，因此默认情况下这将是我们结构的名称，既然如此
structs dot seven wonders so by default that's going to be the name of our struct and since this

1777
03:16:55,940 --> 03:17:01,180
这是一个结构体，让我们使用正确的语法，我们需要在这里放置我们的百分号符号和我们的
is a struct let us use the right syntax so we need to put our percent symbol over here and our

1778
03:17:01,180 --> 03:17:07,500
大括号，所以现在我们有了一个结构体，现在我们可以做的是输入这样一个长的名称可能很无聊
curly brackets so now we have a struct now what we can do is typing such a long name can be boring

1779
03:17:07,500 --> 03:17:13,640
所以我们可以简单地起一个别名，让我们创建一个顶部的别名，我们可以说我们只是想要
so we can simply alias this so let's create an alias of the top so we can say we simply want to

1780
03:17:13,640 --> 03:17:20,280
创建一个别名，我们可以在这里简单地拿出所有这些东西，现在在大括号里面
create an alias and here we can simply take out all of these things now inside the curly brackets

1781
03:17:20,280 --> 03:17:26,320
让我们为各个字段定义类型，所以在我们的七个奇迹的结构体中的第一个字段
let us define the types for the various fields so the first field inside our struct of seven wonders

1782
03:17:26,320 --> 03:17:34,660
是用于名称的，我们可以在这里定义类型为字符串，所以我们可以说字符串点t，所以
is for the name and here we can define the type to be of string so we can say string dot t so the

1783
03:17:34,660 --> 03:17:40,800
字符串的类型，下一个是用于国家的，同样国家将是字符串的类型
type of string the next one we have for the country and again the country is going to be of the type

1784
03:17:40,800 --> 03:17:47,870
所以这就是你如何为你的结构体定义类型规范的方法，下面让我们做一个
of string so this is how you define the type specifications for your struct next let us do one

1785
03:17:47,870 --> 03:17:53,950
让我们创建一个包含世界七大奇迹的列表，所以让我们创建一个简单的函数
thing let us create a list of all of the seven wonders so for this let us create a simple function

1786
03:17:53,950 --> 03:18:00,910
称为all的函数，该函数不接受任何参数，并返回你的列表。现在在函数内部
called as all so this function does not take anything and this returns your list now inside

1787
03:18:00,910 --> 03:18:06,450
在列表中，让我们初始化世界七大奇迹，所以我们可以说第一个奇迹是
this list let us initialize all of the seven wonders so we can say that the first seven wonder

1788
03:18:06,450 --> 03:18:12,430
泰姬陵，因为我来自印度，所以第一个必须是泰姬陵，你可以说
would be Taj Mahal so since i'm from india the first one has to be Taj Mahal and you can say

1789
03:18:12,430 --> 03:18:17,910
国家是印度，让我复制并粘贴剩下的六个奇迹
country is going to be india and let me just copy and paste all of the remaining six wonders

1790
03:18:17,910 --> 03:18:23,770
现在我们有了一个包含世界七大奇迹的好列表，接下来让我们看看如何
so now we have a nice list of all of the seven wonders of the world next let us see how we can

1791
03:18:23,770 --> 03:18:29,210
为这个新函数编写类型规范，我们可以使用model属性
also write the type specifications for this new function so here we can use the model attribute

1792
03:18:29,210 --> 03:18:35,310
根据我们的规范，我们希望为all函数定义规范，现在由于
of our specifications and we want to define the specifications for the function of all now since

1793
03:18:35,310 --> 03:18:40,170
这个函数不接受任何参数，你可以使用括号或者跳过它们
this function does not accept any parameters you can use the brackets or you can skip them

1794
03:18:40,170 --> 03:18:46,530
在这里我们还可以定义返回类型，返回类型是一个列表，其中的元素是
and here we can also define the return type now the return type is a list and the elements are of

1795
03:18:46,530 --> 03:18:51,490
这里我们定义了t的类型，并且指定了不同的参数。
the type of t so right over here we have defined the type of t and we have specified the different

1796
03:18:51,490 --> 03:18:57,630
这是我们引用的结构的参数，让我放一个分隔符。
parameters for our struct and that's what we are referencing right over here let me put a separator

1797
03:18:57,630 --> 03:19:04,170
在这里滚动一下，让我们看看如何开始使用我们的七个。
line over here let's scroll a little bit down and let us see how we can start working with our seven

1798
03:19:04,170 --> 03:19:10,150
所以我们在这里做一件事，让我们定义一个名为print names的函数，这样
wonders so here let us do one thing let us define a function called as print names so what this

1799
03:19:10,150 --> 03:19:16,290
函数将接受所有的奇观，并简单地打印出它们的名字。
function will do is it will accept all of the wonders and it will simply print out the names of

1800
03:19:16,290 --> 03:19:21,470
奇观的名字有很多，比如泰姬陵、佩特拉
the wonders so for example if we see we have different names so we have the Taj Mahal Petra

1801
03:19:21,470 --> 03:19:26,910
基督救世主等等。所以我希望你为这个函数做的是这个函数
Christ the Redeemer and so on so what I want you to do for this function is so this function is

1802
03:19:26,910 --> 03:19:32,590
要接受这个列表，并且我们只想看到名字，就这样
going to accept this list right over here and for the output we just want to see the names and that's

1803
03:19:32,590 --> 03:19:38,690
让我们看看现在如何实现这个函数，这一次不用写函数了
it so let us see how we can implement this function now this time instead of writing functions

1804
03:19:38,690 --> 03:19:46,370
让我们看看如何使用标准库，让我打开终端，这是第一个
let us see how we can use the standard library so let me open up my terminal and here the first

1805
03:19:46,370 --> 03:19:52,950
你想要检查的模块是枚举模块，所以我可以让我们调用帮助函数。
module that you would like to check is the module of enum so what I can do is let us call help and

1806
03:19:52,950 --> 03:19:58,910
让我们看一下枚举模块中的不同函数，所以如果我输入一个点并且
let us see what are the different functions inside the module of enum so if I put a dot and if I

1807
03:19:58,910 --> 03:20:05,910
按下tab键，我们可以看到这个内置模块有很多内置函数，现在我想要看一下
press tab and we can see that this inbuilt module has a lot of inbuilt functions now I want to see

1808
03:20:05,910 --> 03:20:13,050
一个非常特定的函数的文档，那就是“for each”函数，所以让我调用一下
documentation of a very specific function and that is this one for each so here let me call the

1809
03:20:13,050 --> 03:20:20,070
枚举模块的each函数的帮助，这个each函数接受两个参数，第一个参数是
help on enum dot each so this function of each accepts two parameters the first parameter is

1810
03:20:20,070 --> 03:20:27,070
用于枚举，第二个参数是用于函数，我们还有一个示例实现，所以在这里
for enum and the second one is for the function and we also have a sample implementation so here

1811
03:20:27,070 --> 03:20:34,090
我们可以看到第一个参数是一个列表，我们有一个简单的函数，所以发生的情况是
we can see that the first parameter is a list and we have a simple function so what's happening is

1812
03:20:34,090 --> 03:20:40,750
对于每次迭代，这个函数从列表中接收一个元素，所以对于第一次迭代
for each iteration this function receives an element from the list so for the first iteration

1813
03:20:40,750 --> 03:20:47,490
你的x是字符串"sum"，这个函数所做的就是简单地将它打印出来，这就是为什么
your x is the string of sum and what this function is doing it is simply printing it out that's why

1814
03:20:47,490 --> 03:20:54,550
我们在第二次迭代时得到了"sum"的输出，你的x变成了"example"，这就是正在发生的事情。
we have the output of sum for the second iteration your x becomes example and that is what is being

1815
03:20:54,550 --> 03:20:59,690
在这里打印出来，让我们看看如何使用这个内置的打印函数
printed out right over here so let us see how we can use this inbuilt function for printing out

1816
03:20:59,690 --> 03:21:06,030
我们七大奇迹的名称，让我们回到我们的代码编辑器，看看我们能做什么
of the names for our seven wonders so let us go back to our code editor and here what we can do

1817
03:21:06,030 --> 03:21:12,730
我们可以使用相同的函数，我们可以说enum dot each，现在我们的枚举将是我们的奇迹列表
is we can use the same function we can say enum dot each now our enum is going to be our list of

1818
03:21:12,730 --> 03:21:19,730
接下来，让我们定义我们的函数，对于每次迭代的函数，我们将要
our wonders next let us define our function and for the function for each iteration we are going

1819
03:21:19,730 --> 03:21:26,130
从我们的奇迹列表中接收一个奇迹，所以对于每次迭代，会发生的是
to receive one wonder from our list of wonders so for each iteration what's going to happen is

1820
03:21:26,130 --> 03:21:31,830
我们将接收一个奇迹，我们必须对奇迹做些什么，这就是结束
we are going to receive a wonder and we have to do something with the wonder and this is the end

1821
03:21:31,830 --> 03:21:38,190
我们的函数的代码块，由于我们只想打印出我们奇迹的名称，我们实际上可以
block for our function now since we just want to print the name of our wonder we can actually

1822
03:21:38,190 --> 03:21:44,030
在这里进行模式匹配，现在我们知道这个奇迹将是七个结构体的
pattern match right over here now we know that this wonder is going to be the struct of seven

1823
03:21:44,030 --> 03:21:53,930
奇迹，我们可以通过使用我们的map语法轻松进行结构体的模式匹配，所以让我们来做一下
wonders and we can easily pattern match on our structs by using our map syntax so let's do the

1824
03:21:54,650 --> 03:21:59,030
我们想要进行模式匹配，我们想要对name参数进行模式匹配
we want to pattern match and we want to pattern match on the parameter of name

1825
03:21:59,030 --> 03:22:05,710
而且我们想要将名称收集到一个名为name的变量中，对于每次迭代，我们只需要
and we want to collect the name inside a variable called as name and for each iteration we simply

1826
03:22:05,710 --> 03:22:12,030
想要将其打印出来，让我们将变量name放在这里，就这样，让我们打开
want to print it out and let us put the variable of name right over here and that's it let us open

1827
03:22:12,030 --> 03:22:21,070
打开我们的终端，让我进入我的ix，现在让我为我们的教程创建一个别名，不是结构体
up our terminal let me go inside my ix now let me create an alias for our tutorials not structs not

1828
03:22:21,070 --> 03:22:28,070
七大奇迹，让我把一切都搞清楚，这里我们可以说是所有奇迹的列表
seven wonders let me clear up everything and here we can say that the list of all our wonders

1829
03:22:28,070 --> 03:22:34,950
就是我们的七大奇迹，记住我们定义了一个all的函数，现在我们有了所有的
is our seven wonders and remember we have defined a function of all so now we have all of the

1830
03:22:34,950 --> 03:22:41,050
奇迹，让我再次澄清一下，接下来我们可以做的是再次使用相同的模块
wonders let me clear up one more time and next what we can do is we can again use the same module

1831
03:22:41,050 --> 03:22:47,950
七大奇迹的，并且我们可以打印出名称，所以这个函数需要一个参数，就是
of seven wonders and let us print out the names so this function takes one argument and that is the

1832
03:22:47,950 --> 03:22:54,570
所有奇迹的，就是这样，现在我们可以看到我们有了正确的输出，我们回来了
of all our wonders and that's it now we can see that we have the right output and we get back

1833
03:22:54,570 --> 03:23:00,470
只是我们的七大奇迹的名称，让我们回到代码编辑器，让我们也定义一下
just the names of all of our seven wonders let us go back to the code editor and let us also define

1834
03:23:00,470 --> 03:23:06,950
这个函数的类型规范，所以在这里我们可以说我们的函数的规范
the type specification for this function so here we can say that the specifications for our function

1835
03:23:06,950 --> 03:23:17,010
打印名称，所以第一个参数是我们所有奇迹的列表，所以我们可以说这是
of print names so the first argument is the list of all of our wonders so we can say that this is

1836
03:23:17,010 --> 03:23:23,210
现在，由于该函数没有返回任何内容，我们可以说它只返回一个原子
now since this function is not returning anything we can say that this simply returns an atom of

1837
03:23:23,210 --> 03:23:30,370
好的，如果你想的话，你也可以使用管道操作符，所以我可以把这个拿出来
okay also if you want you can also use the pipeline operator so what i can do let me take this one out

1838
03:23:30,370 --> 03:23:36,370
让我把它放在这一行上，在下一行上让我使用管道操作符，所以默认情况下
let me put it on this line and on the next line let me use the pipeline operator so by default

1839
03:23:36,370 --> 03:23:43,130
我们的奇迹列表作为函数enum.dot.each的第一个参数传递，让我来
our list of wonders is being passed as the first argument for the function of enum dot each let me

1840
03:23:43,910 --> 03:23:51,250
打开我的终端，让我重新编译一切，让我们尝试运行相同的函数
open up my terminal let me again recompile everything let us try to run the same function

1841
03:23:51,250 --> 03:23:56,950
再试一次，正如预期的那样，我们得到了正确的答案，接下来让我们看看如何过滤
one more time and as expected we get the right answer back next let us see how we can filter

1842
03:23:56,950 --> 03:24:03,570
从我们的列表中选择一个七大奇迹，所以在这里让我们创建一个新函数，让我给函数命名
a single seven wonder from our list so here let us create a new function and let me name the function

1843
03:24:03,570 --> 03:24:09,770
作为按国家过滤，现在这个函数将接受两个参数，第一个参数显然是
as filter by country now this function will accept two parameters the first parameter is obviously

1844
03:24:09,770 --> 03:24:15,770
我们所有奇迹的列表，第二个参数是我们想要的国家的名称
the list of all our wonders and the second one is the name of our country for which we want to

1845
03:24:15,770 --> 03:24:22,850
筛选出来的，例如如果国家是印度，那么我们应该得到这个七大奇迹
filter for so for example if the country is india then we should get back this single seven wonder

1846
03:24:22,850 --> 03:24:28,910
那么让我们看看我们如何在这里实现这个筛选函数，让我添加我的do和end块
so let us see how we can implement this filter function here let me add my do and end blocks

1847
03:24:28,910 --> 03:24:34,330
让我把这个稍微提高一点，所以让我们再回到我们的终端，看看我们能不能
and let me take this a little up so again let us go back to our terminal and let us see if we can

1848
03:24:34,330 --> 03:24:40,370
在我们的标准库中有一个筛选函数，所以让我再次调用助手文档
a filter function inside our standard library so again let me call the helper documentation

1849
03:24:40,370 --> 03:24:46,970
从我们的枚举模块中，让我们看看这个模块是否有一个筛选函数，所以在这里
from our module of enum and let us see if this module has a function of filter or not so here

1850
03:24:46,970 --> 03:24:54,430
我们有一个筛选函数，所以让我们看看这个函数的文档，所以这个函数
it is we have a function of filter so let us see the documentation of this function so this function

1851
03:24:54,430 --> 03:24:59,730
筛选器接受两个不同的参数，第一个显然是我们的枚举类型，第二个参数
of filter this accepts two different parameters the first is obviously our enum and second parameter

1852
03:24:59,730 --> 03:25:06,310
将是一个函数，这里我们有一个示例实现，因此我们可以看到第一个
is going to be a function and here we have a sample implementation so as we can see the first

1853
03:25:06,310 --> 03:25:11,470
元素是一个列表，第二个参数将是一个函数，现在如果我们阅读
element is a list and the second argument is going to be a function now if we read the

1854
03:25:11,470 --> 03:25:18,030
文档中说，这个函数只返回那些符合你的函数的元素
documentation it is saying that this function returns only those elements for which your function

1855
03:25:18,030 --> 03:25:24,790
返回一个布尔值，让我们来看看这个示例中发生了什么，这里有一个条件
returns a truth value so let's see what's happening inside this example so here they have a condition

1856
03:25:24,790 --> 03:25:30,990
每当这个条件评估为true时，只返回那个值，所以这里我们有一个
and whenever this condition evaluates to true only that value is returned so here we have a

1857
03:25:30,990 --> 03:25:37,630
一个由1、2和3组成的列表，这个条件只对2这个元素满足，那就是
list of one two and three and this condition is only satisfied for the element of two and that's

1858
03:25:37,630 --> 03:25:43,090
这就是为什么我们会得到一个列表和一个单独的元素2，那么让我们看看如何使用这个内置的
why we get back a list along with a single element of two so let's see how we can use this inbuilt

1859
03:25:43,090 --> 03:25:49,370
用于按照我们国家的名称进行过滤的函数，所以这里我们可以使用我们的奇迹列表
function for filtering by the name of our country so here we can take the list of our wonders and

1860
03:25:49,370 --> 03:25:57,070
我们可以将这个参数传递给我们的枚举点过滤器，现在再次默认情况下，奇迹的第一个参数是
we can pipe this argument to our enum dot filter now again by default the first argument of wonders

1861
03:25:57,070 --> 03:26:02,850
会被传递，并且我们只需要为我们的函数传递第二个参数，这个函数
would be passed and we simply need to pass the second argument for our function this function

1862
03:26:02,850 --> 03:26:08,950
每次迭代都会接收一个奇迹，所以它的样子就是这样，这里我们需要
receives a wonder for each iteration so this is how it's going to look like and here we need to

1863
03:26:08,950 --> 03:26:14,850
指定一个条件，该条件将评估为true，所以在这里我们可以做的是再次模式匹配
specify a condition that will evaluate to a true so here what we can do is we can again pattern

1864
03:26:14,850 --> 03:26:21,730
在这个由七个奇迹组成的结构上进行模式匹配，所以让我们来做这件事，这一次我们只想提取出来
on this struct of seven wonders so let's do that thing and this time we simply want to extract the

1865
03:26:21,730 --> 03:26:27,450
国家的名称，让我们在国家字段上进行模式匹配，并收集数据。
name of the country so let us pattern match on the field of country and let us collect the data

1866
03:26:27,450 --> 03:26:34,590
在一个名为country name的变量内，接下来我们来看一下我们的条件判断，我们可以说
inside a variable called as country name now next coming to our truth condition here we can say that

1867
03:26:34,590 --> 03:26:41,750
我们只想在国家名称等于国家名称时进行过滤，所以这个
we want to filter it out only when the country name is equal to the name of the country so this

1868
03:26:41,750 --> 03:26:47,570
国家是作为参数传递给我们的函数的，就在这里，而这个country的参数
country is what is being passed to our function right over here and this parameter of country

1869
03:26:47,570 --> 03:26:53,650
我们是通过在这里使用我们的模式匹配来提取的country的名称，所以让我保存文件
name is what we are extracting by using our pattern match right over here so let me save the file

1870
03:26:53,650 --> 03:27:01,610
让我们打开终端，重新编译七大奇迹的模块，接下来我们可以做的是
let us open up our terminal and let us recompile the module of seven wonders next what we can do

1871
03:27:01,610 --> 03:27:08,030
我们可以说我们想要使用七大奇迹的按国家进行过滤，让我们传递所有的奇迹
is we can say we want to use seven wonders dot filter by country let us pass all of the wonders

1872
03:27:08,590 --> 03:27:14,670
接下来让我们传递印度，看看我们得到什么输出，正如预期的那样
and next let us pass india and let us see what output we are getting and as expected we can

1873
03:27:14,670 --> 03:27:20,370
我们发现我们得到了正确的答案，让我们再试一次，试一下
see that we are getting the right answer back let us try one more time and let us try with

1874
03:27:20,370 --> 03:27:26,170
墨西哥，我们再次得到了正确的答案，所以让我们回到这里
mexico and again we are getting the right answer back so again let us go back right over here and

1875
03:27:26,170 --> 03:27:32,850
让我们编写类型规范，以便过滤器按国家进行过滤
let us write the type specifications so the specifications for our filter by country the

1876
03:27:32,850 --> 03:27:40,270
第一个参数是七大奇迹的类型列表，第二个参数是类型
first argument is the list of the type of seven wonders the second argument is of the type of

1877
03:27:40,270 --> 03:27:47,690
返回类型是列表，其中包含一个单独的类型，就是这样
string and the return type is the list and this contains a single type well that's it for this

1878
03:27:47,690 --> 03:27:52,870
在下一个视频中，我们将继续对我们的结构体进行不同的函数操作，所以让我们
video in the next video we will continue with the different functions on our structs so let us

1879
03:27:52,870 --> 03:27:58,370
继续使用我们的结构体，并且在幕后我添加了一些函数
continue with our structs and behind the scenes what i've done is i have added a couple of functions

1880
03:27:58,370 --> 03:28:03,790
让我们看看如何实现所有这些函数，所以首先的函数是
let us see how we can implement all of these functions so the first function that you can

1881
03:28:03,790 --> 03:28:09,810
在这里可以看到，这个函数也是关于过滤的，我们只是想要过滤掉
see over here so this function is also about filtering and we simply want to filter out

1882
03:28:09,810 --> 03:28:16,130
七大奇迹的国家以i开头，所以让我们看看我们如何做到这一点
the seven wonders for which the countries start with i so let us see how we can do this one

1883
03:28:16,130 --> 03:28:23,350
让我复制这个，然后将其粘贴到这里，我稍微处理一下所有这些东西
let me copy this one and let me paste it right over here let me take all of these things a little

1884
03:28:23,350 --> 03:28:30,070
所以在这种情况下，我们的真值函数将发生变化，我们只是想要比较这些值并检查是否
so in this case our truth function will change and we simply want to compare the values and check if

1885
03:28:30,070 --> 03:28:35,750
这个国家的名字是以i开头还是不以i开头，让我把这个去掉，这次我们可以
the name of the country starts with i or not so let me take this one out and this time we can

1886
03:28:35,750 --> 03:28:41,590
将变量名从country name改为只是country，让我们看看我们如何比较
rename the variable from country name to just country and let us see how we can compare the

1887
03:28:41,590 --> 03:28:48,290
我们字符串的第一个字母是i，为此让我们使用另一个模块，模块的名称是
first alphabet of our string with i for this let us use another module and the name of the module

1888
03:28:48,290 --> 03:28:55,310
将是字符串，并且这个模块有一个非常方便的函数starts with，如果我悬停在上面
is going to be string and this module has a very convenient function of starts with now if i hover

1889
03:28:55,310 --> 03:29:00,450
在函数定义上方，我们可以看到这个函数接受两个不同的参数，所以它们
over the function definition we can see that this function accepts two different parameters so they

1890
03:29:00,450 --> 03:29:06,930
这里有一个例子elixir和eli，所以在这种情况下，elixir以eli开头，这就是为什么我们
have one example over here elixir and eli so in this case elixir starts with eli that's why we

1891
03:29:06,930 --> 03:29:13,890
得到答案为true，所以第一个参数将是我们的国家，第二个参数将是
get the answer as true so the first argument would be our country and the second argument would be

1892
03:29:13,890 --> 03:29:21,770
i，所以让我再次打开终端，重新编译我们的七大奇迹模块，让我
i so let me open up the terminal again let me recompile our module of seven wonders let me

1893
03:29:21,770 --> 03:29:28,090
清理一切，现在让我们调用这个函数，这样我们就可以说七大奇迹点国家
clear up everything now let's invoke the function so we can say seven wonders dot countries which

1894
03:29:28,090 --> 03:29:35,550
以i开头，让我们把所有的奇迹都传递给它，正如预期的那样，我们得到了两个奇迹
start with i and let us pass all of the wonders to this one and as expected we get two wonders back

1895
03:29:35,550 --> 03:29:41,650
所以第一个奇迹是在印度制造的，第二个奇迹是在意大利制造的，下一个函数是
so the first wonder is made in india the second wonder is made in italy the next function is

1896
03:29:41,650 --> 03:29:47,330
按国家长度排序，哦，在继续之前，让我们也为这个添加类型规格
sort by country length oh before moving on let us also add in the type specifications for this one

1897
03:29:47,330 --> 03:29:54,270
规格非常简单，这些奇迹是我们的t型列表
so the specifications are pretty simple this wonders is the list of our type of t

1898
03:29:54,270 --> 03:30:02,210
这也返回一个t型列表，好吧，现在让我们去这个排序函数
and this also returns a list of type of t all right so now let us go to this sort function

1899
03:30:02,210 --> 03:30:08,430
所以这一次我们想做的是，我们只是想按长度对所有的奇迹进行排序
so this time what we want to do is we simply want to sort all of the wonders by the length of the

1900
03:30:09,190 --> 03:30:16,150
所以让我们看看我们如何做到这一点，如果我回到我的终端，让我们来看看枚举
so let us see how we can do this one so if i go back to my terminal and let's check out for enum

1901
03:30:16,150 --> 03:30:23,110
点排序，所以我们在枚举模块内有一个方便的排序函数，正如你所看到的
dot sort so we have a convenient function of sort inside the module of enum and as you can see it

1902
03:30:23,110 --> 03:30:29,150
有很多文档，但我想向您展示一些关键参数，所以这是
has a lot of documentation but i wanted to show you a couple of key parameters so this is the

1903
03:30:29,150 --> 03:30:35,570
排序函数，这个函数接受两个参数，第一个是枚举，第二个是
function of sort and this function accepts two parameter the first is the enum and the second one

1904
03:30:35,570 --> 03:30:42,690
是一个排序器，现在这个排序器参数可以是多种类型，所以让我们参考官方的说明
is an sorter now this sorter argument can be of multiple types so let us refer to the official

1905
03:30:42,690 --> 03:30:48,230
这个函数的规格，让我们试着找出来。第一个显然是你的。
specifications for this function and let us try and figure it out so the first is obviously your

1906
03:30:48,230 --> 03:30:54,530
现在对于 sorter 的第二个参数，我们可以看到我们可以传递多个参数。
elements and now for the second argument of sorter we can see that we can pass a multiple of arguments

1907
03:30:54,530 --> 03:31:00,010
所以这个规格是在说，我们可以传递一个函数，这个函数接收
so what this specification is saying that either we can pass a function and this function receives

1908
03:31:00,010 --> 03:31:06,270
两个元素，这个函数必须返回一个布尔值，或者你可以选择传递
two elements and this function has to return back a boolean value or you can choose to pass

1909
03:31:06,270 --> 03:31:11,690
这些参数也是如此，现在让我们看看我们如何处理这个，这是一个非常简单的
this arguments as well now let us see how we can work with this one so this is a pretty simple

1910
03:31:11,690 --> 03:31:19,070
我们可以传递给我们的 enum.sort 的函数，所以让我们回到我们的代码编辑器，再次
function that we can pass to our enum dot sort so let us go back to our code editor let us again

1911
03:31:19,070 --> 03:31:26,290
使用 wonder 的参数，然后将其传递给我们的 enum.sort，现在让我们看看
use the arguments of wonder and let us pipe this one to our enum dot sort now here let us see how

1912
03:31:26,290 --> 03:31:32,770
定义 sorter 函数，这将是你的常规函数，现在对于每次迭代
define the sorter function so this is going to be your regular function now for each iteration

1913
03:31:32,770 --> 03:31:39,150
这个函数将接收两个不同的 wonders，所以我们可以称它们为 x 和 y，接下来
this function is going to receive two different wonders so we can call them as x and y and next

1914
03:31:39,150 --> 03:31:45,590
对于函数的主体，我们可以简单地说我们想检查字符串的长度
for the body of the function we can simply say that we want to check for the length of the string

1915
03:31:45,590 --> 03:31:52,630
第一个，我们来比较这个长度是否小于下一个奇迹的长度
for the first one and let us compare if this length is less than the length of the next wonder

1916
03:31:52,630 --> 03:31:58,450
所以我们可以再次使用相同的函数string.length，并让我们传递变量y
so again we can use the same function string dot length and let us pass the variable of y this

1917
03:31:58,450 --> 03:32:03,630
所以我们所做的是定义了一个函数，对于每次迭代，这个函数
time so what we have done is we have defined a function and for each iteration this function

1918
03:32:03,630 --> 03:32:08,990
接收两个不同的奇迹，我们只是尝试比较这些奇迹的长度
receives two different wonders and we are simply trying to compare the length of this wonders

1919
03:32:08,990 --> 03:32:16,310
就是这样，让我保存文件，打开终端，再次重新编译
and that's it so let me save the file let me open up my terminal and let me again recompile the

1920
03:32:16,990 --> 03:32:23,670
让我们尝试调用这个函数sevenwonders.sort按国家长度排序，并让我们传递
let's try to invoke this function seven wonders dot sort by country length and let us pass

1921
03:32:23,670 --> 03:32:30,550
所有的奇迹，哦，我们遇到了一个错误，那是因为我们在这里试图找到
all of our wonders oh we are getting an error and that's because here we are trying to find the

1922
03:32:30,550 --> 03:32:36,350
整个结构体的长度，我忘记了指定我们想要检查的参数的长度
length of the entire struct i forgot to specify the parameter that we want to check for the length

1923
03:32:36,350 --> 03:32:42,330
国家的名称，对于这个结构体也是一样的，所以我们要检查
of the name of the country the same thing goes for this struct as well so we want to check for

1924
03:32:42,850 --> 03:32:51,070
这个国家，现在让我保存文件，打开终端，让我重新编译一次，清理一下
this country now let me save the file open up my terminal let me recompile one more time clear up

1925
03:32:51,070 --> 03:32:57,230
屏幕上让我们再试一次调用这个函数，这次如您所见我们有
the screen and let us try to invoke this function one more time so this time as you can see we have

1926
03:32:57,230 --> 03:33:03,130
一个漂亮的排序列表，所以现在您可以看到列表按照国家的长度进行了排序
a nice sorted list so as you can see now the list is sorted according to the length of the country

1927
03:33:03,130 --> 03:33:09,250
名称是秘鲁，这是四个字符长，所以这是第一个，接下来是中国，这是五个
name so peru this is four characters long so this is the first one next is china this is five

1928
03:33:09,790 --> 03:33:16,410
然后我们有意大利和印度，然后我们有巴西等等，所以您可以看到我们有一个
again then we have italy and india then we have brazil and so on so as you can see we have a

1929
03:33:16,410 --> 03:33:21,750
漂亮的排序列表，所以现在让我们回去看看我们想对下一个做什么
nicely sorted list so now let us go back and let us see what we want to do for the next one

1930
03:33:21,750 --> 03:33:28,090
所以对于名称国家列表的下一个函数，这个函数接受我们的奇迹，我希望
so for the next function of name country list so this function accepts our wonders and i want

1931
03:33:28,090 --> 03:33:34,690
一个像这样的输出，所以输出必须是列表，列表中又有另一个列表
an output like this so the output has to be the list and inside the list we want another list the

1932
03:33:34,690 --> 03:33:40,530
第一个元素必须是七大奇迹的名称，第二个名称必须是国家
first element has to be the name of the seven wonder and the second name has to be the country

1933
03:33:40,530 --> 03:33:46,190
所以让我们看看我们如何做到这一点，让我去掉注释，我不需要注释
so let us see how we can do this one so let me take out the comment i don't need the comments

1934
03:33:46,730 --> 03:33:52,490
在我展示这个之前，让我带您回到我的终端，并让我清理所有这些
and before i show this one let me take you back to my terminal and let me clear up all of these

1935
03:33:52,490 --> 03:33:58,970
事情和这次让我们查看 enum dot reduce 的文档，现在这个
things and this time let us check out the documentation for enum dot reduce now this

1936
03:33:58,970 --> 03:34:05,650
reduce 这是一个非常强大的函数，实际上你可以在里面实现所有的函数
reduce this is a very powerful function and in fact you can implement all of the function inside

1937
03:34:05,650 --> 03:34:11,310
enum 模块只需使用这个简单的函数，所以让我们先看看这个函数
the module of enum by just using this simple function so first let us see the function

1938
03:34:11,310 --> 03:34:17,910
签名，因此这个 reduce 函数接受三个参数，第一个参数是你的 enum
signature so this function of reduce accepts three parameters the first argument is for your enum

1939
03:34:17,910 --> 03:34:24,470
第二个参数是你的累加器，第三个参数是你的函数，我们
the second argument is for your accumulator and the third argument is for your function and we

1940
03:34:24,470 --> 03:34:31,350
一个示例就在这里，所以第一个参数是一个列表，第二个参数是
one sample example right over here so the first argument is a list the second argument is for the

1941
03:34:31,350 --> 03:34:36,970
累加器，第三个参数你在这里可以看到，这是一个函数，现在这个
accumulator and the third argument that you can see over here this is for a function now this

1942
03:34:36,970 --> 03:34:43,670
函数在每次迭代中接收一个元素，这个函数还接收累加器
function receives an element for each iteration and this function also receives the accumulator

1943
03:34:43,670 --> 03:34:49,630
因此，对于第一次迭代，由于累加器是零，这将是零，并且对于第一次
so for the first iteration since the accumulator is zero this would be zero and for the first

1944
03:34:49,630 --> 03:34:56,390
迭代，我们的 x 将为一，现在这个函数会发生什么，结果会被传递
iteration our x would be one now what happens with this function is that the result is passed

1945
03:34:56,390 --> 03:35:02,350
作为下一次迭代的累加器，所以您可以在这里阅读文档。
as the accumulator for the next iteration so you can read the documentation over here so this is

1946
03:35:02,350 --> 03:35:07,970
发生什么事情，所以对于第二次迭代，无论这个值评估为何，这个值将会
what is happening so for the second iteration whatever this evaluates to so this value will

1947
03:35:07,970 --> 03:35:13,910
成为您的新累加器，让我们看看这个reduce函数的实际效果，让我们回到
become your new accumulator so let us see this reduce function in action so let us go back to

1948
03:35:13,910 --> 03:35:19,830
代码编辑器，现在让我们看看如何使用reduce函数，因此我们可以说enum点
code editor now let us see how we can work with our reduce function so we can say enum dot

1949
03:35:19,830 --> 03:35:26,470
reduce的第一个参数是我们的wonders，第二个参数将是我们的累加器
reduce the first argument is for our wonders the second argument is going to be our accumulator

1950
03:35:26,470 --> 03:35:32,890
因此，作为我们的初始累加器，我们只需传递一个空列表，第三个参数将是一个
so as our initial accumulator let us just pass an empty list and the third one is going to be a

1951
03:35:32,890 --> 03:35:41,230
函数，现在让我做一件事，让我把这个拿出来，让我们管道到我们的enum点reduce
function now let me do one thing let me take this one out and let us pipe into our enum dot reduce

1952
03:35:41,230 --> 03:35:47,050
现在，对于每次迭代，此函数将接收两个参数，第一个参数是
now for each iteration this function is going to receive two parameters the first parameter is

1953
03:35:47,050 --> 03:35:52,690
将是我们的wonder，第二个参数将是我们的累加器，所以最初的
going to be our wonder and the second parameter is going to be our accumulator so initially the

1954
03:35:52,690 --> 03:35:58,190
累加器将是一个空列表，对于每次迭代，我们想做什么，我们只需简单地
accumulator is going to be a blank list and for each iteration what do we want to do we simply

1955
03:35:58,190 --> 03:36:04,850
想要在这个列表内创建一个列表，我们需要另一个列表，在这个内部列表内，第一个
want to create a list inside this list we need another list and inside this inner list the first

1956
03:36:04,850 --> 03:36:09,610
参数将是奇迹的名称，第二个参数将是奇迹的国家
argument would be the name of the wonder and second one would be the country of the wonder

1957
03:36:09,610 --> 03:36:16,330
所以在这里我们可以说，从奇迹中，我只想要你提取名称，第二个参数是
so here we can say that from wonder i simply want you to take the name and the second argument is

1958
03:36:16,330 --> 03:36:22,570
将成为这个奇迹的国家，之后我们只想要将其添加到累加器中
going to be the country for this one and after this we simply want to append our accumulator

1959
03:36:22,570 --> 03:36:29,950
然后就是这样了，让我保存文件，打开终端，重新编译模块
back and that's it let me save my file let me open up my terminal let me recompile the module

1960
03:36:29,950 --> 03:36:36,550
然后让我清屏，让我们调用这个函数，我们可以说七大奇迹点
and let me clear up the screen let us invoke this function so we can say seven wonders dot

1961
03:36:36,550 --> 03:36:43,810
country list，让我们传递所有的奇迹，正如预期的那样，我们得到了答案，所以在这里
country list and let us pass all of the wonders and as expected we get the answer back so here

1962
03:36:43,810 --> 03:36:49,630
我们可以看到第一个参数将是奇迹的名称，后面是奇迹的名称
we can see the first argument is going to be the name of the wonder followed by the name of the

1963
03:36:49,630 --> 03:36:55,430
现在，只是为了给你更多的练习，让我们再试试使用这个reduce函数
country now just to give you some more practice let us try and use this reduce function one more

1964
03:36:55,430 --> 03:37:01,210
这次，对于这个函数，在这里是国家名称关键字列表，所以这就是我想让你做的事情
time so for this function right over here country name keyword list so this is what i want you to do

1965
03:37:01,210 --> 03:37:08,150
所以这个函数将接受我们的奇迹，这是我期望的输出，所以我们
so this function is going to accept our wonders and this is the output that i'm expecting so we

1966
03:37:08,150 --> 03:37:13,890
想要一个列表，在列表内部我们想创建我们的关键字列表，所以你可以看到这是
want to have a list and inside the list we want to create our keyword list so as you can see this is

1967
03:37:13,890 --> 03:37:19,890
将是一个原子，这将是值，所以让我将所有这些东西复制一遍
going to be an atom and this is going to be the value so let me just copy all of these things

1968
03:37:19,890 --> 03:37:27,110
让我复制这个，然后粘贴到这里，我不需要这个注释，让我拿走
let me copy this one and let me paste it right over here i don't need the comment let me take

1969
03:37:27,110 --> 03:37:33,450
看看我们如何使用这个函数，现在我想做的是
out and let us see how we can work with this function now here what i want to do is we don't

1970
03:37:33,450 --> 03:37:41,550
不想要一个内部列表，我们想要一个元组，所以让我将其从列表改为元组
want an inner list instead what we want is a tuple so let me change this from a list to a tuple so

1971
03:37:41,550 --> 03:37:47,990
让我解释为什么我想要一个元组，让我打开我的终端，例如，如果我们有一个
let me explain why do i want a tuple so let me open up my terminal so for example if we have a

1972
03:37:47,990 --> 03:37:54,850
像这样的关键字列表 a 和 one，所以这个关键字列表实际上被保存为我们元组的列表
keyword list like this a and one so this keyword list is actually saved as a list of our tuples

1973
03:37:54,850 --> 03:37:59,990
所以如果我必须进行模式匹配，那么在左侧让我们创建一个更多的列表
so in case if i have to pattern match so on the left hand side let us create one more list

1974
03:37:59,990 --> 03:38:06,310
在这里，如果我创建一个元组，第一个元素将是 a 的项，第二个元素
and here if i create a tuple the first element is going to be the item of a the second element

1975
03:38:06,310 --> 03:38:12,690
将是一个的值，让我们看看是否是一个模式匹配，是的，这是一个
is going to be the value of one so let us see if this is a pattern match or not so yes this is a

1976
03:38:12,690 --> 03:38:18,810
模式匹配，所以发生的情况是这个关键字列表保存在这个格式中，我想我有
pattern match so what's happening is this keyword list is saved in this format i think i have

1977
03:38:18,810 --> 03:38:24,130
在解释关键字列表时也有涵盖到，所以这是一个小回顾给你，这就是
covered this while explaining keyword list as well so this is a small recap for you so this is

1978
03:38:24,130 --> 03:38:29,570
相同的逻辑，我们在这里使用的原因，这就是为什么我们想要一个元组而不是一个
same logic and that we are using over here so that's why we want to have a tuple and not an

1979
03:38:29,570 --> 03:38:36,050
内部列表，现在第一个元素必须是一个原子，所以我可以做的是让我抓住这个内部
inner list now the first element has to be an atom so what i can do is let me grab this inside

1980
03:38:36,050 --> 03:38:43,910
我们可以通过使用字符串点到原子来将这个字符串转换为原子，现在就是这样
and we can convert this string to an atom by using our string dot to atom and that's it now

1981
03:38:43,910 --> 03:38:51,190
让我再次打开终端，让我们重新编译我们的模块，让我清理屏幕并让
let me open up my terminal again let us recompile our module and let me clear up the screen and let

1982
03:38:51,190 --> 03:38:57,870
我们尝试调用这个函数七个奇迹点国家名字关键字列表，让我们传递
us try to invoke this function seven wonders dot country name keyword list and let us pass

1983
03:38:57,870 --> 03:39:03,470
所有奇迹的参数，所以这次你可以看到第一个参数将是
the arguments of all wonders so this time as you can see that the first argument is going to be

1984
03:39:03,470 --> 03:39:09,610
我们的原子，值将是国家的名字，现在在进入最后一个函数之前
our atom and the value is going to be the name of the country now before going to the last function

1985
03:39:09,610 --> 03:39:16,330
我想给你展示一些东西，所以再让我打开终端，清除所有的
i wanted to show you a couple of things so again let me open up my terminal let me clear up all of

1986
03:39:17,050 --> 03:39:23,570
所以，如果我们只想列出奇迹的名称，我们可以使用多个模块
so in case if we want to make a list of just the names of the wonders we can use multiple modules

1987
03:39:23,570 --> 03:39:30,310
所以，让我再展示给你一种替代方法。我们可以使用`enum.map`，第一个参数
so let me show you one more alternate method so we can say enum dot map and the first argument

1988
03:39:30,310 --> 03:39:36,670
将成为我们所有奇迹的参数，我们可以简单地调用一个
is going to be our argument of all of our wonders and what we can do is we can simply invoke a

1989
03:39:36,670 --> 03:39:46,310
函数。这个函数每次接收一个奇迹，我们只需要做的是
function so this function receives a wonder each time and what we want to do is we simply want to

1990
03:39:46,310 --> 03:39:52,730
获取所有的名字。现在，Elixir实际上提供了一种简写语法，所以我们可以
all of the names now what we can do is elixir actually offers a shorthand syntax so what we

1991
03:39:52,730 --> 03:39:59,130
做的是将这个函数改成简写语法，我们可以说我们想要
can do is we can change this function to a shorthand syntax so we can say that we want

1992
03:39:59,130 --> 03:40:04,870
发送一个匿名函数的引用，这个函数将接收一个参数，所以
to send a reference to an anonymous function and this function is going to receive a parameter so

1993
03:40:04,870 --> 03:40:11,230
我们可以说对于第一个参数，我们只需要返回名称，就这样。所以这是
we can say for the first parameter we simply want to return the name back and that's it so this is

1994
03:40:11,230 --> 03:40:17,490
简写语法，我们得到完全相同的答案。所以如果你感觉舒服，你可以使用这个
shorthand syntax and we get the exact same answer back so if you are comfortable you can use the

1995
03:40:17,490 --> 03:40:23,350
速记语法，或者您可以使用常规语法，现在是这个视频的最后一部分。
shorthand syntax or else you can use the regular syntax now for the last part of this video i

1996
03:40:23,350 --> 03:40:29,550
想向您展示 Elixir 内的四种理解，我们可以通过使用相同的输出得到完全相同的结果。
wanted to show you the four comprehensions inside elixir we can get the exact same output by using

1997
03:40:29,550 --> 03:40:35,830
这四个理解，因此我们可以说对于每次迭代，我们只需
the four comprehensions so we can say for and here we can say that for each iteration we simply

1998
03:40:35,830 --> 03:40:42,570
想要进行模式匹配，并且我们想要将名称提取到一个名为 name 的变量中，并且我们想要
want to pattern match and we want to extract the name inside a variable of name and we want to

1999
03:40:42,570 --> 03:40:48,850
从我们的奇迹列表中提取出这个，对于每次迭代，我只想返回
extract this from our list of all of the wonders and for each iteration i simply want to return

2000
03:40:48,850 --> 03:40:56,270
奇迹的名字，就这样，我们得到了完全相同的结果，现在这个语法是
back the name of the wonder and that's it we get back the exact same result now this syntax is

2001
03:40:56,270 --> 03:41:02,190
有点奇怪，所以我们想要做的是，我们想要说对于每个元素来说
slightly weird so what we are trying to do is we are trying to say that for each element out of

2002
03:41:02,190 --> 03:41:08,610
我们想要对 enum 进行模式匹配，并且我们想要在 name 上进行模式匹配，并且对于每次迭代
enum we want to pattern match and we want to pattern match on name and for each iteration

2003
03:41:08,610 --> 03:41:14,570
我们只想简单地将名称返回，因此您可以使用您感觉舒适的任何语法
we simply want to return the name back so you can use any of the syntax with which you feel

2004
03:41:14,570 --> 03:41:21,090
更舒适，现在让我复制这个，然后让我回到我的代码编辑器，所以对于这个
more comfortable now let me just copy this one and let me go back to my code editor so for this one

2005
03:41:21,090 --> 03:41:27,750
让我们使用这四个理解，我把它粘贴在这里，我们还需要传递一个参数
let us use the four comprehension let me paste it right over here we also need to pass an argument

2006
03:41:28,360 --> 03:41:36,470
所以这个参数变成了我们的奇迹，这也需要改成奇迹，现在让我打开
so this argument becomes for our wonders and this also has to change to wonders now let me open up

2007
03:41:36,470 --> 03:41:43,450
我的终端让我重新编译模块，让我清理一下这个，让我们尝试运行一下
my terminal let me recompile the module and let me clear up this one and let us try to run this one

2008
03:41:43,450 --> 03:41:52,150
所以七个奇迹.全部名称 哦，我忘记传递参数了，所以全部名称和参数是
so seven wonders dot all names oh i forgot to pass the arguments so all names and the argument is

2009
03:41:53,190 --> 03:41:59,110
奇迹，我们得到了完全相同的答案，好了，这个视频就这样，下次见
wonders and we get back the exact same answer well that's it for this video and i will catch

2010
03:41:59,110 --> 03:42:05,230
在下一个视频里见，让我们再多练习一下我们的结构体，所以我做的是在背后
you in the next one let us have some more practice with our structs so what i've done is behind the

2011
03:42:05,230 --> 03:42:12,190
幕后，我创建了一个名为expense的新文件，让我们开始吧，首先
scenes i've created a new file called as expense and let us get started with this one so first as

2012
03:42:12,190 --> 03:42:19,510
像往常一样，让我们创建我们的模块，让我将这个模块命名为tutorials.structs.expense
usual let us create our module and let me call this module as tutorials dot structs dot expense

2013
03:42:20,270 --> 03:42:26,850
现在想象一下，我们正在创建一个管理费用的应用程序，让
now just imagine that we are creating an application to manage our expenses so let

2014
03:42:26,850 --> 03:42:33,990
我们定义一个结构体来保存我们的费用，所以我们可以说我们想定义一个结构体，而且这个
us define a struct to hold our expenses so we can say that we want to define a struct and since this

2015
03:42:33,990 --> 03:42:39,590
结构体将有多个字段，让我将它们放在不同的行上，所以第一个字段
struct is going to have multiple fields let me take them on different lines so the first field

2016
03:42:39,590 --> 03:42:45,050
将用于我们的费用标题，我们可以将标题初始化为空字符串
would be for the title of our expense and we can initialize the title to be a blank string

2017
03:42:45,610 --> 03:42:50,570
第二个是我们的费用日期，起初我们可以将其保持为
the second one would be the date of our expense initially we can keep it as

2018
03:42:50,570 --> 03:42:56,850
nil 接下来是我们的费用金额，让我们将金额初始化为
nil the next one would be the amount of our expense and let us initialize the amount to be

2019
03:42:56,850 --> 03:43:02,590
零 接下来是我们购买的商店，让我们将商店初始化为
zero the next one can be the store from which we did the purchase and let us initialize the store

2020
03:43:02,590 --> 03:43:10,170
也是一个空字符串，现在让我们为我们的结构体定义类型，首先让我创建
to be also a blank string now let us also define the types for our struct so first let me create

2021
03:43:10,970 --> 03:43:20,630
因此，我想为我的教程中的结构体创建一个别名，并在这里让我们定义
so i want to create an alias for my tutorials dot structs dot expense and here let us define the

2022
03:43:20,630 --> 03:43:29,810
此字段的类型，因此我们可以说对于我们的费用结构体的t类型，标题的第一个字段
type for this one so we can say the type of t for our struct of our expense the first field for title

2023
03:43:29,810 --> 03:43:38,270
因此，它将是字符串类型，第二个是日期，我们可以指定
so this is going to be of the type of string the second one is date for this we can specify that

2024
03:43:38,270 --> 03:43:46,870
类型将是日期类型，或者也可以是nil，下一个是金额的类型
type is going to be of the type of date or it can also be nil the next one is for our amount

2025
03:43:46,870 --> 03:43:54,450
所以这将是一个数字，下一个是给商店的，这将是某种类型的
so this is going to be a number and next one is for the store this is going to be of the type of

2026
03:43:54,450 --> 03:44:01,370
字符串，现在我们已经有了类型规范，现在让我们看看如何处理我们的
string so now we have the type specification in place now let us see how we can work with our

2027
03:44:01,370 --> 03:44:08,150
首先，让我创建一些示例费用，所以让我定义，所以让我定义
expense struct first let me create a couple of sample expenses so let me define so let me define

2028
03:44:08,150 --> 03:44:14,110
一个名为示例的函数，这个函数将简单地返回一些我们的费用
a function called as sample so this function will simply return a couple of our expenses

2029
03:44:14,650 --> 03:44:18,870
让我们在这里创建一个费用，所以我们可以说我们想要创建一个
let us create an expense right over here so we can say that we want to create an

2030
03:44:18,870 --> 03:44:27,070
费用，现在对于标题，我们可以说我们买了一些杂货，下一个字段是日期
expense now for the title we can say that we got some grocery the next field is for the date

2031
03:44:27,070 --> 03:44:33,810
现在这个类型必须是日期，所以让我进入我的终端，然后让我
now the type of this has to be a date so for this let me go to my terminal and here let me

2032
03:44:33,810 --> 03:44:40,250
向您展示如何创建日期，elixir有一个日期模块，所以我们可以使用该模块
show you how we can create a date so elixir has a module for date so we can use that module so

2033
03:44:40,250 --> 03:44:46,290
让我给你看，让我们检查一下该模块的文档，这样我们就可以说我们想要查看
let me show you so let us check the documentation for that module so we can say we want to see the

2034
03:44:46,290 --> 03:44:54,010
日期点新的帮助文档，正如您所见，这个 new 函数接受一个年份
helper documentation of date dot new so as you can see this function of new this accepts a year

2035
03:44:54,010 --> 03:45:01,830
月份和日期，让我们试试这个，让我把一切弄清楚，所以在这里我们可以创建一个新的
month and day so let us try this one so let me clear up everything so here we can create a new

2036
03:45:01,830 --> 03:45:08,090
日期，所以我们可以说日期点新的，第一个参数是年份，所以我们可以说
date so we can say date dot new the first argument was for the year so we can say

2037
03:45:08,090 --> 03:45:16,130
2023年，下一个参数是月份，所以我们可以说四月，日期我们可以说
2023 the next argument was for the month so we can say for april and for the day we can say

2038
03:45:16,130 --> 03:45:23,950
四月一号，就是这样我们得到了一个日期，但是正如你所看到的，我们得到了一个回归的复数
the first of april and that's it we get back a date but as you can see we get back a couple back

2039
03:45:23,950 --> 03:45:29,730
所以让我们进行模式匹配并提取日期，我们可以做的就是在左手边
so let us pattern match and let us extract the date so what we can do is just on the left hand

2040
03:45:29,730 --> 03:45:36,210
让我进行模式匹配，第一个元素将是项目，让我们创建一个
side let me pattern match so the first element would be the item of okay and let us create a

2041
03:45:36,210 --> 03:45:42,910
日期的变量，让我们看看日期的内容，就这样我们有了一个新的
variable for the date and let us just check out the contents of date so that's it we have a new

2042
03:45:43,590 --> 03:45:49,930
现在你可以在这里看到的语法是这个符号和d，这也表示一个日期，事实上
now the syntax that you can see over here this sigil and d this also denotes a date and in fact

2043
03:45:49,930 --> 03:45:55,170
我们可以使用这个语法来创建一个新的日期，我们不必总是调用日期函数
we can use this syntax to create a new date we don't have to always invoke the function of date

2044
03:45:55,170 --> 03:46:00,950
点新的，所以我们可以创建一个 sigil，这是 sigil 的标志，让我们
dot new so what we can do is we can create a sigil so this is the sign for sigil and let us

2045
03:46:00,950 --> 03:46:08,090
为我们的日期创建一个标记，这里我们可以说年份必须是2023年，月份可以是
create a sigil for our date and here we can say that the year has to be 2023 the month can be

2046
03:46:08,090 --> 03:46:15,370
日期可以是3月31日，就这样，我们有了一个新的日期，现在让我们回到
and the date can be 31st of march and that's it we have a new date in place so now let us go back

2047
03:46:15,370 --> 03:46:20,930
到结构体中，让我们在这里创建一个日期，让我在这里使用标记，这样我可以说
to the struct and let us create a date right over here so let me use the sigil over here so i can say

2048
03:46:20,930 --> 03:46:28,670
我想创建一个日期，假设我的年份是2023年，月份可以是九月，假设
i want to create a date and suppose my year is 2023 my month can be september and suppose the

2049
03:46:28,670 --> 03:46:36,390
日期是9月12日，接下来是金额，假设金额是18.99，假设商店是
date is 12th of september next is the amount suppose the amount is 18.99 and let's say the store

2050
03:46:36,390 --> 03:46:42,770
地铁，所以现在我们已经创建了一个费用，现在让我只是复制和粘贴一堆
is going to be metro so now we have created an expense now let me just copy and paste a bunch

2051
03:46:42,770 --> 03:46:49,470
更多的费用，就这样，让我打开我的终端，让我清理所有这些东西
of more expenses so that's it let me open up my terminal and let me clear up all of these things

2052
03:46:49,470 --> 03:46:58,110
让我们进入ix，让我为我的教程.结构.费用创建一个别名
let us go inside the ix and let me create an alias for of my tutorials dot structs dot expense

2053
03:46:58,110 --> 03:47:04,070
让我再清理一次，让我们为我们的样本费用创建一个变量，这样我们就可以说
and let me clear this one more time let us create a variable for our sample expenses so we can say

2054
03:47:04,070 --> 03:47:10,770
我的样本费用等于我的费用.样本函数，所以现在我们有了一堆
that my sample expenses is equal to my expenses dot the function of sample so now we have a bunch

2055
03:47:10,770 --> 03:47:17,790
在样本的基础上，让我们回到代码编辑器，看看我们可以如何处理我们的开支
of samples so now let us go back to the code editor and let us see what we can do with our expenses

2056
03:47:17,790 --> 03:47:24,550
哦，在那之前，让我们为这个添加类型规范，这样我们可以指定
oh before that let us add the type specifications for this one so here we can specify that the

2057
03:47:24,550 --> 03:47:31,730
我们的样本的规范，这个不接受任何参数，返回一个列表
specifications for our sample so this does not accept anything and this returns a list of the

2058
03:47:31,730 --> 03:47:37,330
接下来，让我们编写一个函数来获取我们刚刚定义的 t 的总金额
type of t that we have just defined next let us write a function to get the total amount that we

2059
03:47:37,330 --> 03:47:43,470
我们已经花费了多少，我们可以说这个函数是我们的总金额，这个函数接受
have spent so we can say that the function is going to be our total and this function accepts

2060
03:47:43,470 --> 03:47:49,970
我们的开支，让我们定义这个函数的主体，这个开支将是一个列表
our expenses and let's define the body of this function so this expenses would be the list of

2061
03:47:49,970 --> 03:47:55,370
我们所有的开支，例如，如果我们获得这些开支，我们只是想把所有的
all our expenses for example if we get this expenses then we simply want to add all of the

2062
03:47:55,370 --> 03:48:00,550
金额加在一起，我们想返回总金额，让我们看看我们怎么做
amounts together and we want to give back the total amount so let us see how we can do this one

2063
03:48:00,550 --> 03:48:05,890
让我把这些事情稍微提高一点，现在你可以通过使用多种方法来解决这个问题，但是
let me take all of these things a little up now you can solve this by using multiple methods but

2064
03:48:05,890 --> 03:48:12,450
我将使用枚举点减少，所以让我先拿出开支，然后让我引用开支
i'm going to use the enum dot reduce so first let me take the expenses and let me pipe the expenses

2065
03:48:12,450 --> 03:48:19,170
在枚举dot reduce中，现在为了这个reduce函数，让我们定义一个累加器，假设
into enum dot reduce now for this function of reduce let us define an accumulator so let's say

2066
03:48:19,170 --> 03:48:26,070
我的初始累加器是零，下一个是函数，现在对于每次迭代
that my initial accumulator is zero the next one comes the function now for each iteration this

2067
03:48:26,690 --> 03:48:32,790
有两个参数，第一个是expense，第二个是累加器，对于每次迭代
two parameter the first is going to be the expense the second is going to be the accumulator and for

2068
03:48:32,790 --> 03:48:39,930
每次迭代，我只是想去我的expense，取出金额，然后将该金额加到我的累加器中
each iteration i simply want to go to my expense take the amount and add that amount to my accumulator

2069
03:48:39,930 --> 03:48:46,690
就是这样，现在让我们返回终端，重新编译我们的expense，让我清理一下
so that's it now let us go back to our terminal let us recompile our expense let me clear up

2070
03:48:46,690 --> 03:48:53,510
现在让我们调用这个函数，所以我们可以说expense点，让我们得到total for
everything and now let us invoke this function so we can say expense dot let us get the total for

2071
03:48:53,510 --> 03:49:01,530
示例，我们得到的答案是1025.62，让我们回去，让我们也写一下类型
sample and that's it we get the answer as 1025.62 let us go back and let us also write the type

2072
03:49:01,530 --> 03:49:07,970
这个函数的规格是，total函数接受一个类型为t的列表
specifications for this one so this function of total this accepts a list of the type of t

2073
03:49:07,970 --> 03:49:13,490
并且返回一个数字，所以如果你悬停在数字上，你会看到你的数字可以是整数或浮点数
and this returns a number so if you hover over number you can see that your number can either

2074
03:49:13,490 --> 03:49:20,330
可以是整数或浮点数，接下来，让我们编写一个按日期对我们的expenses进行排序的函数
be an integer or a float next let us write a function to sort our expenses by the date so

2075
03:49:20,330 --> 03:49:26,150
我们可以说我们想要定义一个函数，这个函数接受我们的费用清单。
we can say that we want to define a function and this function accepts our list of expenses

2076
03:49:26,150 --> 03:49:32,450
现在让我们看看如何对列表进行排序，所以在上个视频中我们已经看过如何对列表进行排序了。
and now let us see how we can sort our list so in the last video we have seen how to sort a list

2077
03:49:32,450 --> 03:49:38,410
但这次我们想按日期排序，所以让我带你回到我的终端，让我们看看。
but this time we want to sort by date so let me take you back to my terminal so let us see

2078
03:49:38,410 --> 03:49:45,730
我们的枚举点排序的文档，上次我们使用了排序，但我们还有一个函数。
the documentation for our enum dot sort so last time we had used sort but we have one more function

2079
03:49:45,730 --> 03:49:51,110
排序的名字，现在让我们看看这个的文档，让我稍微。
the name of sort and buy now let us see the documentation for this one let me slightly

2080
03:49:51,110 --> 03:49:57,370
向上滚动，在这里他们有一个例子，其中他们使用日期，例如他们有一个。
scroll up and here they have an example in which they are using date so for example they have a

2081
03:49:57,370 --> 03:50:02,910
不同地图的列表，每个地图都有一个日期字段，这是他们的做法。
list of different maps and each of the map has a field for the date and this is how they are

2082
03:50:02,910 --> 03:50:08,750
对日期进行排序，所以第一个参数显然是你的枚举类型，第二个参数他们在使用。
sorting the date so the first argument is obviously your enum for the second argument they are using

2083
03:50:08,750 --> 03:50:13,570
这是一种缩写的语法，你可以使用你的常规函数，他们想要说的是
a shorthand syntax you can use your regular function and what they are trying to say is

2084
03:50:13,570 --> 03:50:19,730
对于每次迭代，他们想按生日排序，所以让我们使用这种缩写语法。
for each iteration they want to sort by the birthday so let us use this shorthand syntax

2085
03:50:19,730 --> 03:50:25,310
让我们来看看如何对日期进行排序，首先让我拿出我的所有开销
and let us see how we can sort our date so here we can say that first let me take all of my

2086
03:50:25,310 --> 03:50:32,310
然后让我将所有这些东西传送到我的enum dot sort by中，并且让我们使用简写语法
expenses then let me pipe all of these things into my enum dot sort by and let us use the shorthand

2087
03:50:32,310 --> 03:50:38,010
因此，我们可以说我想要给一个匿名函数的引用，并且对于每个迭代
syntax so we can say i want to give a reference to an anonymous function and for each iteration

2088
03:50:38,010 --> 03:50:45,590
我想按日期排序，让我们打开终端，重新编译我们的开销，让我来
i want to sort by the date let us open up our terminal let us recompile our expense let me

2089
03:50:45,590 --> 03:50:51,550
清除屏幕，这里我们可以说dot expense dot sort by date，让我们传递
clear out the screen and here we can say dot expense dot sort by date and let us pass the

2090
03:50:51,550 --> 03:50:57,270
我们的样本列表，让我们看看发生了什么，所以在这里你可以看到日期已经排序了
list of our samples and let us see what's happening so here you can see that the dates are sorted

2091
03:50:57,270 --> 03:51:05,390
最后一个是10月30日，之前的一个是10月18日，所以这个是9月份的
the last one is for 30th of october the earlier one is 18th of october so this one is for september

2092
03:51:05,390 --> 03:51:11,990
这个是7月份的，所以我们有一个按升序排列的漂亮列表，以防万一
and this one is for july so we have a nicely sorted list in ascending order in case if you

2093
03:51:11,990 --> 03:51:16,110
如果您想更改顺序，可以参考文档，是的，他们在说
want to change the order you can refer the documentation so yeah they're saying that

2094
03:51:16,110 --> 03:51:22,010
以防万一你想要降序，你也可以添加这些参数，让我们回去吧，让我们
in case if you want descending then you can add this parameters as well let us go back let us

2095
03:51:22,010 --> 03:51:30,050
为这个函数编写规范，按日期排序，所以这个函数接受类型为 t 的列表。
write the specifications for this one so sort by date so this accepts the list of the type of t

2096
03:51:30,050 --> 03:51:36,810
这个函数也返回相同类型的 t 列表，接下来让我们看看如何向列表中添加一个 expense。
and this also returns the same list of the type of t next let us see how we can add an expense to

2097
03:51:36,810 --> 03:51:43,050
我们的 expense 列表，所以让我们定义一个名为 add expense
的函数，它接受一个单独的 expense。
our list of expenses so let's define a function called as add expense so this accepts one single

2098
03:51:43,050 --> 03:51:50,290
然后让我们编写函数的主体，这将是一个非常简单的函数。
expense and let us write the body of our function now this is going to be a very simple function

2099
03:51:50,290 --> 03:51:56,950
我们只需要获取 expense，然后将其追加到我们现有的列表中。
so we simply have to take the expense and we simply want to append this expense to our existing list

2100
03:51:56,950 --> 03:52:03,230
对于这个函数，我想向你展示一个小技巧，以防你想要强制执行。
of samples now for this one i wanted to show you one small trick so in case if you want to enforce

2101
03:52:03,230 --> 03:52:09,230
这个 expense 必须是 expense 结构体类型的，我们可以做的就是
that this expense has to be of the type of the struct of expense then what we can do is we can

2102
03:52:09,230 --> 03:52:14,890
简单地在这里使用模式匹配，我们可以说我们想要进行模式匹配。
simply use a pattern match right over here so here we can say that we want to have a pattern match

2103
03:52:14,890 --> 03:52:21,800
我们的 expense 结构体，所以我们要强制执行类型的。
for our struct of expense so essentially what we are doing is we want to enforce that the type of

2104
03:52:21,800 --> 03:52:28,260
参数必须是我们结构体的类型，让我们也为这个函数添加规范。
parameter has to be of the type of our struct let us also add the specifications for this one so we

2105
03:52:28,260 --> 03:52:37,600
我们可以说我们的add expense函数接受t类型，并返回一个列表，这个列表包含
can say that our add expense this accepts the type of t and this returns the list and the list has

2106
03:52:37,600 --> 03:52:43,860
再者，我们还需要打开终端，重新编译我们的模型
of the type of t as well now let me open up my terminal let us also recompile the model for our

2107
03:52:43,860 --> 03:52:49,740
现在让我把一切都弄清楚，首先让我创建一个expense，让我们创建一个变量
expense let me clear up everything now first let me create an expense so let us create a variable

2108
03:52:49,740 --> 03:52:55,980
为我们的expense初始化结构体，所以这里我们要说我们的expense假设
for our expense and let us initialize our struct so here we want to say that our expense suppose

2109
03:52:55,980 --> 03:53:03,220
我们想买一些咖啡，假设日期是4月1日，这样我们就可以
we want to buy some coffee and let's say that date would be for the first of april so we can

2110
03:53:03,220 --> 03:53:08,640
使用sigil，我们可以说我们想要一个日期的sigil，日期将是2023年
use the sigil and we can say we want to sigil for the date and the date is going to be 2023

2111
03:53:08,640 --> 03:53:14,980
月份是4月，日期是4月1日，假设金额是
the month is april the date is the first of april let's say the amount for this one is going to be

2112
03:53:14,980 --> 03:53:23,080
假设我们从地铁买了这个，现在我们有了一个expense，现在让我们试着添加
and let's say we buy this from metro so now we have an expense with us now let us try adding

2113
03:53:23,080 --> 03:53:29,300
这个expense，所以我们可以说expense.add(our
expense)，让我们传递新创建的expense
this expense so we can say expense dot add our expense and let us pass the newly created expense

2114
03:53:30,080 --> 03:53:34,740
然后我们会得到一个答案，所以让我们看看这个列表中是否有咖啡
and we get back an answer so let us see if we have coffee in this list or not

2115
03:53:36,700 --> 03:53:43,460
所以是的，正如我们所看到的，第一项是咖啡，所以我们已经将我们的费用添加到列表中了。
so yes as we can see the first item is the coffee so we have added our expense inside the list so

2116
03:53:43,460 --> 03:53:48,460
让我们回去看看我们还能做什么，让我们看看我们如何更新单个
let us go back and let us see what else we can do next let us see how we can update a single

2117
03:53:48,460 --> 03:53:54,680
在我们的费用清单中的项目，例如，让我们看看如何更新金额
entry inside our list of expenses so for example let's see how we can update an amount for a

2118
03:53:54,680 --> 03:53:59,440
特定的费用，所以让我们创建一个函数，然后我们称之为更新金额的函数
particular expense so let us create a function and let us call the function as update amount

2119
03:53:59,440 --> 03:54:05,560
现在，这个函数将接受两个参数，第一个参数是我们费用的标题
now this function will take two parameters the first parameter is the title for our expense

2120
03:54:05,560 --> 03:54:10,980
第二个可以是金额，因此是更新的金额，让我们看看如何编写函数体
and the second can be the amount so the updated amount and let us see how we can write the body

2121
03:54:11,520 --> 03:54:18,040
所以例如，我想要做的是假设我们在购买日用品，并且我们想要更新
so for example what i want to do is suppose we are buying grocery and we want to update the

2122
03:54:18,040 --> 03:54:25,760
金额从18.99美元更新为20美元，所以让我们看看如何做到这一点，要更新金额，我们需要
amount from 18.99 to say 20 dollars so let's see how we can do that so for updating the amount we

2123
03:54:25,760 --> 03:54:31,320
要做一些事情，首先我们需要筛选出我们想要的费用
have to do a couple of things so the first thing is we need to filter out the expense that we want

2124
03:54:31,320 --> 03:54:36,560
要更新的第二步是我们要创建一个带有更新金额的新费用，因为
to update the second step is we want to create a new expense with the updated amount because

2125
03:54:36,560 --> 03:54:42,300
请记住，Elixir 中的所有数据类型都是不可变的，第三个是我们只想添加
remember all of the data types in elixir are immutable the third is we simply want to add

2126
03:54:42,300 --> 03:54:47,940
将这个费用添加到我们的样本中，我们想要删除旧的条目，所以让我们看看我们如何做到这一点
this expense to our samples and we want to take out the old entry so let us see how we can do

2127
03:54:47,940 --> 03:54:54,120
所以第一步是使用给定的标题筛选出确切的费用
these things so the first step is to filter the exact expense with the given title so we can say

2128
03:54:54,120 --> 03:55:00,260
我们想要使用 enum dot filter，第一个参数是我们的样本费用
we want to use enum dot filter the first argument would be for our sample expenses so we can just

2129
03:55:00,260 --> 03:55:05,220
将样本的函数传递到这里，接下来我们必须在这里定义一个函数，让我来使用
pass the function of sample over here next we have to define a function right over here so let me use

2130
03:55:05,220 --> 03:55:11,980
函数和 end，对于每次迭代，该函数接收一个单一的费用，所以让我们
the function and end and for each iteration this function receives one single expense so let us

2131
03:55:11,980 --> 03:55:18,900
在费用标题上进行模式匹配，所以我们可以说我们想要提取标题，我们想要
pattern match on the expense title so here we can say that we want to extract the title and we want

2132
03:55:18,900 --> 03:55:25,940
在一个新变量中捕获标题，让我们将变量命名为 expense title，对于每个
to capture the title in a new variable and let us name the variable as expense title and for each

2133
03:55:25,940 --> 03:55:32,980
迭代中，我们只需要检查费用标题是否等于给定的标题，所以这个标题
iteration we simply have to check if the expense title is equal to the given title so this title

2134
03:55:32,980 --> 03:55:38,280
来自函数定义，就在这里，我们还需要记录这个费用
comes from the function definition which is right over here and we also need to capture this expense

2135
03:55:38,280 --> 03:55:44,420
所以如果你只是将鼠标悬停在过滤器上，我们可以看到结果是一个列表，所以让我们进行模式匹配。
so if you just hover on filter so here we can see that the result is a list so let us pattern match

2136
03:55:44,420 --> 03:55:50,580
让我们提取那个支出，在左边让我们进行模式匹配，并且让我们创建。
and let us extract that expense so on the left let us pattern match over here and let us create

2137
03:55:50,580 --> 03:55:56,780
让我们创建一个名为item的变量，这个变量将保存我们的支出，同时创建一个新的列表。
a new list and let us create a variable called as item so this item will hold the expense that we

2138
03:55:56,780 --> 03:56:02,100
刚刚筛选完成后的下一步是创建一个新的支出，所以我们可以说我们想要创建。
have just filtered the next step is to create a new expense so we can say that we want to create

2139
03:56:02,100 --> 03:56:08,460
为新项目创建一个变量，并通过更新此项目来创建一个新的支出，所以我们可以说。
a variable for the new item and let us create a new expense by updating this item so we can say

2140
03:56:08,460 --> 03:56:16,080
对于我的项目结构，我想要根据新的金额更新金额，所以这个金额来自于。
for my struct of item i want to update the amount by the new amount so this amount comes from the

2141
03:56:16,080 --> 03:56:21,520
函数定义就在这里，所以现在我们有了新的金额，最后我们只需要。
function definition right over here so now we have the new amount the last thing is we simply have

2142
03:56:21,520 --> 03:56:27,860
将新项目添加到我们的样本列表中，但是在添加之前，我们还需要删除。
to append the new item to our list of samples but before we can append we also need to remove the

2143
03:56:28,240 --> 03:56:34,400
从我们的样本列表中删除，但是我们可以在一个地方的一条语句中完成所有这些事情。
from our list of samples but we can do all of these things in one place in a single statement

2144
03:56:34,400 --> 03:56:40,520
所以让我向你展示我们如何做到这一点，我们可以说我们想要将新项目添加到。
so let me show you how we can do this so here we can say that we want to append the new item to

2145
03:56:40,520 --> 03:56:46,780
我们的样本列表，但在我们追加之前，我们还需要删除旧条目，所以我们需要
our list of our samples but before we can append we also need to remove the old entry so what we

2146
03:56:46,780 --> 03:56:52,880
我们可以简单地将样本的输出传送到一个新的函数中，我们可以这样说
can do is we can simply take the output of sample and pipe this into a new function and we can say

2147
03:56:52,880 --> 03:56:59,460
list.delete，然后让我将旧项目传递给这个函数，就是这样，那么会发生什么呢
list dot delete and let me pass the old item to this function and that's it so what's going to

2148
03:56:59,460 --> 03:57:05,120
首先，我们将从样本列表中删除该条目，然后将新的条目
happen is first we are going to remove the entry from the list of samples and after that the new

2149
03:57:05,120 --> 03:57:11,120
追加到列表中，现在让我打开终端，像往常一样，让我们重新编译
item is going to be appended now let me open up the terminal and as usual let us again recompile

2150
03:57:11,120 --> 03:57:18,020
我们的开销，让我清理屏幕，让我们尝试调用这个函数 expense.update
our expense let me clear up the screen and let us try to invoke this function expense dot update

2151
03:57:18,020 --> 03:57:25,560
现在，例如，我们想将我们的杂货金额从18.99更新为30美元
amount now for example we want to update the amount of our grocery from 18.99 to say 30 dollars

2152
03:57:25,560 --> 03:57:31,500
让我们检查一下我们是否已经更新了金额，是的，所以这是杂货的条目
and let us check if we have updated the amount or not so yes so this is the entry for grocery

2153
03:57:31,500 --> 03:57:38,040
新金额是13，所以让我们回去，到目前为止，我们已经看到了很多不同的方式
and the new amount is 13 so let us go back so till now we have seen a lot of different ways in which

2154
03:57:38,040 --> 03:57:43,000
我们可以使用我们的结构来工作，我们已经看到了如何使用递归和如何
we can work with our structs we have seen how to work with recursion and we have also seen how to

2155
03:57:43,000 --> 03:57:49,100
现在使用内置模块，对于此视频的最后一部分，我想向你展示with。
with the inbuilt modules now for the last thing in this video i wanted to show you the with

2156
03:57:49,100 --> 03:57:55,320
语句，例如我们可能需要处理多个条件，例如
statements so for example what happens we may have to deal with multiple conditions so for example

2157
03:57:55,320 --> 03:58:01,020
你正在编写一个Web应用程序，你想要有登录功能，现在为了
you are writing a web application and you want to have the functionality for login now in order to

2158
03:58:01,020 --> 03:58:06,240
登录用户，我们必须满足多个不同的条件，例如首先我们需要
login a user we have to satisfy a multiple of different conditions for example first we need

2159
03:58:06,240 --> 03:58:12,240
进行身份验证，然后我们还需要验证密码等等，所以基本上我们想要的是
to authenticate and then we also need to verify the password and so on so basically what we want

2160
03:58:12,240 --> 03:58:18,720
要做的是为了登录，我们必须满足多个条件，而且你可以满足
to do is in order to log in we have to satisfy a multiple of conditions and you can satisfy

2161
03:58:18,720 --> 03:58:24,900
使用with语法来满足多个条件，让我先给你展示一下，这样你就很容易理解了
multiple conditions by using the width syntax so let me show you first and it will be easy for you

2162
03:58:24,900 --> 03:58:31,240
要理解的是，首先让我们为我们的用户创建一个虚拟数据库，我们可以这样做
to understand so the first thing is let us create a dummy database for our users and we can do that

2163
03:58:31,240 --> 03:58:37,660
通过编写我们自己的自定义模块属性，所以在这里我们可以说我们想要定义一个模块
by writing our own custom module attributes so here we can say that we want to define a module

2164
03:58:37,660 --> 03:58:43,380
属性的名称为users，并让我们分配一个不同用户的列表，所以我们所做的是
attribute by the name of users and let us assign a list of different users so what we have done is

2165
03:58:43,380 --> 03:58:48,980
所以这是一个模型属性，我们为这个模型属性分配了一个不同用户的列表。
so this is a model attribute and we have assigned a list of different users for this model attribute

2166
03:58:48,980 --> 03:58:55,240
所以我们可以在整个模块中将这些用户作为常量使用，接下来让我们写一下。
so what happens is we can use these users as a constant throughout our module next let us write

2167
03:58:55,240 --> 03:59:00,420
一些虚拟函数来进行身份验证和密码验证，所以我可以说我想定义一下。
some dummy functions to authenticate and verify password so here i can say that i want to define

2168
03:59:00,420 --> 03:59:06,100
一个用来进行身份验证的函数，这个函数将接受一个用户，我们可以在这里做的是。
a function to authenticate and this function will accept a user and here what we can do is we can

2169
03:59:06,100 --> 03:59:13,280
这是一个称为函数保护的东西，所以我们可以说当用户在我的列表中时。
something which is called as a function guard so here we can say that when the user is in my list

2170
03:59:13,280 --> 03:59:20,220
我们的用户中的时候，我想返回一个元组，第一个元素将是ok的。
of our users only at that time i want to return a tuple and the first element would be okay and the

2171
03:59:20,220 --> 03:59:25,980
消息将被授权，所以你可以在这里看到的语法就是所谓的保护。
message would be authorized so this syntax that you can see over here this is called as guards so

2172
03:59:25,980 --> 03:59:30,700
在Elixir中，我们可以使用不同类型的保护，所以你会逐渐理解保护的作用。
in elixir we can use different kinds of guards so you will understand guards as and when you

2173
03:59:30,700 --> 03:59:36,080
学习更多的Elixir知识，但现在让我们跟着这个流程继续，接下来让我们创建一个函数。
learn more of elixir but for now let us just go with the flow next let us create one more function

2174
03:59:36,080 --> 03:59:41,100
为我们的身份验证创建定义，以防万一我们的数据库中没有该用户。</summary>
definition for our authenticate so in case we don't have the user inside our database

2175
03:59:41,100 --> 03:59:47,720
所以在那个时候，我们想要返回一个元组，第一个元素将是错误，我们可以发送
so at that time we want to return a tuple the first element would be error and we can send

2176
03:59:47,720 --> 03:59:52,800
返回一个称为未经授权的消息，接下来让我们为验证密码创建一些虚拟函数
back a message called as unauthorized next let us create some dummy functions for verify password

2177
03:59:52,800 --> 03:59:58,020
同样，我们可以说我们想要定义验证密码，现在这个函数将接受两个参数
as well so we can say we want to define verify password now this function will accept two

2178
03:59:58,020 --> 04:00:04,020
参数，第一个将是用户，第二个将是密码，这里
parameters the first is going to be the user and the second is going to be the password and here

2179
04:00:04,020 --> 04:00:10,680
我们可以使用函数 guard，所以我们可以说，如果用户在我们的用户数据库中
we can use the function guard so we can say in case the user is inside our database of users

2180
04:00:10,680 --> 04:00:16,840
只有在那个时候，我想返回一个元组，第一个元素将是正常的，然后
only at that time i want to return back a tuple the first element is going to be okay and then

2181
04:00:16,840 --> 04:00:22,200
我们可以将消息传递为密码已验证，现在如果用户名和密码不匹配
we can pass the message as password verified now in case the username and the password does

2182
04:00:22,200 --> 04:00:28,040
不匹配，所以对于这个，让我们创建一个额外的子句，这个我不需要一个 guard
not match so for this one let us create one more clause so this i don't need a guard for this one

2183
04:00:28,040 --> 04:00:35,100
这个必须是错误的，让我们将消息传递为错误的密码，这种情况下
and this has to be error and let us pass the message as wrong password and this case since

2184
04:00:35,100 --> 04:00:39,680
我们对密码不做任何操作，让我使用一个下划线，这里也不是这样
we are not doing anything with the password let me use an underscore and here also we are not

2185
04:00:39,680 --> 04:00:45,100
现在我们已经有了基本的框架，可以对用户和密码进行任何操作了。
doing anything with the user and the password okay so now we have the basic framework in place

2186
04:00:45,100 --> 04:00:52,020
现在让我们创建一个登录函数，我们可以说定义了登录，该函数接受
now let us create a function for login so we can say defined login now this function accepts the

2187
04:00:52,020 --> 04:00:57,960
用户和密码，现在让我把这些东西提升一点，为了登录
user and also a password now let me take all of these things a little up now in order to login

2188
04:00:57,960 --> 04:01:03,360
一个用户，我们必须满足几个不同的条件，第一个条件是首先我们有
a user we have to satisfy a couple of different conditions the first condition is first we have

2189
04:01:03,360 --> 04:01:08,940
进行身份验证，然后我们还必须验证密码，让我们看看如何使用
to authenticate and then we also have to verify the password so let us see how we can use the

2190
04:01:08,940 --> 04:01:14,880
宽度语法，所以让我先在这里写宽度块，宽度为do，我们还可以写
width syntax so first let me write the width block over here so width do and we can also write the

2191
04:01:14,880 --> 04:01:20,020
在这里写else块，现在让我们看看如何定义宽度的主体，为了登录
else block over here now let's see how we can define the body of our width so in order to login

2192
04:01:20,020 --> 04:01:25,660
首先我们需要进行身份验证，同时我们还需要进行验证，现在让我们调用一下
first we need to authenticate and we also need to verify at the same time now here let us call the

2193
04:01:26,500 --> 04:01:32,460
进行身份验证，让我们传递用户，现在我们必须说我们必须满足这个条件
authenticate and let us pass the user now we have to say that we have to satisfy this condition

2194
04:01:32,460 --> 04:01:38,980
我们可以使用箭头语法在这里指定，我们可以指定在我们获得的情况下
and we can specify that by using an arrow syntax over here and we can specify that in case we get

2195
04:01:38,980 --> 04:01:44,520
只有在特定输出的情况下，用户才能被验证，我们可以在这里指定
a specific output only then the user can be authenticated and here we can specify that in

2196
04:01:44,520 --> 04:01:53,820
如果第一个元素是“okay”，那么我们只会得到一条消息
case the first element is the item of okay and then we get some kind of a message back only in

2197
04:01:53,820 --> 04:01:59,900
在验证的情况下，我们还需要检查密码是否可以验证，所以让我们
case of authenticate but we also need to check if we can verify the password or not so here let us

2198
04:01:59,900 --> 04:02:06,220
调用验证密码的函数，让我们传递用户和密码，现在我们
call the function of verify password let us pass the user and let us also pass the password now we

2199
04:02:06,220 --> 04:02:11,880
可以说，验证密码的函数还必须满足一些不同的条件
can say that this function of verify password also has to satisfy a couple of different conditions

2200
04:02:11,880 --> 04:02:17,840
所以让我从这里复制这个，并粘贴到这里，以防这个函数
so let me just copy this one from here and let me paste it right over here so in case this function

2201
04:02:17,840 --> 04:02:23,860
也成功了，我们会得到一个带有“okay”的元组，假设第二个元素是消息
also succeeds and we get back a tuple with okay and suppose the second one is for the message

2202
04:02:23,860 --> 04:02:28,420
让我在这里加一个下划线，因为我们没有对变量进行任何操作，那么现在
let me put an underscore over here since we are not doing anything with the variable so now what

2203
04:02:28,420 --> 04:02:33,100
我们要做的是检查两个不同的条件，验证和验证
we are trying to do is we are trying to check for two different conditions authenticate and verify

2204
04:02:33,100 --> 04:02:39,380
如果我们满足了这两个函数，那么我们可以说我们想要返回一个
and in case we satisfy both of these functions then we can say that we want to return back a

2205
04:02:39,380 --> 04:02:45,920
消息，所以第一项将是 "okay"，然后让我们创建一个字符串，这样我们就可以说用户
message so the first would be the item of okay and then let's create a string so we can say the user

2206
04:02:45,920 --> 04:02:52,120
成功登录，但是如果身份验证或密码验证函数失败，那么在
logged in successfully but in case the function of authenticate or verify password fails so in

2207
04:02:52,120 --> 04:02:57,600
这种情况下，我们将进入else块，现在我们可以根据多个条件进行模式匹配，以防万一
that case we'll go to the else block now here we can pattern match on multiple conditions in case

2208
04:02:57,600 --> 04:03:04,100
我们得到一个元组，并且第一个元素是错误项，第二个元素可能是某种类型的
we get a tuple back and the first element is the item of error the second could be some kind of a

2209
04:03:04,100 --> 04:03:09,280
消息，所以那个时候我们只想返回相同的东西，所以我们想要返回
message so at that time we simply want to return back the same thing so we want to return back the

2210
04:03:09,280 --> 04:03:15,180
错误元组和返回的消息，但是如果我们遇到其他错误，我们可以指定
tuple of error and the message back but in case we get some other error so we can specify that

2211
04:03:15,180 --> 04:03:21,040
使用下划线，在所有其他情况下，我们只想返回一个项，表示
using the underscore so in all other cases we simply want to return back an item saying that

2212
04:03:21,040 --> 04:03:26,680
这是一个未经授权的操作，哦，我忘记在这里放逗号了，所以你的
this is an unauthorized operation oh i forgot to put a comma over here so this is how your

2213
04:03:26,680 --> 04:03:31,260
with块看起来是这样的，让我打开终端，让我们看看这个东西的实际效果
with block looks like so let me open up my terminal and let us see this thing in action

2214
04:03:31,260 --> 04:03:38,080
所以让我重新编译我的费用模块，让我清除屏幕，我们可以说从这里开始
so let me recompile my module of expense let me clear the screen and here we can say that from

2215
04:03:38,780 --> 04:03:45,080
expense dot login，首先让我们传递一个已经在我们的数据库中的用户，例如
expense dot login and first let us pass a user which is there inside our database for example

2216
04:03:45,080 --> 04:03:51,360
在我们的数据库中，我们有一个名为louis的用户，所以让我们传递louis这个参数，对于
we have the user of louis inside our database so let us pass the argument of louis and for the

2217
04:03:51,360 --> 04:03:56,060
密码没有关系，因为我们不会对密码做任何操作，让我们看一下
password it does not matter because we are not doing anything with the password and let us see

2218
04:03:56,060 --> 04:04:01,340
我们得到什么样的输出，是的，我们得到了一条消息，说louis已登录成功
what kind of output we are getting so yes we get back the message saying that louis logged in

2219
04:04:01,340 --> 04:04:07,020
成功了，让我们再试一次，使用一个不存在的用户，所以让我改一下
successfully let's try this one more time with the user who does not exist so let me change the

2220
04:04:07,020 --> 04:04:13,080
拼写，这次我们得到了一条错误消息，说未经授权，所以这就是关于使用的全部内容
spelling and this time we get back the message as error unauthorized so this was all about using the

2221
04:04:13,080 --> 04:04:18,180
elixir中的语法，就是这样了，感谢观看本视频，我们下一个视频再见
syntax with our elixir well that's it for this video and i will catch you in the next one

2222
04:04:18,180 --> 04:04:25,380
大家好，欢迎来到我们整个系列的最后一部分，现在这个最后的部分或者最后的章节是
hi and welcome to the last section of our entire series now this last part or the last section is

2223
04:04:25,380 --> 04:04:31,560
关于在elixir中构建一个统计库的所有内容，现在不要担心统计这个词
all about building a statistics library in elixir now don't worry about the word or statistics there

2224
04:04:31,560 --> 04:04:36,660
统计学没有什么大不了的，只要你知道基本的数学，比如加法
is nothing big about statistics as long as you know your basic mathematics like addition

2225
04:04:36,660 --> 04:04:41,760
减法、除法等等，你会完全没问题的，不用担心。
subtraction division and so on you would be absolutely fine you don't have to worry

2226
04:04:41,760 --> 04:04:47,380
现在我也想讨论一些关于函数式编程的事情。
now i also wanted to discuss about a couple of things regarding functional programming

2227
04:04:47,380 --> 04:04:52,820
我第一个问题是，你对函数式编程有困难吗？
my first question is do you have a hard time understanding functional programming

2228
04:04:52,820 --> 04:04:56,740
如果你的答案是肯定的，那么不用担心，你走在正确的道路上。
if your answer is yes then don't worry you are on the right track

2229
04:04:57,560 --> 04:05:04,560
现在我想说的是，我们的大脑太习惯面向对象的编程范式了。
now what i mean to say is our brains are so much used to the object oriented programming paradigms

2230
04:05:04,560 --> 04:05:10,160
或者命令式编程范式，这需要一些时间才能理解。
or the imperative programming paradigms that it takes some time for you to understand about

2231
04:05:10,160 --> 04:05:16,920
数据不变性和递归，所以不要担心，你需要的只是更多的实践。
data immutability and recursion so don't worry the only thing that you need is more practice

2232
04:05:16,920 --> 04:05:23,980
而创建另一个项目的意图是为了给你更多的练习，对吧，所以不要担心。
and the intent behind creating one more project is to give you more practice isn't it so don't

2233
04:05:23,980 --> 04:05:29,360
不用担心，这将是一个非常好的项目，我会向你展示我们如何稍微
worry and this is going to be a very nice project i will show you how we can slightly

2234
04:05:29,940 --> 04:05:35,580
优化我们的代码，如何创建一个不同的公共API，我们如何
architect our code in a much better way how we can create a different public api how we can

2235
04:05:35,580 --> 04:05:42,680
将我们的内部实现与公共API分开等等。总的来说，这将会
separate our our internal implementation from the public api and so on so overall this is going

2236
04:05:42,680 --> 04:05:48,120
这将是一个非常好的项目，所以跟着我，我会在下一个视频中见到你，到那时
to be a very nice project so hang on with me and i will catch you right in the next video till then

2237
04:05:48,120 --> 04:05:54,300
再见，让我们开始我们的统计项目，但在此之前，我想让你见见
bye so let's get started with our statistics project but before that i would like you to meet

2238
04:05:54,300 --> 04:06:02,620
我的朋友路易斯，他住在多伦多，拥有一家糖果店，他将帮助我们
my friend louis now louis stays in toronto and he owns a candies store and louis is going to help

2239
04:06:02,620 --> 04:06:09,120
了解更多关于统计学的知识，我们想要学习的第一个主题叫做中央
us to learn more about statistics the first topic that we want to learn is called as central

2240
04:06:09,120 --> 04:06:15,500
趋势，中央趋势就像是一个大章节，但不要担心，我会让它变得非常简单易懂
tendency so central tendency is like a big chapter but don't worry i will make it very simple for you

2241
04:06:15,500 --> 04:06:21,820
我们想要学习的第一件事是如何计算平均数，平均数其实没什么
the first thing that we want to study is how we can calculate a mean now mean is nothing it's

2242
04:06:21,820 --> 04:06:27,720
只是一个华丽词汇代表平均数，所以让我们试着更深入地学习这些概念
just a glorified word for average so let us try and study a little bit more about these concepts

2243
04:06:28,260 --> 04:06:35,800
现在路易斯住在多伦多，他想要统计多伦多的汽车数量，所以这个
now since louis stays in toronto louis wants to count the number of cars in toronto so this

2244
04:06:35,800 --> 04:06:42,700
这种数据被称为人口数据，这种数据被称为人口，因为
kind of data is called as your population data now this kind of data is called as population because

2245
04:06:42,700 --> 04:06:51,440
我们的数据范围只限于多伦多，对吧？我们只想要统计多伦多的汽车数量
our entire scope of data is just toronto right we only want to count the number of cars which are

2246
04:06:51,440 --> 04:07:00,300
在多伦多，所以这个车辆数量将是一个有限的数字，我们的数据范围或数据范围
in toronto so this number of cars is going to be a finite number and our scope or our range of data

2247
04:07:00,300 --> 04:07:08,880
仅限于多伦多，这就是为什么这种数据被称为您的人口数据，请现在让
is limited just to toronto that's why this kind of data is called as your population data now let

2248
04:07:08,880 --> 04:07:16,920
让我们看看接下来会发生什么，接下来路易斯想要计算多伦多的汽车数量，但是
us see next what's going to happen so next louis wants to count the number of cars in toronto but

2249
04:07:16,920 --> 04:07:23,840
这次数据不同，路易斯想要计算多伦多的汽车数量
this time the data is different louis wants to count the number of cars in toronto out of

2250
04:07:23,840 --> 04:07:30,660
加拿大所有汽车，所以这一次发生的是多伦多的汽车数量
all of the cars in canada so this time what is happening is the number of cars in toronto

2251
04:07:30,660 --> 04:07:39,100
变为样本数据，现在这个数据变成样本数据的原因是我们正在采用一个小样本
becomes your sample data now the reason why this data becomes sample data is we are taking a small

2252
04:07:39,100 --> 04:07:46,480
从加拿大所有汽车的更大数据集中选择多伦多的一个子集
subset of cars in toronto from a bigger set of data which is all of the cars in canada

2253
04:07:46,920 --> 04:07:53,300
所以加拿大所有汽车是你的人口，而且我们正在从中选择一个小样本
so all of the cars in canada is your population and since we are taking a small subset of cars

2254
04:07:53,300 --> 04:08:00,620
只是在多伦多，这就是为什么这种数据变成你的样本数据，所以让我们来看一下
just in toronto that's why this kind of data becomes your sample data so let us have a look

2255
04:08:00,620 --> 04:08:08,380
例如，路易斯想要计算他那里的人们的平均身高的另一个例子
at one more example for example louis wants to calculate the average height of people in his

2256
04:08:08,380 --> 04:08:15,600
房子，例如，如果有四个人住在他的房子里，那个数据就成为了
house so for example if there are four people staying in his house then that data becomes the

2257
04:08:15,600 --> 04:08:22,260
人口数据，现在在这种情况下发生的是人数是有限的
population data now what's happening in this case is the number of people are just limited

2258
04:08:22,260 --> 04:08:30,400
路易斯的房子，这就是为什么数据是你的人口数据，我们正在尝试计算
to the house of louis and that's why the data is your population data and we are trying to calculate

2259
04:08:30,400 --> 04:08:36,780
平均身高，这就是为什么我们只需计算这种类型的人口均值
the average height that's why we simply have to calculate the population mean for this kind of

2260
04:08:36,780 --> 04:08:45,340
数据接下来是路易斯想要计算多伦多人的平均身高
data the next is louis wants to calculate the average height of people in toronto out of all

2261
04:08:45,340 --> 04:08:52,820
加拿大的人，现在在这种情况下发生的是所有加拿大人都是这个数据
the people in canada now what's happening in this case all of the people in canada this data

2262
04:08:52,820 --> 04:08:59,900
是你的人口数据，我们的目标是只针对那些留在这里的人
is your population data and what we are targeting is we are targeting just the people who stay in

2263
04:08:59,900 --> 04:09:08,980
多伦多，所以这个数据是你的样本数据，这就是为什么这个平均值将成为你的样本均值
toronto so this data is your sample data that's why this average is going to be your sample mean

2264
04:09:08,980 --> 04:09:17,780
对了，现在让我们再看一个例子，路易斯在多伦多有一家糖果店，路易斯
right let's have a look at one more example now louis owns a candy store in toronto and louis

2265
04:09:17,780 --> 04:09:24,400
想要计算三小时内售出的糖果平均数量，现在需要什么样的数据
wants to calculate the average number of candies sold in three hours now what kind of a data would

2266
04:09:24,400 --> 04:09:31,440
这个是人口数据还是样本数据的问题，答案是这是人口数据。
this be would this be a population data or would this be a sample data the answer is this is going

2267
04:09:31,440 --> 04:09:39,060
因为我们的范围仅限于三个小时，所以这是人口数据。
to be a population data because our scope is just limited to three hours and since this is a

2268
04:09:39,060 --> 04:09:46,120
我们将计算人口平均数，所以举个例子，这些是
population data we would be calculating the population mean so for example these are the

2269
04:09:46,120 --> 04:09:52,680
不同种类的糖果，在第一小时，路易斯卖了10个糖果
different candies which are sold by louis in the first hour louis could sell 10 candies for the

2270
04:09:52,680 --> 04:10:00,680
第二小时，路易斯卖了20个糖果，第三小时卖了30个糖果，让我们看看如何
second hour louis sold 20 candies and for the third hour louis sold 30 candies so let us see how we can

2271
04:10:00,680 --> 04:10:07,560
计算这种数据的平均值，我们只需把所有的糖果加在一起
calculate the mean for this kind of a data so we have to just add all of the candies together so

2272
04:10:07,560 --> 04:10:12,940
这就是我们在这里做的，然后我们只需除以三，我们就得到
that's what we are doing right over here and then we simply have to divide by three so we get the

2273
04:10:12,940 --> 04:10:21,480
答案是每小时20个糖果，这意味着路易斯平均每小时能卖出20个糖果
answer as 20 candies for an hour that means louis was able to sell on an average 20 candies per hour

2274
04:10:21,480 --> 04:10:29,440
在前三个小时，现在让我们再看一个例子，这次路易斯想要
for the first three hours now let us have a look at one more example now this time louis wants to

2275
04:10:29,440 --> 04:10:37,220
计算在整个一天中前三个小时的平均售出糖果数，这种情况下
calculate the average candies sold in the first three hours out of the entire day now in this case

2276
04:10:37,220 --> 04:10:44,060
整个一天就是你的总体数据，而我们只限制在前三个小时
the full day would be your population data and since we are just limited to the first three hours

2277
04:10:44,060 --> 04:10:51,520
从整个一天中选择，这就是我们的样本数据，也就是说我们需要计算
out of the full day that means this is going to be our sample data which means we have to calculate

2278
04:10:51,520 --> 04:10:58,180
样本均值，这些是路易斯在整整八个小时内卖出的不同糖果
the sample mean now these are the different candies which are sold by louis throughout eight

2279
04:10:58,180 --> 04:11:04,240
一天中的小时数，所以第一个小时他卖出了10颗糖果，第二个小时卖出了20颗糖果
hours in the day so for the first hour he sold 10 candies for the second hour 20 candies for the

2280
04:11:04,240 --> 04:11:12,080
第三个小时卖出了30颗糖果，如此类推，让我们看看如何计算这种情况下的均值
third hour 30 candies and so on so let us see how we can calculate the mean in this case so again

2281
04:11:12,080 --> 04:11:18,860
前三个小时都保持不变，我们有相同的数字，所以第一个小时卖出10颗糖果
everything remains the same for the first three hours we have the same figures so 10 candies for

2282
04:11:18,860 --> 04:11:24,660
第二个小时卖出20颗糖果，下一个小时卖出30颗，所以我们有10加20加30
the first hour 20 for the second 30 for the next so that's why we have 10 plus 20 plus 30

2283
04:11:24,660 --> 04:11:30,760
我们计算的小时数是三，所以这里有三
and the number of hours for which we are calculating is three that's why we have three over here and

2284
04:11:30,760 --> 04:11:37,460
再次计算结果是20，这意味着在整个一天中的前三个小时，路易斯
again this evaluates to 20 that means for the first three hours in the entire day louis was

2285
04:11:37,460 --> 04:11:44,480
每小时能卖出20颗糖果，所以你可以看到均值的公式保持不变
able to sell 20 candies in an hour so you can see that the formula for the mean remains the same

2286
04:11:44,480 --> 04:11:50,660
那么区别是什么，区别在于视角，样本数据是不同的，
so what's the difference the difference is in perspective sample data is different and

2287
04:11:50,660 --> 04:11:56,080
人口数据是不同的，所以请记住这个视角，让我们看看如何
population data is different so keep this perspective in your mind and let us see how

2288
04:11:56,080 --> 04:12:02,360
您可以在下一个视频中编写这个人口和样本均值，让我们开始吧
you can code this population and sample mean right in the next video let us get started with

2289
04:12:02,360 --> 04:12:09,080
我们的统计项目，让我打开终端，让我们创建一个新的混合项目
our statistics project so let me open up my terminal and let's create a new mix project

2290
04:12:09,620 --> 04:12:15,320
让我进入我的函数式编程与elixir的文件夹，然后让我进入
so let me go inside my folder of functional programming with elixir and then let me go inside

2291
04:12:15,320 --> 04:12:21,800
我的代码文件夹，就在这里，我想创建一个新的项目，所以我可以说混合
my folder of code and right over here i want to create a new project so i can say mix

2292
04:12:22,860 --> 04:12:30,480
统计，让我在一个新窗口中打开文件夹，这将是我们的新
new stats and let me open up the folder in a new window so this is going to be our new

2293
04:12:30,480 --> 04:12:36,320
统计项目，让我们看看如何实现我们的人口和样本均值
statistics project so let us see how we can implement our population and sample mean

2294
04:12:36,320 --> 04:12:42,180
功能，所以首先要在lib文件夹里创建一个新文件夹
functionality so the first thing is inside the folder of lib let me create a new folder

2295
04:12:42,180 --> 04:12:50,680
让我把这个文件夹叫做中心趋势，现在在这个文件夹里让我们创建另一个文件
and let me call that folder as central tendency now inside this folder let us create another file

2296
04:12:50,680 --> 04:12:56,940
让我创建一个文件，这将用于计算我们的人口和样本均值
so let me create a file and this is going to be for calculating our population and sample mean

2297
04:12:56,940 --> 04:13:04,600
让我收起边栏，首先让我们定义一个模块，这将是统计模块。
let me collapse my sidebar and first let us define a module so this is going to be stats

2298
04:13:04,600 --> 04:13:11,980
中央趋势·均值，首先让我们看看如何计算总体均值。
dot central tendency dot mean so here first let us see how we can calculate our population mean

2299
04:13:12,180 --> 04:13:18,280
计算总体均值的公式非常简单，我们只需要取...
now the formula for calculating the population mean is very simple we simply have to take the

2300
04:13:18,280 --> 04:13:25,520
总和，然后我们需要将该总和除以计数。在统计学中，这个总和也被称为...
sum and we have to divide that sum with our count now in terms of statistics this sum is also called

2301
04:13:25,520 --> 04:13:32,400
作为σ，那么让我们先来看看如何计算总体均值，然后我们定义一个函数...
as sigma so let us see how we can calculate our population mean first so let's define a function

2302
04:13:32,400 --> 04:13:39,740
命名为population mean，这个函数接受一个数字列表作为参数，所以我们可以将参数称为...
called as population mean this function accepts a list of our numbers so we can call the argument

2303
04:13:39,740 --> 04:13:45,680
numbers，然后让我们看看如何为这个函数定义函数体，但在我们定义之前...
as numbers and let us see how we can define the body for this function but before we can define

2304
04:13:45,680 --> 04:13:52,440
在这里我们需要进行很多验证，我们需要进行的第一个验证是...
the body here we need to do a lot of validation the first validation that we need to do is we

2305
04:13:52,440 --> 04:13:59,520
需要检查这个numbers是否实际上是一个列表，所以我们要使用一个守卫...
need to check if this numbers is actually a list or not so for this we are going to use a guard

2306
04:13:59,520 --> 04:14:05,280
所以让我们查看官方文档，看看我们能否找到合适的守卫。
so let us go to the official documentation and let us try and see if we can find the right guard

2307
04:14:05,280 --> 04:14:12,460
在内核模块中，我们有一个用于保护的部分，所以让我们检查一下能否找到
or not so inside the module of kernel we have a section for guards so let us check if we can find

2308
04:14:12,460 --> 04:14:19,860
列表的保护器是否存在，所以如果我往下滚动一点，我们就有一个保护器，这个保护器是
the guard for list or not so if i scroll a little bit down here we have one guard and this guard is

2309
04:14:19,860 --> 04:14:26,720
就在这里是列表，所以让我们看看我们如何在我们的函数中使用这个保护器，所以这里我们
right over here is list so let us see how we can use this guard in our function so here what we

2310
04:14:26,720 --> 04:14:34,080
可以说我们希望有一个保护器，它说是列表，让我们传递变量 numbers
can say that we want to have a guard saying that is list and let us pass the variable of numbers

2311
04:14:34,080 --> 04:14:40,500
基本上我们想做的就是只有在 numbers 是一个列表时才运行这个函数
so basically what we want to do is we want to run this function only when this numbers is a list

2312
04:14:40,500 --> 04:14:47,200
现在我们已经验证了这个 numbers 是一个列表，但是如果这个 numbers 不是一个列表呢？
now we have validated that this numbers is a list but what happens if this numbers is not a list

2313
04:14:47,200 --> 04:14:53,320
或者如果 numbers 是一个空列表，那么让我们在顶部定义一个更多的函数重载
or in case the numbers is an empty list so let's define one more function overload on the top

2314
04:14:53,320 --> 04:15:00,660
所以在这里我们可以定义我们想要定义相同的函数 population mean，如果我们的情况是
so here we can define that we want to define the same function population mean and in case if we

2315
04:15:00,660 --> 04:15:07,500
空列表，那么此时返回一个空列表，现在我们可以返回一个空列表
blank list then at that time return back a blank list now we can either return back a blank list

2316
04:15:07,500 --> 04:15:13,460
或者我们也可以返回一些错误，例如，如果你想返回某种类型的
or we can also return some kind of an error so for example if you want to return some kind of

2317
04:15:13,460 --> 04:15:19,260
发生错误，我们可以返回一个元组，并且可以说这是一个错误，我们可以
an error so we can return back a tuple and we can say that this is going to be an error and we can

2318
04:15:19,260 --> 04:15:25,740
还可以返回一个消息，说数据无效，所以你可以选择是否返回
also return back a message saying that invalid data so it's up to you if you want you can return

2319
04:15:25,740 --> 04:15:30,860
返回一个空列表，或者可以返回一个错误元组，这只是供您参考
back a blank list or you can return back an error tuple so this is just for your reference

2320
04:15:30,860 --> 04:15:36,900
现在让我们看看如何定义我们总体均值的实际体。在这里，我们需要
so now let us see how we can define the actual body for our population mean so here we need to

2321
04:15:36,900 --> 04:15:43,420
首先，我们需要找出总和或Sigma，然后我们需要除以
do two things first we need to find out the sum or the sigma and then we have to divide by the

2322
04:15:43,420 --> 04:15:49,720
计数，但在我们进行所有这些操作之前，我们需要进行一次额外的验证。到目前为止，我们所拥有的是
count but before we do all of these things we need to do one more validation so till now what we have

2323
04:15:50,440 --> 04:15:58,720
这些数字只是一个列表，但我们还需要验证这是否是一个数字列表。所以让我们
that this numbers is just a list but we also need to validate that this is a list of numbers so let

2324
04:15:58,720 --> 04:16:04,700
看看我们如何验证这个。因此让我们创建一个流程，这里我们可以说首先
us see how we can validate this one so here let us create a pipeline so here we can say that first

2325
04:16:04,700 --> 04:16:10,720
我希望你拿这些数字，然后将这些数字放入一个函数中
i want you to take the numbers and then i want you to pipe these numbers inside a function and

2326
04:16:10,720 --> 04:16:17,400
我们可以称之为验证我们的数字列表的函数。所以我们还没有定义这个函数，但是让我们
we can call that function as validate our number list so we have not defined this function but let's

2327
04:16:17,400 --> 04:16:22,560
在这里定义它，所以让我复制这个，并让我们在这里定义一个函数。
define it right over here so let me just copy this one and let us define a function right over

2328
04:16:22,560 --> 04:16:28,760
在这里验证我们的数字列表，接受我们的数字列表，让我们看看我们如何定义。
here so validate our numbers list this accept our list of numbers and let us see how we can define

2329
04:16:28,760 --> 04:16:34,560
对于这个函数的主体，让我们返回一个元组，第一个条件将是。
the body for this one now for this function let us return back a tuple the first condition would be

2330
04:16:34,560 --> 04:16:41,880
要么是true，要么是false，第二个条件将是数字，所以如果这个列表不是一个列表的话。
either true or false the second condition would be the numbers so in case if this list is not a list

2331
04:16:41,880 --> 04:16:48,420
我们将返回false，但如果这是一个有效的数字列表，那么我们将发送。
of numbers we will send back false but in case this is a valid list of numbers then we will send

2332
04:16:48,420 --> 04:16:54,320
在这里返回一个true，所以让我们看看我们如何做这个事情，不幸的是，它非常简单。
back a true right over here so let us see how we can do this thing unfortunately it's very simple

2333
04:16:54,320 --> 04:17:01,960
所以在这里让我们使用内置的枚举模块，我想使用all函数，现在这个all函数需要。
so here let us use the inbuilt module of enum and i want to use the function of all now this all takes

2334
04:17:01,960 --> 04:17:08,400
两个参数，第一个将是我们的枚举，所以让我们传递我们数字的枚举，这个也。
two arguments the first is going to be our enum so let us pass the enum of our numbers and this also

2335
04:17:08,400 --> 04:17:14,340
接受一个函数，所以让我们在这里定义一个函数，现在每次迭代发生的情况是。
takes a function so let us define a function right over here now what happens for each iteration

2336
04:17:14,340 --> 04:17:20,340
我们将从我们的数字列表中接收一个元素，我们只需检查是否。
we are going to receive an element from our list of numbers and we simply have to check if that

2337
04:17:20,340 --> 04:17:27,640
元素是数字还是其他类型，我们可以使用一个内建函数叫做 is_number，让我们
element is a number or not so here we can use an inbuilt function called as is number and let us

2338
04:17:27,640 --> 04:17:33,520
将元素传递给这个函数，这样我们就定义了一个函数来验证所有的数字
pass the element to this one and that's it we have defined a function to validate all our numbers as

2339
04:17:33,520 --> 04:17:40,360
让我们为这个函数写入类型说明，这样我们可以说规格为
let us also write the type specification for this function so here we can say that the specs for

2340
04:17:40,360 --> 04:17:47,600
验证数字列表，所以这个函数接收一个数字列表，并返回一个元组
validate number list so this receives a list of our numbers and this function returns a tuple

2341
04:17:47,600 --> 04:17:54,400
第一个元素将是我们的布尔值，第二个元素是我们的数字列表，让我们回到
the first is going to be our boolean the second element is our list of numbers let us go back to

2342
04:17:54,400 --> 04:17:59,960
我们的均值函数，现在我们已经完成了所有的验证，现在这个函数
our function of population mean so now we have all of the validation in place now this function

2343
04:17:59,960 --> 04:18:06,900
返回一个元组，所以我们可以简单地取出那个元组，并将输出
returns back a tuple so what we can do is we can simply take that tuple and we can pipe the output

2344
04:18:06,900 --> 04:18:13,600
传递给另一个函数，让我们将这个新函数称为计算均值，所以我们有了
in yet another function so let us call the new function as calculate population mean so we have

2345
04:18:13,600 --> 04:18:19,540
还没有定义这个函数，但是让我们在这里定义它，所以我们可以说定义
not yet defined this function but let's define it right over here so here we can say that define

2346
04:18:19,540 --> 04:18:26,260
计算均值，让我们写下 do 和 end 代码块，现在这个计算的函数
calculate population mean and let us write the do and end blocks now this function of calculate

2347
04:18:26,260 --> 04:18:33,860
总体均值接收一个元组，第一个是我们的条件，第二个是我们的数字列表
population mean receives a tuple right the first is our condition the second one is our list of

2348
04:18:33,860 --> 04:18:40,660
数字，现在这个条件可以是真的或者是假的，所以假设我们有一个真的条件
numbers now this condition can either be true or it can be false so suppose we have a true condition

2349
04:18:40,660 --> 04:18:46,700
那么我们可以在这里进行模式匹配，但如果它是假的，我们可以再创建一个
then we can have a pattern match right over here but in case if it is false then we can create yet

2350
04:18:46,700 --> 04:18:52,400
另一个子句，所以让我复制粘贴这个，所以在这里我可以说，如果参数
another clause so let me just copy and paste this one so here i can say that in case the argument

2351
04:18:52,400 --> 04:18:58,020
是假的，我们就不必对数字做任何操作，所以让我用下划线替换数字
is false and we don't have to do anything with numbers so let me replace numbers with my underscore

2352
04:18:58,020 --> 04:19:04,800
如果第一个参数是假的，那就意味着验证失败了，所以我们可以再次
in case the first argument is false that means the validation has failed so here we can again

2353
04:19:04,800 --> 04:19:10,760
发送相同的元组错误，所以让我复制这个，然后粘贴在这里，现在让
send the same tuple error so let me copy this one and let me paste it right over here now let

2354
04:19:10,760 --> 04:19:22,380
我们来看看如何计算总体均值，如果第一个参数是真的，那么这里
us see how we can calculate the population mean in case the first argument is true now here the

2355
04:19:22,380 --> 04:19:29,500
我们可以通过使用内置函数来计算总和，所以我们可以说 enum 命令总和下一个
and we can calculate the sum by using an inbuilt function so we can say enum dot sum the next one

2356
04:19:29,500 --> 04:19:35,720
我们只需要用总和除以计数，所以为此让我们再定义一个函数
is we simply have to divide the sum with the count so for this let us define one more function and

2357
04:19:35,720 --> 04:19:41,360
让我们把这个函数称为mean，所以这个函数将接收两个参数，第一个
let us call that function as mean so this function is going to receive two arguments the first

2358
04:19:41,360 --> 04:19:46,880
参数是用于sigma，它来自这个，第二个参数是用于
argument would be for the sigma which comes from this one the second argument would be for the

2359
04:19:46,880 --> 04:19:52,680
计数，我们可以在这里传递第二个参数，所以我们可以说enum dot count，让
count and we can pass the second argument right over here so we can say enum dot count and let

2360
04:19:52,680 --> 04:19:58,540
我们传递数字列表，现在让我们在这里创建这个函数，所以我们可以说定义
us pass the list of numbers now let us create this function right over here so we can say define

2361
04:19:58,540 --> 04:20:04,680
mean函数的第一个参数是sigma，第二个参数是计数，对于这个
mean the first argument is for the sigma the second argument is for the count and for this

2362
04:20:04,680 --> 04:20:10,900
实现非常简单，我们只需要将sigma除以计数，就这样
one the implementation is very easy we simply have to divide the sigma with the count and that's it

2363
04:20:10,900 --> 04:20:16,560
我们已经实现了总体均值，但我们可以做很多改进，正如你所见，我们有
we have implemented population mean but we can do a lot of improvements so as you can see we have

2364
04:20:16,560 --> 04:20:23,040
一些重复，我们这里也有一些错误的tuple，顶部也一样，让我也放一些
some repetition we have this tuple of error here as well as on the top as well let me also put some

2365
04:20:23,040 --> 04:20:29,380
分隔线，为了方便我们，这将是一个独立的事情和计算
separator lines for our convenience so this is going to be separate thing and calculation for

2366
04:20:29,380 --> 04:20:35,060
总体均值将成为一个单独的部分，这也是一个，所以现在让
the population mean is going to be a separate section and one for this one as well so now let

2367
04:20:35,060 --> 04:20:41,260
我们回到顶部，看看如何改进我们的代码，所以现在首先我们有这个
us go to the top and let us see how we can improve our code so now the first thing is we have this

2368
04:20:41,800 --> 04:20:48,700
两次，所以让我们为错误创建一个单独的模块，让我打开我的侧边栏，进入目录
twice so let's create a separate module for errors so let me open up my sidebar and inside the directory

2369
04:20:48,700 --> 04:20:56,220
在lib目录下，让我创建一个名为errors的新模块，并将该模块定义为stats dot
errors
of lib let me create a new module called as errors and let us define the module as stats dot errors

2370
04:20:56,220 --> 04:21:02,940
让我们在这里定义一个函数，我们可以说定义无效的数据类型，我们只是想
let us define a function over here so we can say define invalid data types and we simply want to

2371
04:21:02,940 --> 04:21:09,840
返回元组，让我返回mean文件，让我只是复制这一行
return back the tuple so let me go back to the file of mean and let me just copy this line let

2372
04:21:09,840 --> 04:21:16,020
回到我们的errors文件，让我粘贴在这里，现在让我们回到这个文件
go back to our errors file and let me paste it right over here now let us go back to this file

2373
04:21:16,020 --> 04:21:22,020
让我折叠我的侧边栏，现在我们可以在顶部创建一个别名，这样我们可以说
let me collapse my sidebar and now what we can do is we can create an alias on the top so we can say

2374
04:21:22,020 --> 04:21:30,020
让我们为stats dot errors创建一个别名，我们可以用errors替换这一行
that let us create an alias for our stats dot errors and we can replace this line with errors

2375
04:21:30,020 --> 04:21:36,000
点无效的数据类型，我们可以在这里做同样的事情，让我删除这一行
dot invalid data type and we can do the same thing right over here so let me take out this line and

2376
04:21:36,820 --> 04:21:43,840
errors dot invalid data type，现在我想做一件事，我想删除这个函数
errors dot invalid data type now i want to do one more thing i want to take out this function of

2377
04:21:43,840 --> 04:21:49,300
将它验证为另一个模块，因为我知道我们将需要这个。
validate into yet another module and this is because i simply know that we would require this

2378
04:21:49,300 --> 04:21:56,060
为了未来的实现，我们还需要一个验证函数，所以在lib中让我们创建一个文件。
validation function for our future implementation as well so inside lib let us create one more file

2379
04:21:56,060 --> 04:22:03,180
再次为验证器定义模块，模块名必须是stats.validators。
for validators again let us define the module and the module name has to be stats dot validators

2380
04:22:03,180 --> 04:22:09,600
让我们回到这个文件，我只想把所有的东西都删掉，所以让我把它拿出来，我们去...
let us go back to this file i simply want to cut everything out so let me take it out let us go to

2381
04:22:09,600 --> 04:22:15,820
我们的验证器文件，让我把它粘贴在这里，这个我们可以做一个小的...
our file of validators and let me paste it right over here now for this one we can do one slight

2382
04:22:15,820 --> 04:22:21,120
由于我们将此文件放在另一个模块中，所以我们可以进行一个小的验证。
validation since we have taken this file inside another module so here we can do one small

2383
04:22:21,120 --> 04:22:28,580
同样也需要验证，所以让我们在这里定义一个保护条件，当我们的数字是列表且如果...
validation as well so let's define a guard over here so when is list for our numbers and in case

2384
04:22:28,580 --> 04:22:33,800
如果这个验证失败，那么让我们在这里创建一个更多的子句，所以在这里我们可以简单地...
if this validation fails then let us create one more clause right over here so here we can simply

2385
04:22:33,800 --> 04:22:40,200
忽略这个参数，我们可以简单地返回一个错误，所以让我再次为它创建一个别名...
ignore the argument and we can simply return back an error so let me again create an alias for the

2386
04:22:40,200 --> 04:22:47,060
在这里创建一个错误，所以让我们为我们的stats.errors创建一个别名，并返回一个错误。
error right over here so let's create an alias for our stats dot errors and let us return an error

2387
04:22:47,060 --> 04:22:53,200
就在这里，我们可以说错误是无效的数据类型，现在对此进行规范。
right over here so here we can say that errors dot invalid data type now the specification for this

2388
04:22:53,200 --> 04:23:00,020
即将改变，这个无效数据类型的函数返回一个元组，让我们定义一个。
is going to change so this function of invalid data type this returns a tuple let us define a

2389
04:23:00,020 --> 04:23:05,980
对于这个也要规定，让我们去错误这里，我们可以说规范是。
specification for this one as well so let us go to errors and here we can say that the specification

2390
04:23:05,980 --> 04:23:12,300
对于我们的无效数据类型函数，所以这个函数不接受任何参数，只是简单地。
for our function of invalid data type so this function does not accept anything and this simply

2391
04:23:12,300 --> 04:23:19,340
返回一个原子，并且下一个参数的类型是字符串，所以让我复制所有这些。
return backs an atom and the next argument is of the type of string so let me copy all of these

2392
04:23:19,340 --> 04:23:26,160
让我们回到我们的验证文件，现在发生的情况是如果这个数字是一个。
let us go back to our file of validators so now what's happening is in case if this number is a

2393
04:23:26,160 --> 04:23:32,820
数字列表，我们返回一个元组，但是如果验证失败，我们只需返回一个。
list of numbers we send back a tuple but in case the validation fails then we simply send back an

2394
04:23:32,820 --> 04:23:38,980
错误和错误的格式是我们有一个原子，我们还有一条消息，接下来的。
error and the format for the error is we have an atom and we also have a message right the next

2395
04:23:38,980 --> 04:23:44,240
问题是，由于我们将这个函数放在一个不同的模块中，让我们回到我们的模块。
thing is since we have taken this function in a different module let us go back to our module of

2396
04:23:44,240 --> 04:23:49,860
mean，并且让我们在顶部创建一个别名，所以我们可以说我们想要再别名一个。
mean and let us create an alias on the top so here we can say that we want to alias yet another

2397
04:23:49,860 --> 04:23:56,580
从同一个模块中导入errors和validators，这样我们就可以创建一个别名。
module so we can say that we want to alias stats dot validators now what we are doing is we are

2398
04:23:56,580 --> 04:24:02,440
从同一个模块中导入errors和validators，这样我们就可以创建一个别名。
importing errors and validators from the same module of stats so we can create an alias on the

2399
04:24:02,440 --> 04:24:07,760
同一行上，让我来告诉你如何操作，我们只需要将其包裹在花括号中。
same line let me show you how so we just have to wrap this inside our curly brackets and we can

2400
04:24:07,760 --> 04:24:13,600
我们也要为validators创建一个别名，在这一行上。
say that we also want to create an alias for validators as well now right over here on line

2401
04:24:14,360 --> 04:24:21,620
这个函数在validators模块中，所以我们可以写validators.validate(numbers_list)。
this function is inside our module of validators so validators dot validate numbers list let me

2402
04:24:21,620 --> 04:24:29,520
删除这些行，让我打开终端，我们可以进入ix，让我们为其创建一个别名。
take out these lines let me open up my terminal and we can go inside our ix let us create an alias for

2403
04:24:29,520 --> 04:24:37,220
stats.central_tendency.mean，让我整理一下，然后我们来调用我们的总体均值。
stats dot central tendency dot mean let me clear up everything and let us call our population mean

2404
04:24:37,220 --> 04:24:45,760
我们可以说是总体均值，让我们传入10、20和30，按预期我们会得到答案。
so we can say population mean and let us pass 10 20 and 30 and as expected we get back the answer

2405
04:24:45,760 --> 04:24:52,000
得到20，现在让我们传入一个空列表，看看发生了什么，所以在这种情况下，我们得到了一个错误。
as 20 now let us pass an empty list and see what's happening so in this case we are getting back an

2406
04:24:52,000 --> 04:24:58,220
错误显示无效的数据类型，请看看如果我们传入其他参数会发生什么。
error saying that error invalid data type now watch what happens if we pass some other argument

2407
04:24:58,220 --> 04:25:04,300
例如，如果我们传递a、b和c，那么在这种情况下我们会得到一个错误，提示没有函数
for example if we pass a b and c so in this case we get an error saying that no function

2408
04:25:04,300 --> 04:25:09,940
这是因为我们没有为这个函数定义一个捕获所有情况的子句
clause matching and this is because we have not defined a catch all clause for this function of

2409
04:25:09,940 --> 04:25:15,340
总体均值，所以让我们在这里定义一个子句，我们可以说定义
population mean so let us define one clause right over here so here we can say that define

2410
04:25:15,340 --> 04:25:21,800
总体均值，而在这种情况下我们只想忽略参数并返回
population mean and in this case we simply want to ignore the argument and we simply want to return

2411
04:25:21,800 --> 04:25:30,100
返回我们的错误.无效的数据类型，让我打开终端，让我们重新编译我们的模块
back our errors dot invalid data type let me open up the terminal and let us recompile our module of

2412
04:25:30,100 --> 04:25:36,460
让我清理一切，让我们再试一次相同的语句，这一次我们得到了一个很好的
let me clear up everything and let us try the same statement one more time so this time we get a nice

2413
04:25:36,460 --> 04:25:42,920
错误，说错误的无效数据类型，这就是我们可以创建总体均值的方式，但我们还没有完成
error saying that error invalid data type so this is how we can create population mean but we are

2414
04:25:42,920 --> 04:25:49,200
还没有完成，我们还需要实现样本均值，但幸运的是样本均值和
not yet done we also need to implement the sample mean but luckily the formula for sample mean and

2415
04:25:49,200 --> 04:25:55,420
总体均值是相同的，所以让我们非常快速地实现我们的样本均值，让我拿出来
population mean is the same so let us very quickly implement our sample mean as well let me take out

2416
04:25:55,420 --> 04:26:01,340
我不需要这些注释，让我将分隔线粘贴在顶部，现在在这里让
the comments i don't need the comments let me paste the separator line on top now here let

2417
04:26:01,340 --> 04:26:06,260
再次复制这个分隔线，并为样本均值创建一个更多的函数，对吗？
me again copy this separator line and let us create one more function for sample mean right

2418
04:26:06,260 --> 04:26:11,540
在这里，我们可以说我们想要为样本均值定义一个函数，现在这个
over here so here we can say that we want to define a function for our sample mean now this

2419
04:26:11,540 --> 04:26:18,440
函数接受一个数字列表，我们只需调用我们的总体均值并传入我们的
function accepts a list of numbers and we simply have to call our population mean and pass our

2420
04:26:18,440 --> 04:26:24,120
数字列表，就这样我们现在有了样本均值和总体均值的函数
list of numbers so that's it now we have the function for sample mean and population mean as

2421
04:26:24,120 --> 04:26:29,380
让我们也为这个函数定义规范，所以我们可以说
let us also define the specifications for this function so here we can say that the

2422
04:26:29,380 --> 04:26:35,760
总体均值的规范，这个函数接收一个数字列表，这个
specifications for our population mean now this function receives a list of numbers and this

2423
04:26:35,760 --> 04:26:42,080
函数将返回一个数字，或者它将返回一个错误，现在
function is going to return back a number or it is going to return back an error now the type of

2424
04:26:42,080 --> 04:26:48,720
我们的错误是这样的，第一个元素是原子，第二个元素是类型
our error is like this the first element is the atom and the second element is of the type of

2425
04:26:48,720 --> 04:26:55,520
让我也将这个规范复制给我们的样本均值，让我将它粘贴在这里，让
let me copy this specification for our sample mean as well let me paste it right over here and let

2426
04:26:55,520 --> 04:27:02,420
我将名称从总体更改为样本，接下来我们可以对我们的一些改进做更多的工作
me change the name from population to sample next we can do a couple of more improvements for our

2427
04:27:02,420 --> 04:27:08,220
现在代码里，如果你看到这个计算总体均值的函数和这个均值的函数，那么
code now if you see this function of calculate population mean and this function of mean so

2428
04:27:08,220 --> 04:27:14,040
这些函数只是我们的私有函数，所以让我们将它们声明为私有函数，这样就变成了
these functions are just our private functions so let us declare them as private so this becomes

2429
04:27:14,040 --> 04:27:20,480
我们的p的定义也变成了我们的私有函数，对于我们的mean也是一样的情况
our def of p and this also becomes our private function the same thing happens for our mean as

2430
04:27:20,480 --> 04:27:25,580
好的，这也变成了我们的私有函数，现在让我打开终端，让我们试试
well this also becomes our private function now let me open up the terminal let us try

2431
04:27:25,580 --> 04:27:31,320
重新编译一次，让我清理一下所有东西，然后让我们尝试调用相同的
and recompile this one more time let me clear up everything and let us try to invoke the same

2432
04:27:31,320 --> 04:27:39,060
函数再试一次，让我们传入10、20和30的列表，这是用于总体均值的
function one more time let us pass the list of 10 20 and 30 so this is for the population mean

2433
04:27:39,060 --> 04:27:45,120
我们也让我们尝试一下样本均值，让我用样本均值来替代这个
and let us try the same thing for our sample mean as well so let me replace this with sample mean

2434
04:27:45,120 --> 04:27:50,480
我们得到了相同的答案，现在的情况是每次我们都要创建一个
and we get the same answer back now what's happening is every time we have to create an

2435
04:27:50,480 --> 04:27:56,980
但是我们可以做的是将我们的公共API和私有API分开
alias but instead what we can do is we can separate our public api from our private api

2436
04:27:56,980 --> 04:28:04,660
所以如果我打开我的侧边栏，我们有一个stats.ex的模块，正如你所看到的，这个文件不是
so if i open up my sidebar we have a module for stats.ex and as you can see that this file is not

2437
04:28:04,660 --> 04:28:11,440
我们现在要做的是将这个stats文件作为我们的公共API，所以不要做任何事情。
doing anything so what we want to do is we want to make this stats file as our public api so what

2438
04:28:11,440 --> 04:28:18,000
我的意思是最终用户只需引用这个单个文件就可以使用所有功能。
i mean to say is the end users can just reference this single file to use all of the functionality

2439
04:28:18,000 --> 04:28:23,000
让我来向你展示我们如何做到这一点，让我把所有这些东西拿出来，这些都不是必需的。
so let me show you how we can do this let me take out all of these things these are not required

2440
04:28:23,000 --> 04:28:28,380
让我折叠侧边栏，我们在这里定义一个用于人口平均值的函数。
let me collapse the sidebar and let us define a function for our population mean right over here

2441
04:28:28,380 --> 04:28:34,160
现在这个函数接收我们的数字列表，从这里我们可以简单地调用我们的函数。
now this function receives the list of our numbers and from here we can simply call our function of

2442
04:28:34,160 --> 04:28:41,620
所以我们可以说我们想为我们的stats.dot.central.tendency.mean创建一个别名。
so we can say that we want to create an alias for our stats dot central tendency dot mean

2443
04:28:41,620 --> 04:28:48,300
对于这个函数，我们可以简单地将它委派给mean.dot.population.mean，并让我们传递
and for this function we can simply delegate it to mean dot population mean and let us pass the

2444
04:28:48,300 --> 04:28:54,680
数字参数，所以现在我们大大简化了我们的API，现在让我打开终端
argument of numbers so now we have simplified our api quite a lot now let me open up the terminal

2445
04:28:54,680 --> 04:29:01,160
让我们重新编译stats模型，让我清理一切，现在我们可以做的就是简单地
let us recompile the model of stats let me clear up everything now what we can do is we can simply

2446
04:29:01,160 --> 04:29:09,440
stats.dot.population.mean，让我们传递参数10、20和30，然后我们得到了
stats dot population mean and let us pass the argument of 10 20 and 30 and we get back the

2447
04:29:09,440 --> 04:29:16,300
正确答案，现在让我们回到我们的代码，我们可以对这个做一个小小的改进。
right answer now let us go back to our code and we can do one slight improvement for this one

2448
04:29:16,300 --> 04:29:21,820
现在，我们可以使用一个叫做“def delegate”的东西，而不仅仅是调用这个函数。
now instead of just calling this function we can use something which is called as def delegate

2449
04:29:21,820 --> 04:29:27,360
首先让我给你展示一下，然后我可以解释给你听，在这里我们可以使用一个叫做“def
delegate”的新关键字。
so first let me show you and then i can explain it to you so here we can use the new keyword called

2450
04:29:28,160 --> 04:29:34,440
“delegate”的第一个参数是我们函数的名称，所以我们函数的名称是“population”。
delegate the first argument is the name of our function so the name of our function is population

2451
04:29:34,440 --> 04:29:40,300
mean，所以让我把它粘贴到这里，现在这个函数也接受一个参数，而这个参数是。
mean so let me paste it right over here now this function also accepts one argument and the argument

2452
04:29:40,300 --> 04:29:46,160
是用于我们数字列表的，现在我们想做的就是简单地将这个委托给。
is for the list of our numbers and now what we want to do is we simply want to delegate this

2453
04:29:46,160 --> 04:29:54,100
我们的mean模型的函数，就是这样，第四行和第五行就是做这个事情的。
function to our model of mean and that's it line number four and line number five does the exact

2454
04:29:54,100 --> 04:29:59,720
同样的事情，所以让我对这一行进行注释，这是不需要的，让我打开我的终端。
same thing so let me comment on this line this is not required let me open up my terminal let

2455
04:29:59,720 --> 04:30:05,920
我们重新编译一下统计模块，让我把一切都清理干净，然后再调用同一个函数。
us recompile the module of stats let me clear up everything and let me call the same function one

2456
04:30:05,920 --> 04:30:12,320
再次调用一次，正如预期的那样，这个工作得很好，让我们再创建一个“def delegate”函数。
more time and as expected this is working just fine let us create one more def delegate for the

2457
04:30:12,320 --> 04:30:18,180
样本均值，所以我们只需要将名称从总体均值改为样本均值。
sample mean so here we simply have to change the name from population mean to sample mean so

2458
04:30:18,180 --> 04:30:24,260
每当我们调用stats.sample mean时，该函数将被委托给mean.sample。
whenever we call stats dot sample mean this function will be delegated to mean dot sample

2459
04:30:24,260 --> 04:30:31,200
均值，让我打开终端，让我们重新编译相同的模块，让我清理一切。
mean let me open up my terminal let us recompile the same module let me clear up everything and

2460
04:30:31,200 --> 04:30:37,320
在这里，我可以说stats这次我想计算样本均值，让我传递
here i can say that stats dot this time i want to calculate the sample mean and let me pass the

2461
04:30:37,320 --> 04:30:43,660
三、四、五、六和七的参数，这次我们得到的答案是五，那就是这样了。
argument of three four five six and seven and this time we get the answer as five well that's it for

2462
04:30:43,660 --> 04:30:49,240
这个视频就到这里，我会在下一个视频中见到你们，让我们开始我们的统计项目吧。
this video and i will catch you in the next one let us get started with our statistics project

2463
04:30:49,900 --> 04:30:56,600
所以让我打开终端，让我们创建一个新的mix项目，让我进入我的文件夹
so let me open up my terminal and let's create a new mix project so let me go inside my folder

2464
04:30:56,600 --> 04:31:03,560
关于elixir的函数式编程，然后让我进入我的代码文件夹
of functional programming with elixir and then let me go inside my folder of code and right over

2465
04:31:03,560 --> 04:31:12,080
这里我想创建一个新项目，所以我可以说mix new stats，让我在一个窗口里打开这个文件夹
here i want to create a new project so i can say mix new stats and let me open up the folder in a

2466
04:31:13,060 --> 04:31:19,720
所以这将是我们的新统计项目，让我们看看我们如何实施我们的
window so this is going to be our new statistics project so let us see how we can implement our

2467
04:31:19,720 --> 04:31:26,180
群体和样本均值功能，所以第一件事是在lib文件夹内，让我创建一个新文件夹。
population and sample mean functionality so the first thing is inside the folder of lib let me

2468
04:31:26,180 --> 04:31:34,280
创建一个新文件夹，让我把它叫做中心倾向，现在，在这个文件夹内
create a new folder and let me call that folder as central tendency now inside this folder let

2469
04:31:34,280 --> 04:31:40,740
让我们创建另一个文件，让我创建一个文件，用于计算我们的总体
us create another file so let me create a file and this is going to be for calculating our population

2470
04:31:40,740 --> 04:31:48,140
和样本均值，让我折叠侧边栏，首先，让我们定义一个模块
and sample mean let me collapse my sidebar and first let us define a module so this is going to

2471
04:31:48,140 --> 04:31:56,900
叫做stats.dot.central_tendency.dot.mean，所以首先让我们看看如何计算我们的总体
be stats dot central tendency dot mean so here first let us see how we can calculate our population

2472
04:31:56,900 --> 04:32:03,540
均值，现在计算总体均值的公式非常简单，我们只需要将
mean now the formula for calculating the population mean is very simple we simply have to take the

2473
04:32:03,540 --> 04:32:10,720
总和，然后将该总和除以计数，根据统计学的说法，这个总和也被称为
sum and we have to divide that sum with our count now in terms of statistics this sum is also called

2474
04:32:10,720 --> 04:32:17,700
sigma，所以首先让我们看看如何计算我们的总体均值，让我们定义一个函数
as sigma so let us see how we can calculate our population mean first so let's define a function

2475
04:32:17,700 --> 04:32:25,020
叫做population_mean，这个函数接受一个数字列表作为参数
called as population mean this function accepts a list of our numbers so we can call the argument

2476
04:32:25,020 --> 04:32:30,980
作为numbers，然后让我们看看如何为这个函数定义主体，但在我们定义之前
as numbers and let us see how we can define the body for this function but before we can define

2477
04:32:30,980 --> 04:32:36,940
这里我们需要做很多验证，我们需要做的第一个验证是
the body here we need to do a lot of validation the first validation that we need to do is

2478
04:32:36,940 --> 04:32:43,820
我们需要检查这个数字是否实际上是一个列表，为此我们将使用
we need to check if this numbers is actually a list or not so for this we are going to use

2479
04:32:43,820 --> 04:32:50,280
一个守卫，所以让我们去官方文档，看看我们能否找到正确的
a guard so let us go to the official documentation and let us try and see if we can find the right

2480
04:32:50,280 --> 04:32:56,920
守卫或者不是，在内核模块中，我们有一个守卫的部分，所以让我们检查一下
guard or not so inside the module of kernel we have a section for guards so let us check if

2481
04:32:56,920 --> 04:33:03,780
我们能否找到用于列表的守卫，如果我往下滚动一点，这里有一个守卫
we can find the guard for list or not so if i scroll a little bit down here we have one guard

2482
04:33:03,780 --> 04:33:10,260
这个守卫就在这里，是列表，所以让我们看看如何在我们的函数中使用这个守卫
and this guard is right over here is list so let us see how we can use this guard in our function

2483
04:33:10,820 --> 04:33:18,060
所以在这里，我们可以说我们想要一个守卫，说它是一个列表，让我们传递
so here what we can say that we want to have a guard saying that is list and let us pass the

2484
04:33:18,060 --> 04:33:24,360
变量的数字，所以基本上我们想要做的是只有当
variable of numbers so basically what we want to do is we want to run this function only when

2485
04:33:24,360 --> 04:33:30,300
这个数字是一个列表，现在我们已经验证了这个数字是一个列表，但是会发生什么
this numbers is a list now we have validated that this numbers is a list but what happens

2486
04:33:30,300 --> 04:33:36,560
如果这个数字不是一个列表，或者数字是一个空列表的情况下，那么让我们定义一个
if this numbers is not a list or in case the numbers is an empty list so let us define one

2487
04:33:36,560 --> 04:33:43,260
在顶部进行更多的函数重载，这样我们可以定义我们想要定义的相同函数。
more function overload on the top so here we can define that we want to define the same function

2488
04:33:43,260 --> 04:33:50,340
总体均值，如果我们得到一个空列表，那么就返回一个空列表。
population mean and in case if we get a blank list then at that time return back a blank list

2489
04:33:50,340 --> 04:33:57,080
现在我们可以返回一个空列表，或者也可以返回某种错误，例如
now we can either return back a blank list or we can also return some kind of an error so for example

2490
04:33:57,080 --> 04:34:02,300
如果你想返回某种错误，那么我们可以返回一个元组，并且可以说
if you want to return some kind of an error so we can return back a tuple and we can say that

2491
04:34:02,300 --> 04:34:08,360
这将是一个错误，我们还可以返回一条消息，说明数据无效。
this is going to be an error and we can also return back a message saying that invalid data

2492
04:34:08,360 --> 04:34:14,480
所以这取决于你，如果你愿意，你可以返回一个空列表，或者你可以返回一个错误的元组。
so it's up to you if you want you can return back a blank list or you can return back an error tuple

2493
04:34:14,480 --> 04:34:20,000
这只是供你参考，现在让我们看看如何为我们的实际主体定义。
so this is just for your reference so now let us see how we can define the actual body for our

2494
04:34:20,000 --> 04:34:26,120
总体均值，所以这里我们需要做两件事，首先我们需要找出总和或sigma
population mean so here we need to do two things first we need to find out the sum or the sigma

2495
04:34:26,120 --> 04:34:32,200
然后我们必须除以计数，但在我们做所有这些之前，我们需要做
and then we have to divide by the count but before we do all of these things we need to do

2496
04:34:32,200 --> 04:34:38,760
另一个验证，到目前为止，我们验证的是这些数字只是一个列表。
one more validation so till now what we have validated is that this numbers is just a list

2497
04:34:38,760 --> 04:34:45,920
但我们还需要验证这是否是一个数字列表，让我们看看如何验证
but we also need to validate that this is a list of numbers so let us see how we can validate this

2498
04:34:45,920 --> 04:34:51,880
首先，让我们创建一个流水线，让我们说首先我想让你取出这些数字
one so here let us create a pipeline so here we can say that first I want you to take the numbers

2499
04:34:51,880 --> 04:34:57,920
然后，我希望你将这些数字传入一个函数中，并且我们可以称呼这个函数为
and then I want you to pipe these numbers inside a function and we can call that function as

2500
04:34:57,920 --> 04:35:04,340
验证我们的数字列表，我们还没有定义这个函数，但是让我们在这里定义它
validate our number list so we have not defined this function but let's define it right over here

2501
04:35:04,340 --> 04:35:09,600
所以让我复制这个，让我们在这里定义一个函数，验证我们的数字
so let me just copy this one and let us define a function right over here so validate our numbers

2502
04:35:09,600 --> 04:35:15,220
这个函数接受我们的数字列表，让我们看看如何定义它的主体部分
list this accept our list of numbers and let us see how we can define the body for this one

2503
04:35:15,220 --> 04:35:21,400
现在，对于这个函数，让我们返回一个元组，第一个条件可以是真或假
now for this function let us return back a tuple the first condition would be either true or false

2504
04:35:21,400 --> 04:35:27,860
第二个条件是数字，如果这个列表不是一个数字列表的话
the second condition would be the numbers so in case if this list is not a list of numbers

2505
04:35:27,860 --> 04:35:34,680
我们将返回假，但是如果这是一个有效的数字列表，我们将返回真
we will send back false but in case this is a valid list of numbers then we will send back a true

2506
04:35:34,680 --> 04:35:40,680
就在这里，让我们看看我们如何做这件事，不幸的是它非常简单，所以在这里让我们
right over here so let us see how we can do this thing unfortunately it's very simple so here let

2507
04:35:40,680 --> 04:35:47,580
我们使用内置的枚举模块，我想使用all函数，这个函数需要两个参数。
us use the inbuilt module of enum and I want to use the function of all now this all takes two

2508
04:35:47,580 --> 04:35:54,520
第一个参数是我们的枚举类型，所以让我们传递我们的数字枚举，这个函数还需要一个参数。
the first is going to be our enum so let us pass the enum of our numbers and this also takes a

2509
04:35:54,520 --> 04:36:00,540
所以让我们在这里定义一个函数，每次迭代时会发生什么。
function so let us define a function right over here now what happens for each iteration we are

2510
04:36:00,540 --> 04:36:06,060
我们将从数字列表中接收一个元素，我们只需要检查该元素是否为数字。
going to receive an element from our list of numbers and we simply have to check if that element

2511
04:36:06,060 --> 04:36:13,500
判断该元素是否为数字，我们可以使用一个名为is number的内置函数，让我们将该元素传递给它。
is a number or not so here we can use an inbuilt function called as is number and let us pass the

2512
04:36:13,500 --> 04:36:19,080
将该元素传递给它，这样我们就定义了一个函数来验证我们的所有数字。
element to this one and that's it we have defined a function to validate all our numbers as well

2513
04:36:19,080 --> 04:36:25,660
让我们还为这个函数编写类型规范，所以在这里我们可以说这个函数的规范是
let us also write the type specification for this function so here we can say that the specs for

2514
04:36:25,660 --> 04:36:32,880
验证数字列表，所以它接收一个数字列表，并返回一个元组。
validate number list so this receives a list of our numbers and this function returns a tuple

2515
04:36:32,880 --> 04:36:39,700
第一个元素是一个布尔值，第二个元素是我们的数字列表，让我们回到
the first is going to be our boolean the second element is our list of numbers let us go back to

2516
04:36:39,700 --> 04:36:45,780
总体均值的函数，现在我们已经完成了所有的验证，现在这个函数返回的是
function of population mean so now we have all of the validation in place now this function returns

2517
04:36:45,780 --> 04:36:52,880
返回一个元组，我们可以做的是简单地获取那个元组并将输出连接到另一个函数。
back a tuple so what we can do is we can simply take that tuple and we can pipe the output in yet

2518
04:36:52,880 --> 04:36:59,360
另一个函数，我们可以称之为计算人口平均数的新函数，所以我们还没有。
another function so let us call the new function as calculate population mean so we have not yet

2519
04:36:59,360 --> 04:37:05,600
定义了这个函数，但是让我们在这里定义它，我们可以说定义计算函数。
defined this function but let's define it right over here so here we can say that define calculate

2520
04:37:05,600 --> 04:37:12,180
平均值，让我们现在编写do和end块，现在这个计算人口的函数。
population mean and let us write the do and end blocks now this function of calculate population

2521
04:37:12,180 --> 04:37:19,680
平均值接收一个元组，第一个是我们的条件，第二个是我们的数字列表。
mean receives a tuple right the first is our condition the second one is our list of numbers

2522
04:37:19,680 --> 04:37:26,360
现在这个条件可以是真也可以是假，所以假设我们有一个真条件，那么
now this condition can either be true or it can be false so suppose we have a true condition then

2523
04:37:26,360 --> 04:37:32,000
我们可以在这里进行模式匹配，但是如果为假，我们可以创建yet。
we can have a pattern match right over here but in case if it is false then we can create yet

2524
04:37:32,580 --> 04:37:38,500
所以让我只是复制粘贴这个，所以在这里我可以说如果参数为假的话
so let me just copy and paste this one so here I can say that in case the argument is false

2525
04:37:38,500 --> 04:37:43,320
我们不需要对数字做任何处理，所以让我用下划线替换数字
and we don't have to do anything with numbers so let me replace numbers with my underscore

2526
04:37:43,320 --> 04:37:50,100
如果第一个参数为假，那意味着验证失败，所以在这里我们可以再次做
in case the first argument is false that means the validation has failed so here we can again

2527
04:37:50,100 --> 04:37:56,060
发送相同的元组错误，所以让我复制这个，然后粘贴到这里，现在，让我
send the same tuple error so let me copy this one and let me paste it right over here now let

2528
04:37:56,060 --> 04:38:02,300
我们来看看如果第一个参数是真的，我们如何计算总体平均数，现在这里
us see how we can calculate the population mean in case the first argument is true now here the

2529
04:38:02,300 --> 04:38:07,720
公式非常简单，首先我们要取出数字，然后我们要计算总和
formula is very simple first we have to take the numbers next we have to calculate the sum

2530
04:38:07,720 --> 04:38:14,820
我们可以通过使用内置函数来计算总和，所以我们可以说枚举点和下一个
and we can calculate the sum by using an inbuilt function so we can say enum dot sum the next one

2531
04:38:14,820 --> 04:38:21,080
我们只需将总和除以计数即可，所以为此让我们定义一个更多的函数，并且
is we simply have to divide the sum with the count so for this let us define one more function and

2532
04:38:21,080 --> 04:38:26,660
将该函数称为均值，所以这个函数将接收两个参数，第一个
call that function as mean so this function is going to receive two arguments the first

2533
04:38:26,660 --> 04:38:32,180
参数将用于来自此处的sigma，第二个参数将用于
argument would be for the sigma which comes from this one the second argument would be for the

2534
04:38:32,180 --> 04:38:37,960
计数，我们可以将第二个参数传递到这里，所以我们可以说枚举点计数，让
count and we can pass the second argument right over here so we can say enum dot count and let

2535
04:38:37,960 --> 04:38:43,840
我们传递数字列表，现在让我们创建这个函数，所以我们可以说定义
us pass the list of numbers now let us create this function right over here so we can say define

2536
04:38:43,840 --> 04:38:49,980
均值的第一个参数是sigma，第二个参数是计数，以及对于这个
mean the first argument is for the sigma the second argument is for the count and for this

2537
04:38:49,980 --> 04:38:56,400
实现非常简单，我们只需要将sigma与计数相除，就是这样我们
the implementation is very easy we simply have to divide the sigma with the count and that's it we

2538
04:38:56,400 --> 04:39:01,880
实现了总体均值，但我们还可以进行很多改进，所以你可以看到我们有
have implemented population mean but we can do a lot of improvements so as you can see we have

2539
04:39:01,880 --> 04:39:08,300
一些重复，我们这里有一个错误的元组，以及在顶部也有，让我也放一些
some repetition we have this tuple of error here as well as on the top as well let me also put some

2540
04:39:08,300 --> 04:39:14,660
分隔线以方便我们，所以这将是一个独立的事物和计算
separator lines for our convenience so this is going to be separate thing and calculation for

2541
04:39:14,660 --> 04:39:20,840
总体均值将成为一个独立的部分，还有一个独立的部分，所以现在让我们去
population mean is going to be a separate section and one for this one as well so now let us go to

2542
04:39:20,840 --> 04:39:26,780
顶部，让我们看看如何改进我们的代码，现在第一件事是我们有这个错误
the top and let us see how we can improve our code so now the first thing is we have this error

2543
04:39:26,780 --> 04:39:33,660
元组两次，所以让我们为错误创建一个单独的模块，让我打开我的侧边栏，在里面
tuple twice so let's create a separate module for errors so let me open up my sidebar and inside the

2544
04:39:33,660 --> 04:39:39,440
lib目录，让我创建一个名为errors的新模块，让我们定义这个模块
directory of lib let me create a new module called as errors and let us define the module

2545
04:39:39,440 --> 04:39:46,900
as stats.dot.errors，让我们在这里定义一个函数，这样我们就可以定义无效的数据类型
as stats dot errors let us define a function over here so we can say define invalid data types

2546
04:39:46,900 --> 04:39:53,560
我们只想返回这个元组，所以让我回到均值文件，让我只是
and we simply want to return back the tuple so let me go back to the file of mean and let me just

2547
04:39:53,560 --> 04:40:00,200
复制这一行，让我们回到我们的错误文件，然后让我在这里粘贴它，现在我们可以
copy this line let us go back to our errors file and let me paste it right over here now let us

2548
04:40:00,200 --> 04:40:05,890
回到这个文件，让我折叠我的侧边栏，现在我们可以做的是创建一个别名
go back to this file let me collapse my sidebar and now what we can do is we can create an alias

2549
04:40:06,490 --> 04:40:14,210
我们可以说，让我们为我们的stats dot errors创建一个别名，并且我们可以替换这一行
we can say that let us create an alias for our stats dot errors and we can replace this line

2550
04:40:14,210 --> 04:40:20,430
用errors dot invalid data
type替换，并且我们可以在这里做同样的事情，所以让我拿出来
with errors dot invalid data type and we can do the same thing right over here so let me take out

2551
04:40:20,430 --> 04:40:27,270
这一行，我们可以说errors dot invalid data type，现在我想再做一件事
this line and we can say that errors dot invalid data type now i want to do one more thing i want

2552
04:40:27,270 --> 04:40:33,270
将这个验证函数取出到另一个模块中，这是因为我知道
to take out this function of validate into yet another module and this is because i simply know

2553
04:40:33,270 --> 04:40:39,470
我们将来也需要这个验证函数，所以在lib中
we would require this validation function for our future implementation as well so inside lib let

2554
04:40:39,470 --> 04:40:46,550
我们再创建一个文件给validators，让我们定义模块，模块名必须是
us create one more file for validators again let us define the module and the module name has to

2555
04:40:46,550 --> 04:40:53,250
是stats dot validators，让我们回到这个文件，我只是想把所有东西都删掉，所以让
be stats dot validators let us go back to this file i simply want to cut everything out so let

2556
04:40:53,250 --> 04:40:59,810
我把它拿出来，让我们去我们的validators文件，然后让我在这里粘贴，现在针对这个
me take it out let us go to our file of validators and let me paste it right over here now for this

2557
04:40:59,810 --> 04:41:05,130
我们可以进行一次轻微的验证，因为我们已经将这个文件放入了另一个模块中，所以在这里
we can do one slight validation since we have taken this file inside another module so here

2558
04:41:05,130 --> 04:41:12,250
我们也可以进行一次小的验证，所以让我们在这里定义一个守卫，这样当我们的列表为空时
we can do one small validation as well so let's define a guard over here so when is list for our

2559
04:41:12,250 --> 04:41:17,710
如果这个验证失败了，那么让我们在这里创建一个额外的子句
numbers and in case if this validation fails then let us create one more clause right over here

2560
04:41:17,710 --> 04:41:24,270
所以在这里我们可以忽略这个参数，然后返回一个错误，所以让我再次
so here we can simply ignore the argument and we can simply return back an error so let me again

2561
04:41:24,270 --> 04:41:30,470
在这里为这个错误创建一个别名，让我们为我们的 stats.dot.errors 创建一个别名
create an alias for the error right over here so let's create an alias for our stats dot errors

2562
04:41:30,470 --> 04:41:36,750
然后让我们在这里返回一个错误，所以在这里我们可以说 errors.dot.invalid data
type
and let us return an error right over here so here we can say that errors dot invalid data type

2563
04:41:36,750 --> 04:41:42,610
现在这个函数的规范将会改变，所以这个 invalid data type 的函数
now the specification for this one is going to change so this function of invalid data type

2564
04:41:42,610 --> 04:41:48,390
这个函数返回一个元组，让我们也为它定义一个规范，所以让我们去 errors
this returns a tuple let us define a specification for this one as well so let us go to errors

2565
04:41:48,390 --> 04:41:54,950
在这里我们可以说这个 invalid data type 函数的规范，所以这个函数
and here we can say that the specification for our function of invalid data type so this function

2566
04:41:54,950 --> 04:42:01,730
不接受任何参数，只是返回一个原子，而下一个参数的类型是
does not accept anything and this simply return backs an atom and the next argument is of the type

2567
04:42:01,730 --> 04:42:08,710
字符串的话，让我复制所有这些东西，让我们回到我们的验证器文件，那么现在怎么样？
of string so let me copy all of these things let us go back to our file of validators so now what's

2568
04:42:08,710 --> 04:42:15,130
发生的是，如果这个数字是一个数字列表，我们发送回一个元组，但是如果
happening is in case if this number is a list of numbers we send back a tuple but in case the

2569
04:42:15,130 --> 04:42:21,070
验证失败，那么我们只需发送一个错误，并且该错误的格式是我们有一个
validation fails then we simply send back an error and the format for the error is we have an

2570
04:42:21,070 --> 04:42:26,490
原子，我们还有一条消息，接下来的事情是，由于我们在一个
atom and we also have a message right the next thing is since we have taken this function in a

2571
04:42:26,490 --> 04:42:32,830
不同的模块，让我们回到我们的平均模块，并在顶部创建一个别名，所以在这里
different module let us go back to our module of mean and let us create an alias on the top so here

2572
04:42:32,830 --> 04:42:38,570
我们可以说我们想给另一个模块起一个别名，所以我们可以说我们想给统计模块起一个别名
we can say that we want to alias yet another module so we can say that we want to alias stats

2573
04:42:38,570 --> 04:42:44,670
点验证器，现在我们正在做的是从相同的地方导入错误和验证器
dot validators now what we are doing is we are importing errors and validators from the same

2574
04:42:44,670 --> 04:42:50,450
统计模块，所以我们可以在同一行上创建一个别名，让我告诉你怎么做，我们只需要
module of stats so we can create an alias on the same line let me show you how so we just have to

2575
04:42:50,450 --> 04:42:56,110
将其包裹在我们的花括号中，我们可以说我们也想为其创建一个别名
wrap this inside our curly brackets and we can say that we also want to create an alias for

2576
04:42:56,110 --> 04:43:02,850
同样，现在在这里，在第10行，这个函数在我们的模块中
validators as well now right over here on line number 10 this function is inside our module of

2577
04:43:02,850 --> 04:43:09,170
验证器，所以验证器点验证数字列表让我删除这些行，让我打开
validators so validators dot validate numbers list let me take out these lines let me open up

2578
04:43:09,890 --> 04:43:18,030
我们可以进入我们的 ix，让我们为 stats 点 central tendency 点 mean
创建一个别名
and we can go inside our ix let us create an alias for stats dot central tendency dot mean

2579
04:43:18,030 --> 04:43:24,710
让我清理一切，然后让我们调用我们的总体平均值，这样我们就可以说总体平均值
let me clear up everything and let us call our population mean so we can say population mean and

2580
04:43:24,710 --> 04:43:33,670
让我们传递 10 20 和 30，预期我们得到的答案是 20，现在让我们传递一个空的
let us pass 10 20 and 30 and as expected we get back the answer as 20 now let us pass an empty

2581
04:43:33,670 --> 04:43:38,770
列表，看看发生了什么，在这种情况下，我们得到了一个错误，错误信息为
list and see what's happening so in this case we are getting back an error saying that error

2582
04:43:38,770 --> 04:43:44,830
无效的数据类型，现在看看如果我们传递一些其他的参数会发生什么，例如，如果我们传递
invalid data type now watch what happens if we pass some other argument for example if we pass

2583
04:43:44,830 --> 04:43:51,370
a b 和 c，所以在这种情况下，我们得到了一个错误，错误信息为没有匹配的函数子句，这是因为
a b and c so in this case we get an error saying that no function clause matching and this is

2584
04:43:51,370 --> 04:43:56,730
因为我们没有为这个总体平均值函数定义一个捕获所有子句，所以让我们
because we have not defined a catch all clause for this function of population mean so let us

2585
04:43:56,730 --> 04:44:03,170
在这里定义一个子句，所以在这里我们可以说定义总体平均值，在这种情况下
define one clause right over here so here we can say that define population mean and in this case

2586
04:44:03,170 --> 04:44:10,530
只是希望忽略该参数，并希望返回我们的错误，错误信息为无效数据
simply want to ignore the argument and we simply want to return back our errors dot invalid data

2587
04:44:10,530 --> 04:44:16,930
打开终端机让我重新编译我们的mean模组，让我先清除一下
type let me open up the terminal and let us recompile our module of mean let me clear up

2588
04:44:16,930 --> 04:44:22,490
让一切归零，让我们再试一次相同的语句，这样这次我们会得到一个很好的错误提示
everything and let us try the same statement one more time so this time we get a nice error saying

2589
04:44:22,490 --> 04:44:28,970
那个错误，无效的数据类型，这就是我们如何创建样本均值，但我们还没完成
that error invalid data type so this is how we can create population mean but we are not yet done

2590
04:44:28,970 --> 04:44:34,950
我们还需要实现样本均值，但幸运的是样本均值和母体均值的公式是相同的
we also need to implement the sample mean but luckily the formula for sample mean and population

2591
04:44:34,950 --> 04:44:41,290
平均值是相同的，所以让我们非常快速地实现我们的样本均值，让我把所有的都拿出来
mean is the same so let us very quickly implement our sample mean as well let me take out all of the

2592
04:44:41,290 --> 04:44:47,190
注释我不需要注释，让我在顶部贴上分隔线，现在让我再次
comments i don't need the comments let me paste the separator line on top now here let me again

2593
04:44:47,190 --> 04:44:52,030
复制这个分隔线，让我们在这里创建一个样本均值的额外函数
copy this separator line and let us create one more function for sample mean right over here

2594
04:44:52,030 --> 04:44:57,230
所以在这里我们可以说我们想要为我们的样本均值定义一个函数，现在这个函数
so here we can say that we want to define a function for our sample mean now this function

2595
04:44:57,230 --> 04:45:04,050
接受一个数字列表，我们只需要调用我们的母体均值并传递我们的列表
accepts a list of numbers and we simply have to call our population mean and pass our list

2596
04:45:04,050 --> 04:45:09,770
的数字，这就是了，现在我们有了样本均值和母体均值的函数
of numbers so that's it now we have the function for sample mean and population mean as well

2597
04:45:09,770 --> 04:45:15,330
让我们也为这个函数定义规格，这样我们可以说规格是
let us also define the specifications for this function so here we can say that the specifications

2598
04:45:15,330 --> 04:45:27,210
对于我们的总体均值，这个函数现在接收一个数字列表，这个函数将会
for our population mean now this function receives a list of numbers and this function is going to

2599
04:45:27,210 --> 04:45:34,310
错误是这样的，第一个元素是原子，第二个元素是字符串类型的
error is like this the first element is the atom and the second element is of the type of string

2600
04:45:34,310 --> 04:45:40,810
让我也为样本均值复制这个规格，让我把它粘贴到这里，然后
let me copy this specification for our sample mean as well let me paste it right over here and let

2601
04:45:40,810 --> 04:45:47,730
我把名称从总体改为样本，接下来我们还可以做一些更改来改进我们的
me change the name from population to sample next we can do a couple of more improvements for our

2602
04:45:47,730 --> 04:45:53,370
现在如果你看到这个计算总体均值的函数和这个均值函数
code now if you see this function of calculate population mean and this function of mean so

2603
04:45:53,370 --> 04:45:59,330
这些函数只是我们的私有函数，所以让我们把它们声明为私有的，这样它就变成了
these functions are just our private functions so let us declare them as private so this becomes

2604
04:45:59,330 --> 04:46:05,770
我们的p定义，这也变成了我们的私有函数，对于我们的均值也是同样的情况
our def of p and this also becomes our private function the same thing happens for our mean as

2605
04:46:05,770 --> 04:46:11,670
好吧，这也变成了我们的私有函数，现在让我打开终端，让我们尝试重新编译一下
well this also becomes our private function now let me open up the terminal let us try and recompile

2606
04:46:11,670 --> 04:46:17,570
这一次让我清除一切，让我们尝试调用相同的函数一次
this one more time let me clear up everything and let us try to invoke the same function one

2607
04:46:17,570 --> 04:46:25,470
让我们再花一些时间来传递10、20和30的列表，这是用于总体均值的，我们试试看。
more time let us pass the list of 10 20 and 30 so this is for the population mean and let us try

2608
04:46:25,470 --> 04:46:31,610
对于样本均值也是一样，所以让我用样本均值来替换，然后我们得到
the same thing for our sample mean as well so let me replace this with sample mean and we get the

2609
04:46:31,610 --> 04:46:37,410
相同的答案。现在的情况是，每次我们都必须创建一个别名，但是相反的是，
same answer back now what's happening is every time we have to create an alias but instead what

2610
04:46:37,410 --> 04:46:44,930
我们可以将我们的公共API与私有API分开，所以如果我打开边栏，我们有
we can do is we can separate our public api from our private api so if i open up my sidebar we have

2611
04:46:44,930 --> 04:46:51,970
stats.ex模块，正如你所见，这个文件什么都没做，所以我们想要做的是
module for stats.ex and as you can see that this file is not doing anything so what we want to do

2612
04:46:51,970 --> 04:46:59,230
我们希望将这个stats文件作为我们的公共API，所以我的意思是最终用户可以
is we want to make this stats file as our public api so what i mean to say is the end users can

2613
04:46:59,230 --> 04:47:05,230
只需引用这个单独的文件来使用所有功能，让我来演示一下我们如何做到这一点
just reference this single file to use all of the functionality so let me show you how we can do this

2614
04:47:05,230 --> 04:47:10,750
让我把这些东西都拿出来，这些都不需要的，让我折叠边栏，然后让我们
let me take out all of these things these are not required let me collapse the sidebar and let us

2615
04:47:10,750 --> 04:47:16,270
一个用于总体均值的函数就在这里，这个函数接收我们的列表
a function for our population mean right over here now this function receives the list of our

2616
04:47:16,270 --> 04:47:21,470
然后我们可以从这里简单地调用我们的总体均值函数，所以我们可以说
numbers and from here we can simply call our function of population mean so we can say that

2617
04:47:21,470 --> 04:47:28,310
我们想为我们的stats.dot.central tendency.mean函数创建一个别名。
we want to create an alias for our stats dot central tendency dot mean and for this function

2618
04:47:28,310 --> 04:47:35,250
我们可以简单地委托给mean.dot.population mean，让我们传递一个数字的参数。
we can simply delegate it to mean dot population mean and let us pass the argument of numbers so

2619
04:47:35,250 --> 04:47:41,410
我们已经大大简化了我们的API，现在让我打开终端，重新编译一下。
we have simplified our api quite a lot now let me open up the terminal let us recompile the

2620
04:47:41,410 --> 04:47:48,090
统计模块，让我清理一下，现在我们可以简单地调用stats.dot。
module of stats let me clear up everything now what we can do is we can simply call stats dot

2621
04:47:48,090 --> 04:47:55,590
population mean，并让我们传递参数10、20和30，我们会得到正确的答案。
population mean and let us pass the argument of 10 20 and 30 and we get back the right answer

2622
04:47:55,590 --> 04:48:02,510
现在让我们回到我们的代码中，我们可以对这个做一个小小的改进，现在不是。
now let us go back to our code and we can do one slight improvement for this one now instead of

2623
04:48:02,510 --> 04:48:08,570
调用这个函数，我们可以使用一个叫做def delegate的东西，所以首先让我展示一下。
calling this function we can use something which is called as def delegate so first let me show

2624
04:48:08,570 --> 04:48:14,150
你，然后我可以解释给你听，所以在这里我们可以使用一个叫做def delegate的新关键字。
you and then i can explain it to you so here we can use the new keyword called as def delegate

2625
04:48:14,150 --> 04:48:20,110
第一个参数是我们的函数的名字，所以我们的函数的名字是population mean。
the first argument is the name of our function so the name of our function is population mean

2626
04:48:20,110 --> 04:48:25,590
所以让我把它粘贴到这里，现在这个函数还接受一个参数，这个参数。
so let me paste it right over here now this function also accepts one argument and the argument

2627
04:48:25,590 --> 04:48:31,430
这是我们数字列表的一部分，现在我们要做的就是将它委托给我们的模块。
is for the list of our numbers and now what we want to do is we simply want to delegate this

2628
04:48:31,430 --> 04:48:38,850
将这个函数委托给我们的平均值模块，就是这样，第四行和第五行做的就是这个。
function to our module of mean and that's it line number four and line number five does the

2629
04:48:38,850 --> 04:48:44,710
完全一样，所以让我对这一行进行注释，这是不必要的，让我打开我的终端。
exact same thing so let me comment on this line this is not required let me open up my terminal

2630
04:48:44,710 --> 04:48:50,830
让我们重新编译统计模块，让我把一切清理干净，然后让我调用同样的函数。
let us recompile the module of stats let me clear up everything and let me call the same function

2631
04:48:50,830 --> 04:48:57,630
再试一次，正如预期的那样，这个工作得很好，让我们再创建一个def委托。
one more time and as expected this is working just fine let us create one more def delegate for the

2632
04:48:58,250 --> 04:49:04,210
所以在这里，我们只需要把名称从总体均值改为样本均值，这样每当我们...
so here we simply have to change the name from population mean to sample mean so whenever we

2633
04:49:04,210 --> 04:49:10,850
调用stats.dot样本均值时，该函数将委托给mean.dot样本均值，让我打开。
call stats dot sample mean this function will be delegated to mean dot sample mean let me open up

2634
04:49:10,850 --> 04:49:17,570
我的终端，让我们重新编译相同的模块，让我清理一切，这样我可以说...
my terminal let us recompile the same module let me clear up everything and here i can say that

2635
04:49:17,570 --> 04:49:23,830
这次我想计算样本均值，让我传入3、4、...
stats dot this time i want to calculate the sample mean and let me pass the argument of three four

2636
04:49:23,830 --> 04:49:29,490
5、6和7，这次我们得到的答案是5，好了，这个视频到此结束。
five six and seven and this time we get the answer as five well that's it for this video

2637
04:49:29,490 --> 04:49:34,470
而且我会在下一个中抓住你，现在让我们继续下一部分，看看如何
and i will catch you in the next one now let us move on to the next part and let us see how

2638
04:49:34,470 --> 04:49:41,050
我们可以计算一些被称为中位数的东西，现在我所做的是在幕后
we can calculate something which is called as a median now what i have done is behind the scenes

2639
04:49:41,050 --> 04:49:48,050
我创建了一个名为中位数的新文件，并且为此定义了模型
i have created a new file called as median and i have also defined the model for this one and to

2640
04:49:48,530 --> 04:49:56,010
简单来说，我添加了很多文档，让我们看看中位数的确切含义
simple i have added a lot of documentation so let us see what do we exactly mean by the median

2641
04:49:56,010 --> 04:50:02,550
让我们来看看这个场景，假设路易斯在卖糖果
so let us have a look at this scenario right over here so suppose louis is selling candies

2642
04:50:02,550 --> 04:50:10,950
连续九个小时，这些是每个小时的糖果销量，第一个小时
for nine hours and these are the sales of the candies for each respective hour for the first

2643
04:50:10,950 --> 04:50:17,530
路易斯在第一小时卖出了10颗糖果，第二小时卖出了40颗糖果，第三小时卖出了
hour louis could sell 10 candies for the second hour louis sold 40 candies for the third he sold

2644
04:50:17,530 --> 04:50:25,190
以此类推，这些是路易斯在连续九个小时内每个小时卖出的糖果数量
20 and so on so these are the number of candies that louis sold each hour throughout nine hours

2645
04:50:25,190 --> 04:50:31,670
在他的工作时间内，让我们看看中位数的确切含义，中位数什么都不是，它只是
of his shift now let us see what do we exactly mean by median so median is nothing it is just

2646
04:50:31,670 --> 04:50:38,890
一个中心值，或者说它只是将测量结果分为两个相等部分的值
a central value or it's just the value that divides the measurement into two equal parts

2647
04:50:39,370 --> 04:50:45,730
所以我们想要达到的目标是找到一个能够将我们的测量结果分成两部分的值
so what we want to achieve is we want to find a value that will divide our measurements in

2648
04:50:45,730 --> 04:50:52,530
前50%和后50%，计算中位数也非常容易，所以这是
first 50 percent and the next 50 percent and it's very easy to calculate median as well so this is

2649
04:50:52,530 --> 04:50:59,290
一个非常简单的计算中位数的算法，我们算法的第一步是
going to be a very simple algorithm for calculating the median the first step in our algorithm is

2650
04:50:59,290 --> 04:51:05,710
对我们的列表进行排序，所以在这里我们可以看到我们有一个按糖果销售额排序的列表
sorting our list so here we can see we have a sorted list of all of the sales of candies for

2651
04:51:05,710 --> 04:51:13,010
前九个小时，我们算法的第二部分是需要计算元素的数量
the first nine hours for the second part of our algorithm is we need to count the number of elements

2652
04:51:13,010 --> 04:51:20,350
在我们的列表中，现在有两种情况，第一种是如果我们的计数是奇数，第二种是
inside our list and now here there can be two things first if our count is odd and the second

2653
04:51:20,350 --> 04:51:29,090
如果计数是偶数，那么如果计数是奇数，事情就非常简单，我们只需要
one is if the count is even now if the count is odd then the things are very simple we simply

2654
04:51:29,090 --> 04:51:36,650
取中间的值，这个值就成为我们的中位数，所以例如在这个例子中，50就是
take the middle value and that value becomes our median so for example in this case 50 is right at

2655
04:51:36,650 --> 04:51:44,090
我们左边有四个值，右边也有四个值，所以50就成为我们的
we have four values to the left and we have four values to the right so 50 becomes our

2656
04:51:44,090 --> 04:51:51,830
中位数，下一个情况是如果计数是偶数，那么我们要做的是
median the next scenario is what happens if the count is even at that time what we do is

2657
04:51:51,830 --> 04:51:59,710
我们从中心取两个值，所以在这种情况下，40和50是两个值，现在请看一下。
we take two values from the center so in this case 40 and 50 are two values now just have a look at

2658
04:51:59,710 --> 04:52:06,010
这个列表只包含八个值，我从这个列表中取出了最后一个值90。
this list this list contains only eight values i have taken out the last value of 90 from this list

2659
04:52:06,010 --> 04:52:12,990
现在，由于这是一个偶数列表，我们只需从中心取两个值，所以我们有40和50。
now since this is an even list we simply take two values from the center so we have 40 and 50

2660
04:52:12,990 --> 04:52:18,530
作为中心，正如你所看到的，左边有三个值，右边也有三个值。
as the center so as you can see there are three values to the left and we have three values to

2661
04:52:18,530 --> 04:52:25,150
然后我们简单地对它们取平均值，所以40加50除以2，我们得到的答案是。
the right and then we simply average them out so 40 plus 50 divided by 2 and we get the answer as

2662
04:52:25,150 --> 04:52:33,170
45，45成为你的中位数，这就是我们将要实现的算法。
45 and 45 becomes your median value so this is how we are going to implement our algorithm for

2663
04:52:33,170 --> 04:52:38,230
计算中位数，让我们看看如何将所有这些内容转化为代码。
calculating the median so let us see how we can translate all of these things into code

2664
04:52:38,230 --> 04:52:44,810
让我回到顶部，在这里我们可以看到我定义了一个名为stats点的模块。
so let me go to the top and here we can see that i have defined a module by the name of stats dot

2665
04:52:44,810 --> 04:52:51,610
中央趋势点中位数，现在让我们开始吧，让我们定义第一个。
central tendency dot median and now let's get started with this one let us define the very first

2666
04:52:51,610 --> 04:52:57,810
函数，让我们将函数称为中位数，这个函数将接受一个列表。
function and let us call the function as median this function is going to accept a list of our

2667
04:52:57,810 --> 04:53:03,930
所以我们可以将参数称为数字列表，让我们也在这里使用守卫
so we can call the argument as numbers list and let us also use the guard right over here

2668
04:53:03,930 --> 04:53:10,510
所以我们可以说当它是一个列表时，让我们传递我们的数字列表的参数
so we can say when is a list and let us pass the argument of our number list

2669
04:53:11,070 --> 04:53:16,730
所以这是一个场景，下一个场景可能是我们在这里没有得到一个合适的列表
so this is one scenario and the next scenario could be we don't get a proper list over here

2670
04:53:16,730 --> 04:53:23,490
所以为了处理这种情况，让我们定义一个更多的版本，所以我们可以说中位数我们只想
so for handling that case let us define one more version so we can say median we simply want to

2671
04:53:24,050 --> 04:53:31,110
输入，我们只想抛出一个错误，但首先我们需要创建一个别名，所以非常简单
the input and we simply want to throw an error but first we need to create an alias so it's very

2672
04:53:31,110 --> 04:53:41,390
对我们来说很容易使用这些模块，所以让我为我们的stats.dot.errors创建一个别名，这里我们可以
easy for us to use those modules so let me create an alias for our stats dot errors and here we can

2673
04:53:41,390 --> 04:53:49,410
说我们只想返回我们的errors.dot.invalid data type，现在让我们回到这个
say that we simply want to return our errors dot invalid data type now let us go back to this

2674
04:53:49,410 --> 04:53:56,010
函数，让我们看看如何实现这个，所以第一件事是我们需要验证我们的
function and let us see how we can implement this one so the first thing is we need to validate our

2675
04:53:56,010 --> 04:54:02,970
数字列表，所以再让我在顶部创建一个别名，这里我可以说我们想要
list of numbers so again let me create one more alias at the top so here i can say that we want

2676
04:54:02,970 --> 04:54:10,270
创建另一个别名，这次是为了stats.dot.our.validators，现在让我们继续执行
to create yet another alias and this time it's for stats dot our validators and now let us go down

2677
04:54:10,270 --> 04:54:16,610
在这里，我们可以简单地使用我们的数字列表，然后
right over here so here what we can do is we can simply take the list of our numbers and then we

2678
04:54:16,610 --> 04:54:24,650
将数字列表传递到我们的validators dot validate numbers
list函数中，然后在验证完成后
pipe this list of numbers inside our validators dot validate numbers list and after we validate

2679
04:54:24,650 --> 04:54:31,130
我们可以将我们的数字列表传递给另一个名为calculate的函数
our numbers list then we can pipe the output into yet another function by the name of calculate

2680
04:54:31,130 --> 04:54:38,190
中位数，现在我们还没有这个函数，但我们很快会创建它
median now we don't have that function as of now but we will create it shortly let me put a separate

2681
04:54:38,190 --> 04:54:45,870
定义calculate median函数的代码行在这里，让我稍微滚动一下
line over here and here let us define the function of calculate median now let me scroll slightly up

2682
04:54:45,870 --> 04:54:51,990
以便一切都能看到，现在让我们看看这个函数将接收到什么
so that everything is visible now let us see what this function is going to receive so the

2683
04:54:51,990 --> 04:54:58,290
函数validate numbers list的输出将被传递到calculate函数中
output of this function validate numbers list is going to be piped into the function of calculate

2684
04:54:58,290 --> 04:55:05,330
中位数，正如您所见，这个函数要么返回一个布尔值和我们的数字列表，要么
median and as you can see this function either returns a boolean and our numbers list or it

2685
04:55:05,330 --> 04:55:15,370
返回项目以及错误消息，因此让我们在各种情况下进行匹配
returns the item along with the error message so let us pattern match on various scenarios and let

2686
04:55:15,370 --> 04:55:15,830
看看我们可以用这个函数做什么，比如说我们想创建一个错误，最
us see what we can do with this function let us say we want to create an error and the most

2687
04:55:15,830 --> 04:55:23,470
最简单的方法就是处理错误，这样如果我们获得这样的输入，就会得到一个错误和
easiest one is just to handle the error so in case we get an input like this we get an error and the

2688
04:55:23,470 --> 04:55:31,090
第二个参数是一条消息，这时我们可以简单地返回错误和元组
second argument is a message at that time we can simply return back the tuple of error and the

2689
04:55:31,090 --> 04:55:37,590
不对消息做任何处理，或者我们可以简单地使用错误模块，所以你可以
message as it is or what we can do is we can simply use the errors module so either you can

2690
04:55:37,590 --> 04:55:45,350
这样做，或者我们可以简单地调用错误点无效数据类型，现在让我们看看我们还能做什么
do this or we can simply call errors dot invalid data types now let us see what more we can do with

2691
04:55:45,350 --> 04:55:52,850
这个函数，现在验证数字列表的函数也可以给我们一个元组，其中第一个
this function now the function of validate numbers list can also give us a tuple where the first

2692
04:55:52,850 --> 04:55:59,290
参数是一个布尔值，第二个参数是数字列表，所以让我们在模式匹配上
argument is a boolean and the second argument is the list of numbers so let us pattern match on

2693
04:55:59,290 --> 04:56:04,750
这种情况，让我们看看我们如何处理这个，让我定义另一个函数
this scenario and let us see how we can work with this one so let me define yet another function oh

2694
04:56:04,750 --> 04:56:10,410
还有一件事，我们可以简单地将此函数标记为私有函数，因为这个函数
one more thing what we can do is we can simply mark this function to be private now since this

2695
04:56:10,410 --> 04:56:14,810
将成为我们的辅助函数，我们不想在外部公开功能
is going to be our helper function we don't want to expose the functionality outside

2696
04:56:15,470 --> 04:56:20,950
所以我只是将此函数标记为私有函数，现在让我们再进行一次模式匹配
so i'm simply marking this function as a private function now let us have one more pattern match

2697
04:56:20,950 --> 04:56:28,010
就在这里，如果第一个参数为假，那么我们可以简单地忽略第二个参数。
right over here now what happens if the first argument is false so at that time we can simply

2698
04:56:28,010 --> 04:56:33,850
忽略第二个参数，我们不需要第二个参数，所以在这种情况下也是如此。
ignore the second argument we don't want the second argument so in this case also since

2699
04:56:33,850 --> 04:56:40,570
验证失败，让我们再次返回错误，我们可以说错误.无效。
the validation has failed let us again send back the error so we can say errors dot invalid

2700
04:56:40,570 --> 04:56:46,570
数据类型，现在让我们也定义第三种情况，所以让我们再次定义私有函数。
data type now let us define the third scenario as well so again let us define the private function

2701
04:56:47,690 --> 04:56:54,010
计算中位数，这次它接收一个元组，其中第一个参数是真。
calculate median and this time it receives a tuple where the first argument is true

2702
04:56:54,010 --> 04:57:01,210
第二个参数是我们的数字列表，让我们看看如何定义它的主体部分。
and the second argument is our list of numbers here let us see how we can define the body for

2703
04:57:01,210 --> 04:57:07,590
计算中位数函数，让我们稍微上升一点，看看我们的算法。
calculated median function let us go slightly up and let us have a look at our algorithm

2704
04:57:07,590 --> 04:57:15,230
所以对于算法，我们需要做两件事，我们需要进行排序，还需要进行计数。
so for the algorithm we need to do two things we need to sort and we also need to count now

2705
04:57:15,230 --> 04:57:20,470
让我们在这个函数中实现这些步骤，就在这里计算中位数，所以在这里我们可以。
let us implement those steps in this function right over here calculate median so here what

2706
04:57:20,470 --> 04:57:27,210
我们可以做的是，我们可以使用内置模块来获取数字列表并对其进行排序。
we can do is we can take the numbers list and we can sort it out by using the inbuilt module of

2707
04:57:27,210 --> 04:57:35,770
枚举，所以我们可以说枚举排序，现在我们有了一个排序好的元素列表，现在第二个
enum so we can say enum dot sort so now we have a sorted list of our elements now the second

2708
04:57:35,770 --> 04:57:42,670
我们需要计算元素的数量是偶数还是奇数，根据这个来决定
thing is we need to count if the number of elements are even or odd and depending on that

2709
04:57:42,670 --> 04:57:48,570
我们必须处理两种不同的情况，所以第一种情况是如何计算
scenario we have to handle two different scenarios so the first scenario was how to calculate the

2710
04:57:48,570 --> 04:57:55,270
当计数为奇数时计算中位数，第二种情况是当计数为偶数时计算中位数
median when the count is odd and the second scenario was how to calculate the median when

2711
04:57:55,270 --> 04:58:02,310
当长度为偶数时，我们需要创建另一个辅助函数，所以我们可以
the length is even so for this we would need to create yet another helper function so what we can

2712
04:58:02,310 --> 04:58:09,730
做的是我们可以将enum dot sort的输出作为参数传递给另一个函数
do is we can take the output of enum dot sort and let us pipe that output in one more function by

2713
04:58:09,730 --> 04:58:16,010
名称为get median的函数，现在我们还没有这个函数，但是我们很快就会创建它，现在这个
the name of get median now we don't have this function but we will create it shortly now this

2714
04:58:16,010 --> 04:58:21,870
get median函数将接收三个不同的参数，第一个参数是
function of get median is going to receive three different parameters the first parameter is

2715
04:58:22,510 --> 04:58:28,890
排序好的列表，第二个参数将是一个布尔值，所以我们将检查数字是否是
sorted list the second parameter is going to be a boolean value so we will check if the number is

2716
04:58:28,890 --> 04:58:35,690
奇数还是偶数，第三个参数将是计数本身，所以让我们传递参数给
odd or even and the third argument would be the count itself so let us pass the argument for

2717
04:58:35,690 --> 04:58:41,730
这个函数现在第二个参数将是一个布尔值，我们可以检查
this function now the second argument is going to be a boolean value and we can check if the

2718
04:58:41,730 --> 04:58:48,750
计数是奇数还是偶数，可以使用另一个名为整数的内置模块来调用
count is odd or even by using yet another inbuilt module by the name of integer so we can call the

2719
04:58:48,750 --> 04:58:56,310
整数的内置模块，我们可以在这里使用内置的is even函数，并让我们传递
inbuilt module of integer and here we can use the inbuilt function of is even and let us pass

2720
04:58:56,310 --> 04:59:03,470
现在为了计算计数，我们可以说数字列表，然后我们可以管道传输
the count now for calculating the count what we can do is we can say numbers list and we can pipe

2721
04:59:03,470 --> 04:59:10,810
这个传递到另一个名为枚举点计数的函数中，get函数的下一个参数
this one into another function called as enum dot count the next argument for the function of get

2722
04:59:10,810 --> 04:59:16,830
中位数将是计数本身，所以在这里我们可以说数字列表
median is going to be the count itself so here again what we can do is we can say numbers list

2723
04:59:16,830 --> 04:59:24,310
然后我们可以将输出管道传输到枚举点计数，现在你可以看到我们有一点点
and we can pipe the output into enum dot count now as you can see we have a little bit of

2724
04:59:24,310 --> 04:59:31,090
重复，所以我们可以把这个从这里拿出来，让我创建一个变量
repetition so what we can do is we can take this one out from here and let me create a variable

2725
04:59:31,090 --> 04:59:39,670
称为计数，让我把它放在这里，我们可以简单地用变量替换它
called as count let me put it right over here and we can simply replace this by the variable of

2726
04:59:39,670 --> 04:59:46,810
计数，这也会被计数的变量替换，现在要做的最后一件事就是我们只需要
count and this also gets replaced by the variable of count now the last thing to do is we simply

2727
04:59:46,810 --> 04:59:54,130
需要定义获取中位数的函数，让我在这里使用分隔符，让我
have to define the function of get median so let me use the separator right over here and let me

2728
04:59:54,130 --> 05:00:01,330
创建获取中位数的函数，现在这个函数接收三个参数，第一个
create the function of get median now this function receives three parameters the first

2729
05:00:01,330 --> 05:00:07,850
参数是我们的数字列表，第二个参数实际上是一个布尔值
parameter is our list of numbers the second parameter is actually going to be a boolean value

2730
05:00:07,850 --> 05:00:13,690
所以现在让我先写成布尔值，第三个参数将是计数，现在让我们看一下
so let me write in bool for now and the third parameter is going to be count now let us see

2731
05:00:13,690 --> 05:00:19,410
现在我们可以用这个函数做什么，对于这个函数，我们再次有两种情况，所以如果
what we can do with this function now for this function we again have two scenarios right so if

2732
05:00:19,410 --> 05:00:26,230
我们回到算法，第一种情况是奇数，第二种情况是偶数，所以我们
we go back to the algorithm so the first scenario is odd and the second scenario is even so what we

2733
05:00:26,230 --> 05:00:32,750
可以做的是我们可以在这里简单地使用模式匹配，所以这个整数点甚至会
can do is we can simply use pattern match right over here so this integer dot even is going to

2734
05:00:32,750 --> 05:00:39,890
给我们一个布尔值，要么是true要么是false，所以我们在这里可以做的是让我们进行模式匹配
give us a boolean in terms of true and false so here what we can do is let us pattern match on

2735
05:00:39,890 --> 05:00:48,250
那么这意味着这个列表不是偶数，也就是说这个列表将是奇数，而且由于这个列表
so that means this list is not even that means this list is going to be odd and since this list

2736
05:00:48,250 --> 05:00:54,590
将是奇数，我们只需取中间的元素并将其返回即可
is going to be odd we simply have to take the element at the center and return it back and

2737
05:00:54,590 --> 05:01:01,430
幸运的是，这很容易，我们将使用内置的enum模块，然后
fortunately it's very easy again for this we are going to use the inbuilt module of enum and there

2738
05:01:01,430 --> 05:01:07,590
有一个内置函数叫做at，这个函数接受两个不同的参数，第一个是
is an inbuilt function called as at so this function accepts two different parameters the first is

2739
05:01:07,590 --> 05:01:14,730
将是我们的数字列表，第二个参数将是索引，所以对于
going to be our list of numbers and the second parameter is going to be the index so for the

2740
05:01:14,730 --> 05:01:21,530
索引，我们可以简单地取出计数，然后将计数除以二，现在
index what we can do is we can simply take the count and we can divide that count by two now

2741
05:01:21,530 --> 05:01:29,190
这里有一个小问题，将计数除以二实际上会返回一个浮点数
there is one small issue over here so this count divided by two this actually returns back a float

2742
05:01:29,190 --> 05:01:36,790
而索引值不能是浮点数，所以假设这个值返回一个整数，如4.5
and the index value cannot be float so suppose if this value returns an integer such as 4.5

2743
05:01:36,790 --> 05:01:43,610
那么在这种情况下，我们没有任何值，或者说我们没有任何叫做4.5的索引
so in that case we don't have any values or rather we don't have any index called as 4.5

2744
05:01:43,610 --> 05:01:50,270
所以我们需要做的是进行整数除法，而不是浮点除法
so what we need to do is we need to have an integer division and not a float division over

2745
05:01:50,270 --> 05:01:56,330
所以为了确保我们得到一个整数，我们可以使用内置函数
here so in order to ensure that we get back an integer we can use the inbuilt function of

2746
05:01:56,330 --> 05:02:02,930
除法，所以第一个参数将是计数，第二个参数将是
division so the first argument is going to be the count and the second argument is going to be

2747
05:02:02,930 --> 05:02:10,130
现在这个函数必须是私有的，所以让我将它定义为def和p，这样
the number now again this function has to be private so let me put it as def and p so this

2748
05:02:10,130 --> 05:02:17,190
这是列表奇数的第一种情况，第二种情况是列表是偶数时发生的情况
is the first scenario where the list is odd the second scenario is what happens when the list is

2749
05:02:17,190 --> 05:02:24,950
所以让我将所有这些都复制过来，然后粘贴到这里，现在是第二种情况
even so let me just copy all of this and let me paste it right over here now for the second

2750
05:02:24,950 --> 05:02:31,770
情况是列表是偶数，所以我们在这里得到一个true，让我们看看我们应该做什么
scenario is the list is even so we get a true right over here and let us see what we are supposed

2751
05:02:31,770 --> 05:02:38,270
在这种情况下应该做什么，所以如果你回到算法，我们必须取两个值
to do in this case so if you go back to the algorithm so in this case we have to take two

2752
05:02:38,270 --> 05:02:45,430
从中心取值，然后我们只需将它们除以二并返回值
values from the center and then we simply have to divide them by two and return back the value so

2753
05:02:45,430 --> 05:02:51,330
现在让我们在这里做这些事情，我们可以创建两个变量
let us do exactly those things right over here now what we can do is let us create two variables to

2754
05:02:51,330 --> 05:02:59,110
保存从中心取得的值，我们可以说第一个变量是a，让我复制这个
hold the values from the center so we can say that the first variable is a and let me copy this

2755
05:02:59,110 --> 05:03:06,450
从这里开始就是这个函数，现在在这种情况下，我们必须取一个先前的值，所以如果我回去
function right from here now in this case we have to take one previous value right so if I go back

2756
05:03:06,450 --> 05:03:13,150
我们要取这个值，也就是在这里，所以我们可以说计数
over here we want to take the value which is right over here so what we can do is we can say count

2757
05:03:13,670 --> 05:03:20,630
减去一个，然后我再复制粘贴给下一个值，我们不需要减去一个
minus of one and let me again copy and paste for the next value we don't need minus one

2758
05:03:21,170 --> 05:03:28,610
让我们把那个变量称为b，现在我们有了来自中心的两个值，我们只需要
and let us call that variable as b so now we have both the values from the center and we simply have

2759
05:03:28,610 --> 05:03:37,690
加上b，然后我们只需要将它们除以二，就这样，现在我保存后
to add a plus of b and we just want to divide them by two and that's it now as soon as I saved

2760
05:03:37,690 --> 05:03:43,450
我的文件中，我们可以看到我们在这里得到了一个小错误，那么这是在说什么呢？
my file we can see that we are getting a small error right over here so what is this saying that

2761
05:03:43,450 --> 05:03:50,410
在调用宏之前，你必须要求整数，所以发生的情况是，Elixir实际上是
you must require integer before invoking the macro so what's happening is elixir is actually

2762
05:03:50,410 --> 05:03:58,410
使用宏，所以宏是一种生成另一段代码的代码，但现在我们不需要
using a macro so macro is a kind of a code that generates yet another code but for now we don't

2763
05:03:58,410 --> 05:04:04,350
去关注细节，我们只需要按照这个错误信息告诉我们的去做，所以如果
have to go into the specifics we just have to do whatever this error message is telling us so if

2764
05:04:04,350 --> 05:04:11,850
你只需要查看消息，它是在说我们只需要要求整数，所以我们就按照这个要求去做
you just refer the message it is saying that we simply have to require integer so let's do exactly

2765
05:04:11,850 --> 05:04:19,130
同样的事情，让我回到顶部，在这里我可以说我想要要求整数模块
the same thing so let me go to the top and here I can say that I want to require the module of

2766
05:04:19,130 --> 05:04:26,730
整数，就这样，现在错误应该消失了，是的，现在所有的错误都解决了
integer and that's it now the error should be gone yes now all of the errors are sorted out

2767
05:04:26,730 --> 05:04:34,390
最后一件事是让我们进入我们的公共API，让我们进入lib文件夹，在lib文件夹下面让我们进入
the last thing is let us go to our public API let us go to lib and under lib let us go to

2768
05:04:34,390 --> 05:04:41,330
stats模块，让我们在这里创建一个def代理，同时让我们使用
the module of stats and let us create a def delegate right over here as well let us use the

2769
05:04:41,330 --> 05:04:48,570
def代理的宏，我们可以说我们想定义中值函数，现在这个函数
macro of def delegate and we can say that we want to define the function of median now this function

2770
05:04:48,570 --> 05:04:55,970
接受我们数字的列表，我们只想将这个函数委托给模块
accepts the list of our numbers and we simply want to delegate this function to the module of

2771
05:04:55,970 --> 05:05:01,850
中值，但在此之前，让我们在顶部创建一个别名，这样我们可以导入
median but before let us create an alias right on the top so what we can do is we can import

2772
05:05:01,850 --> 05:05:08,490
在同一行上导入不同的模块，所以我们可以说我也想在这里导入中值
different modules on the same line so we can say that I also want to import median right over here

2773
05:05:08,890 --> 05:05:15,530
现在在第九行我们只是想将执行委托给中值模块
now here on line number nine we simply want to delegate the execution to the module of median

2774
05:05:15,530 --> 05:05:23,370
现在让我打开终端，让我进入ix，并让我清理一切
so now let me open up my terminal and let me go inside ix and let me clear up everything

2775
05:05:23,370 --> 05:05:30,970
所以在这里让我们尝试调用那个函数，所以我们可以说stats中的中值，让我们创建一个列表
so here let us try an invoke that function so we can say stats dot median and let us create a list

2776
05:05:30,970 --> 05:05:37,890
就在这里，让我传递这些值，这样我们就可以看到我们得到的值是50
right over here and let me pass the values so as we can see we are getting the value as 50

2777
05:05:37,890 --> 05:05:44,450
现在我所做的是这是我们奇数的列表，接下来让我再传递一个列表
now what I have done is this is a list of our odd numbers next let me pass one more list which

2778
05:05:44,450 --> 05:05:52,070
有偶数，所以让我把90拿出来，我不需要90，而且在这种情况下我们得到的是
has even numbers so let me take out 90 I don't need 90 from here and in this case we are getting

2779
05:05:52,070 --> 05:05:58,130
值是45，就是这样，这个视频到此为止，我会在下一个视频中见到你们
the value as 45 well that's it for this video and I will catch you right in the next one

2780
05:05:58,670 --> 05:06:04,490
大家好，欢迎来到这个系列的最后一个视频，所以最后一个视频是关于学习的
hello and welcome to the last video of this series so the last video is all about learning

2781
05:06:04,490 --> 05:06:10,470
有一种被称为众数的东西，那么众数到底是什么，让我来尝试解释一下
something which is called as mode now what exactly is a mode so let me try and explain

2782
05:06:10,470 --> 05:06:14,710
但在此之前，我所做的是在幕后创建了这个文件
but before that what I've done is behind the scenes I have created this file

2783
05:06:14,710 --> 05:06:22,930
在集中趋势中的mode.ex，现在让我们看看如何找到我们元素的众数
mode.ex inside central tendency and let us see now how we can find the mode of our elements

2784
05:06:22,930 --> 05:06:31,590
那么，我们所说的众数到底是什么，众数基本上是最常重复的元素
so what exactly do we mean by mode so mode is basically the element which repeats most often

2785
05:06:31,590 --> 05:06:39,110
例如，如果我们有这个数值数组，那么这些数值的众数将是这些数值
so for example if we have this array of values then the mode of these values would be the values

2786
05:06:39,110 --> 05:06:44,930
重复次数最多的值，现在在这个例子中，重复次数最多的值是四和八
that are repeating the most now in this example the most repeating values are four and eight

2787
05:06:44,930 --> 05:06:51,470
这就是为什么这个模式是四和八，现在你一定在想模式有什么用
that's why the mode of this is four and eight now you must be thinking what is the use of mode

2788
05:06:51,470 --> 05:06:57,530
所以让我试着帮你解释一下为什么模式非常重要，现在假设这些值实际上
so let me try and help you why mode is very important now suppose these values actually

2789
05:06:57,530 --> 05:07:04,990
代表路易斯正在销售的糖果的产品ID，例如一个可能是
stand for the product id of the candies which louis is selling so for example one could be

2790
05:07:04,990 --> 05:07:11,890
红色糖果的产品ID，二可以是黄色糖果的产品ID，三可以是
product id for the red candies two could be the product id for the yellow one three could be for

2791
05:07:11,890 --> 05:07:19,130
绿色糖果的产品ID，通过找到模式，我们可以了解路易斯能够销售哪些糖果
the green one so by finding out the mode we can understand which candies louis was able to sell

2792
05:07:19,130 --> 05:07:26,310
最多的，所以在这个例子中，我们可以说ID为四的糖果和ID为八的糖果
the most so in this example we can say that the candy with the idea of four and the candy with

2793
05:07:26,310 --> 05:07:32,290
是店里最受欢迎的糖果，让我们看看如何找到
the idea of eight were the most popular candies inside the store so let us see how we can find

2794
05:07:32,290 --> 05:07:38,770
更多，我在这里给出了步骤，基本上是一个三步过程，第一步是我们
more so i have given the steps over here so it's basically a three-step process the first is we

2795
05:07:38,770 --> 05:07:45,450
需要找到发生的次数或频率，然后我们需要找到最大值
have to find the number of occurrences or the frequencies next we have to find the maximum

2796
05:07:45,450 --> 05:07:51,950
发生次数，最后我们需要将具有最大发生次数的元素进行分组
number of occurrences and finally we have to group the elements which have the maximum occurrences

2797
05:07:51,950 --> 05:07:57,290
这次，不直接编写代码，让我来演示一下在ix中如何找到解决方案。
now instead of directly writing the code this time let me show you inside the ix how you can

2798
05:07:57,290 --> 05:08:04,330
找到这个问题的解决方案，让我复制一下，然后打开我的终端。
find the solution for this one so let me just copy this one and let me open up my terminal

2799
05:08:04,330 --> 05:08:12,370
让我进入我的ix，并清理屏幕。现在，如果我们参考一下步骤，第一步是...
so let me go inside my ix and let me clear up the screen now if we refer to the steps the first

2800
05:08:12,370 --> 05:08:18,790
我们必须找到出现次数或频率，所以让我把值粘贴过来。
step is we have to find the occurrences or the frequencies so let me paste the values right over

2801
05:08:18,790 --> 05:08:25,390
在这里，我们可以通过使用内置函数来找出频率，所以我们可以将这些值连接起来。
here and we can find out the frequencies by using the inbuilt function so we can pipe these values

2802
05:08:25,390 --> 05:08:33,890
到enum dot frequencies，就是这样，现在我们有了所有的值及其频率。
to enum dot frequencies and here it is so now we have all of the values and their frequencies as

2803
05:08:33,890 --> 05:08:40,070
好吧，我想要做的是将这个简单地保存在一个叫作的变量中。
well so what i would like to do is i would like to simply save this in a variable called as

2804
05:08:40,070 --> 05:08:47,450
ranked map，现在我们有了一个有序映射，下一步是找到最大的次数。
ranked map so now we have a ranked map the next step is we have to find the maximum number of

2805
05:08:47,450 --> 05:08:54,550
出现次数，让我们看看如何做到这一点，让我清理一下屏幕，现在我们有了排名映射。
occurrences so let us see how we can do that let me clear up my screen so now we have the rank map

2806
05:08:55,190 --> 05:09:01,430
为了找出最大的次数，我们可以使用排名映射。
for finding out the maximum number of occurrences what we can do is we can take the rank map

2807
05:09:01,430 --> 05:09:08,530
从这个地图上，我们只需要取出值，所以我们可以说map.values，让我们看看它是什么样子
and from this map let us simply take the values so we can say map dot values and let us see how it

2808
05:09:08,530 --> 05:09:15,510
看起来就像这样，这些只是值，下一步，我们只需要找到最大值
looks like so these are just the values the next is we simply have to find the maximum value out

2809
05:09:15,510 --> 05:09:23,090
从这个地图中，我们可以将它传递给另一个名为enum的函数
of this map so what we can do is we can pipe this one into yet another function called as enum dot

2810
05:09:23,090 --> 05:09:30,810
max，就是它了，重复次数最多的值是三次，如果我们参考一下
max and here it is so the maximum number any value is repeating is thrice and if we refer to

2811
05:09:30,810 --> 05:09:36,610
我们的地图，我们可以看到四重复三次，八也重复三次
our map we can see that four is repeating thrice and eight is also repeating thrice

2812
05:09:37,450 --> 05:09:43,770
现在有一个小问题，如果元素没有重复出现，那么就无法找到众数
now there is a small caveat for finding out the mode in case the elements are not repeating more

2813
05:09:43,770 --> 05:09:50,190
在这种情况下，我们无法找到众数，但是如果我们有重复出现的元素
than once in that case we can't find out the mode but if we have elements which are repeating more

2814
05:09:50,190 --> 05:09:57,550
只要重复一次，那么我们就可以找到一个有效的众数，所以现在让我做一件事，让我复制这个
than once only in that case we can find a valid mode so now let me do one thing let me copy this

2815
05:09:57,550 --> 05:10:04,890
并将其保存到另一个名为max的变量中，让我清理所有这些东西
one and let me save this into yet another variable called as max let me clear up all of these things

2816
05:10:04,890 --> 05:10:11,710
所以现在我们有了排名地图，我们也有了最大计数，下一步，我们只需要
so now we have the ranked map and we also have the maximum count the next step is we simply have to

2817
05:10:11,710 --> 05:10:18,930
对这个排名地图进行筛选，找出最大出现次数的元素。在这种情况下，我们看到数字4出现了四次。
filter this ranked map for the maximum number of occurrences so in this case we saw that four is

2818
05:10:18,930 --> 05:10:24,650
数字4重复了三次，数字8也重复了三次，所以我们只需将它们筛选出来。
repeating thrice and eight is also repeating thrice so we simply want to filter it out so let us see

2819
05:10:24,650 --> 05:10:31,030
我们该如何做呢？我们可以取出排名地图，然后使用...
how we can do this so for this what we can do is we can take the ranked map and then we can use the

2820
05:10:31,030 --> 05:10:38,790
函数名为map.filter，它接受两个参数，第一个是地图（map），还有...
function called as map dot filter now this function accepts two parameters the first is your map and

2821
05:10:38,790 --> 05:10:44,770
第二个参数是匿名函数，现在我们来编写一个函数，对于每个...
the second is your anonymous function so let us write a function right over here now for each

2822
05:10:44,770 --> 05:10:51,950
在每次迭代中，这个函数将接收到来自地图的键和值对，然后...
iteration this function is going to receive the key and also the value pairs from our map and for

2823
05:10:51,950 --> 05:10:58,570
在每次迭代中，我们只需筛选出值等于最大值的元素。
each iteration we simply want to filter out for the values where the value is equal to our maximum

2824
05:10:58,570 --> 05:11:05,710
现在我们有了一个经过筛选的地图，下一步我们只需取出键即可。
count so now we have a filtered map the next step is we simply have to take out the keys and that's

2825
05:11:05,710 --> 05:11:12,530
那么我们看看如何实现这一点，我们可以采用相同的表达式，然后...
it so let us see how we can do that so we can take this exact same expression and then we can say that

2826
05:11:12,530 --> 05:11:19,730
我们只需从地图中取出键，就完成了。我们得到了最终答案，我们继续进行吧。
we just want to take the keys from our map and that's it we have our final answer so let us go

2827
05:11:19,730 --> 05:11:25,130
回到代码编辑器，让我们看看如何在这里完成所有这些事情。
back to the code editor and let us see how we can do all of these things right over here now for this

2828
05:11:25,130 --> 05:11:30,390
例如，我不会进行所有的验证和错误报告，因为我想你应该知道。
example i am not going to do all of the validation and error reporting because i suppose you know

2829
05:11:30,390 --> 05:11:36,270
如何完成所有这些事情，让我们直接进入并看看如何编写这些函数。
how to do all of those things so let us directly go inside and see how to write the functions for

2830
05:11:36,270 --> 05:11:43,350
那么让我来处理所有这些事情，我们在这里定义一个函数，我们可以说
mode so let me take all of these things up and here let us define a function and here we can say

2831
05:11:43,350 --> 05:11:49,590
我们想要定义一个名为mode的函数，这个函数接收一个参数，它是
that we want to define a function called as mode now this function receives a parameter which is

2832
05:11:49,590 --> 05:11:57,290
数字列表，所以我可以在这里添加一个保护，这是我的数字列表，如果你
the list of numbers so i can simply add a guard over here so is list for my numbers now if you

2833
05:11:57,290 --> 05:12:01,710
如果你愿意，你可以进行所有额外的验证，但对于这个视频，我不会进行验证。
want you can do all of the extra validation but for this video i'm not going to do the validation

2834
05:12:01,710 --> 05:12:08,670
所以第一步是找到频率，让我创建一个名为ranked map的变量
so the first step was finding the frequencies so let me create a variable called as ranked map

2835
05:12:08,670 --> 05:12:15,390
在这里，我们可以简单地取出这些数字，并将这些数字传递给enum。
and here what we can do is we can simply take the numbers and let us pipe those numbers to enum.

2836
05:12:16,850 --> 05:12:23,790
接下来，我们可以尝试找到最大出现次数，所以为此我们可以这样做。
frequencies next what we can do is let us try and find the maximum number of occurrences so for that

2837
05:12:23,790 --> 05:12:31,490
我们可以做的是，我们可以获取排名映射，然后将此函数传递给map.values，这样我们现在就有了所有的值
what we can do is we can take the ranked map we can pipe this function into map.values so now we

2838
05:12:31,490 --> 05:12:37,270
我们现在拥有了所有的值，接下来让我们找出最大的出现次数，这样我们就能
have all of the values with us next let us find out the maximum number of occurrences so we can

2839
05:12:37,270 --> 05:12:44,830
将其传递给另一个函数enum.max，这样我们就有了排名映射，还有
pipe this into yet another function enum.max so now we have the ranked map and we also have

2840
05:12:44,830 --> 05:12:50,950
最大的出现次数，现在我们只需要过滤掉我们的
the maximum number of occurrences now the last thing to do is we simply have to filter out our

2841
05:12:50,950 --> 05:12:58,390
排名映射，为此让我们创建一个辅助函数，所以在这里让我们将其传递给另一个
ranked map and for that let us create a helper function so here let us pipe this into yet another

2842
05:12:58,390 --> 05:13:04,530
名为mode func的函数，现在这个函数将接受两个参数
function by the name of mode func now this function is going to accept two parameters the

2843
05:13:04,530 --> 05:13:10,450
第一个参数是最大的出现次数，第二个参数是
first parameter would be for the maximum number of occurrences and the second parameter would be

2844
05:13:10,450 --> 05:13:18,370
排名映射本身，所以让我定义一个私有函数mode of func，现在这个函数接受
for the rank map itself so let me define a private function mode of func now this function accepts

2845
05:13:18,370 --> 05:13:24,390
两个参数，第一个参数是最大的出现次数，第二个参数是
two parameters the first parameter is for the maximum number of occurrences the second parameter

2846
05:13:24,390 --> 05:13:31,170
我们排名的映射，现在我们需要注意另一个条件，那就是
is for our rank of map now here we need to take care of one more condition and that is

2847
05:13:31,170 --> 05:13:38,330
只有当出现次数超过一次时，我们才能找到更多的内容，所以对于这个函数定义
we can find more only if the number of occurrences are more than one so for this function definition

2848
05:13:38,330 --> 05:13:45,090
让我们在这里进行模式匹配，这样我们就可以看到，如果最大数量的
let us have a pattern match right over here so we can see that in case the maximum number of

2849
05:13:45,090 --> 05:13:51,190
出现次数为一，那么我们只需要忽略排名映射，因为我们无法找到
occurrences are one in that case we simply have to ignore the rank map because we can't find out

2850
05:13:51,190 --> 05:13:57,570
众数，我们只需要返回nil，但是如果出现次数超过
mode and let us simply return back nil but in case we have the occurrences which are more than

2851
05:13:57,570 --> 05:14:04,190
一次，为了处理这种情况，让我们在这里定义一个额外的函数重载，这样我们就能
one so to handle that situation let us define one more function overload right over here so we can

2852
05:14:04,190 --> 05:14:11,010
说出func的众数，并且第一个参数是最大值，第二个参数是我们的
say mode of func and the first parameter was for the maximum value the second parameter was for our

2853
05:14:11,010 --> 05:14:18,010
排名映射，所以让我们拿出排名映射，然后我们只需要过滤掉，这样我们就可以说
ranked map so let's take the ranked map and next we simply have to filter it out so we can say

2854
05:14:18,010 --> 05:14:23,890
map.过滤器，这里让我们定义匿名函数，这样我们就可以说函数
map dot filter and here let us define the anonymous function so we can say function

2855
05:14:23,890 --> 05:14:31,210
现在对于每次迭代，它将接收键和值，我们需要做的是
now for each iteration this is going to receive the key and also the value and what we need to do is

2856
05:14:31,210 --> 05:14:38,770
我们只需要在值等于最大值时将其过滤掉，最后我们只需要
we simply want to filter it out when the value is equal to our max and the last thing is we simply

2857
05:14:38,770 --> 05:14:47,250
必须从这个中取出键，这样我们就可以说map.keys，现在要做的最后一件事是让
have to take out the keys from this one so we can say map dot keys now the last thing to do is let

2858
05:14:47,250 --> 05:14:54,510
让我们转到我们的stats.ex，并在这里创建一个def代理，这样我们就可以说def
us go to our stats dot ex and let us create a def delegate right over here so we can say def

2859
05:14:54,510 --> 05:15:02,370
代理，让我们为mode创建一个函数，这也接受我们的数字列表，我们只需
delegate let us create a function for the mode this also accepts our numbers list and we simply

2860
05:15:02,370 --> 05:15:08,770
想将这个委派给模块mode，但首先让我们在这里导入它，这样我们就可以
want to delegate this to the module of mode but first let us import it right over here so we can

2861
05:15:08,770 --> 05:15:15,930
说我们还想导入mode，这个我们只想委派给mode，现在让我折叠
say we also want to import mode and this one we simply want to delegate to mode now let me collapse

2862
05:15:15,930 --> 05:15:23,090
我的侧边栏，让我打开终端，现在让我们重新编译一次，让我清空
my sidebar and let me open up my terminal now let us recompile this one more time and let me clear

2863
05:15:23,090 --> 05:15:29,810
所有的东西，这样现在我们就可以调用stats.mode，并让我在这里传递值
up everything so now we can call stats dot mode and let me pass the values right over here

2864
05:15:30,330 --> 05:15:36,910
正如预期的那样，我们得到的答案是四和八，好，这就是我们这个的结束
and as expected we get back the answer as four and eight well this brings us to the end of this

2865
05:15:36,910 --> 05:15:42,950
当然，在我说出我的最后话之前，我想向你展示一些东西，现在，如果
course but before i can say my final words i wanted to show you a couple of things now if

2866
05:15:42,950 --> 05:15:48,730
你参考我的github存储库中的代码，这是一个现在在我的官方github里的
you refer to the code from my github repository so which is this one now inside my official github

2867
05:15:48,730 --> 05:15:55,250
我所做的是，在存储库中实现了两个更多的功能，它们位于文件夹下面。
repository what i have done is i have implemented two more functionality which are under the folder

2868
05:15:55,250 --> 05:16:02,730
第一个是关于变异性的，第二个是关于标准差的。
of variability the first one is about variance the second one is all about your standard deviation

2869
05:16:02,730 --> 05:16:08,770
因为我认为它们与数学建模和统计有关，所以我不打算在本教程系列中涵盖这些部分。
now i am not going to cover these parts inside this tutorial series because i think they are

2870
05:16:08,770 --> 05:16:15,230
这部分涉及到你的数学建模和统计，而这门课程旨在为您提供一个公正的
towards your mathematical modeling and statistics while this course was designed to give you a fair

2871
05:16:15,230 --> 05:16:20,970
有关Elixir函数式编程的概念，但我将它们保留作为参考，您可以参考它们。
idea about functional programming in elixir but i have kept them for a reference you can refer them

2872
05:16:20,970 --> 05:16:27,710
您可以看到我如何为统计建模方差和标准差，这就是
and you can see how i am able to model variance and standard deviation for statistics well that's

2873
05:16:27,710 --> 05:16:33,410
我就是这些了，下次见。嗨，我希望您在学习函数式编程时真的很开心。
it from me and i will catch you in the next one hi i hope you really had fun learning functional

2874
05:16:33,410 --> 05:16:38,070
与我一起学习编程，现在这门课程旨在教您所有基础
programming along with me now this course was designed to teach you all of the basic

2875
05:16:38,070 --> 05:16:44,450
函数式编程语言的概念，但Elixir还有更多要学习的，接下来的事情
concepts of the functional programming language but elixir has a lot more to it the next things

2876
05:16:44,450 --> 05:16:50,130
您将想要学习的是关于并发和OTP框架的一切，之后您可以
that you will want to learn is all about the concurrency and the otp framework and after you

2877
05:16:50,130 --> 05:16:54,410
学习并发框架，然后你可以继续学习令人惊叹的凤凰框架。
learn the concurrency framework then you can go ahead and you can learn the awesome phoenix

2878
05:16:54,410 --> 05:16:59,870
还有框架。现在回到这门课程，如果你觉得函数式编程有些困难，
framework as well now coming back to this course if you are finding functional programming to be

2879
05:16:59,870 --> 05:17:06,230
这不是你的错，需要一些时间、耐心和练习，才能够。
a little difficult it's not your fault it takes some time patience and practice before you can

2880
05:17:06,230 --> 05:17:11,570
掌握了函数式编程语言之后，
functional programming language but after you get the hang of functional programming language

2881
05:17:11,570 --> 05:17:16,690
相信我，你再也不会回到面向对象编程或者
believe me you would never want to go back to your object-oriented programming or your

2882
05:17:16,690 --> 05:17:23,070
命令式编程范式。所以让我总结一下这门课程，也让我总结一下这个视频。
imperative programming paradigm as well so let me conclude this course and let me conclude this video

2883
05:17:23,730 --> 05:17:29,270
请在评论中告诉我你对这门课程的看法，你也可以与我联系。
and do let me know in the comments how do you find this course and you can also connect with

2884
05:17:29,270 --> 05:17:35,130
我的网站是octalium.com，你也可以在Twitter上关注我，我的用户名是@octalium。
me on my website it's octalium.com and also on twitter my handle is at the rate octalium

2885
05:17:35,130 --> 05:17:40,150
如果你慷慨的话，你可以给我买杯咖啡，网址是buymeocoffee.com。
and if you're feeling generous you can you can buy me a coffee it's buymeocoffee.com

2886
05:17:41,210 --> 05:17:46,290
octalium，如果你想学习更多的概念，请告诉我。
octalium and also do let me know if you want to learn some more concepts from me if you would

2887
05:17:46,290 --> 05:17:52,050
想学习 OTP 框架，Phoenix 框架，或者如果你想学习数学的话
like to learn otp framework the phoenix framework or if you would like to learn mathematics and

2888
05:17:52,050 --> 05:17:56,760
或者从我这里学习统计建模或者其他你想学的主题
statistical modeling from me or any other topic that you would like to learn from me as well

2889
05:17:57,390 --> 05:18:01,270
这就是我要说的了，下次见，再见
so that's it from me and i will catch you in the next one bye

